diff --git a/.gitignore b/.gitignore
index 95ff567..28f5a24 100644
--- a/.gitignore
+++ b/.gitignore
@@ -38,6 +38,7 @@ a.out
 
 
 # Other
+*.DS_Store
 *.exe
 *.tgz
 *.tar
@@ -52,4 +53,6 @@ a.out
 
 # MPLABX Whitelist
 !project.xml
-!configurations.xml
\ No newline at end of file
+!configurations.xml
+/Lab0/Lab0.X/dist/
+/Lab0/Lab0.X/build/
\ No newline at end of file
diff --git a/Common/AD.c b/Common/AD.c
new file mode 100644
index 0000000..c1e2000
--- /dev/null
+++ b/Common/AD.c
@@ -0,0 +1,527 @@
+/*
+ * File:   AD.c
+ * Author: mdunne
+ *
+ * Created on November 22, 2011, 8:57 AM
+ */
+
+#include <xc.h>
+#include <BOARD.h>
+#include <AD.h>
+
+#include <sys/attribs.h>
+
+#include <serial.h>
+
+#include <stdio.h>
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+//#define AD_DEBUG_VERBOSE
+
+
+#define NUM_AD_PINS 6
+#define NUM_AD_PINS_UNO 16
+
+
+//#define AD_DEBUG_VERBOSE
+#ifdef AD_DEBUG_VERBOSE
+#include "serial.h"
+#define dbprintf(...) while(!IsTransmitEmpty()); printf(__VA_ARGS__)
+#else
+#define dbprintf(...)
+#endif
+
+
+
+#define ALLADPINS (AD_A0|AD_A1|AD_A2|AD_A3|AD_A4|AD_A5)
+
+
+
+
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                            *
+ ******************************************************************************/
+static unsigned int AD1PCFG_MASKS[NUM_AD_PINS] = {_AD1PCFG_PCFG2_MASK, _AD1PCFG_PCFG4_MASK,
+    _AD1PCFG_PCFG8_MASK, _AD1PCFG_PCFG10_MASK, _AD1PCFG_PCFG12_MASK, _AD1PCFG_PCFG14_MASK};
+
+static unsigned int AD1CSSL_MASKS[NUM_AD_PINS] = {_AD1CSSL_CSSL2_MASK, _AD1CSSL_CSSL4_MASK, 
+    _AD1CSSL_CSSL8_MASK, _AD1CSSL_CSSL10_MASK, _AD1CSSL_CSSL12_MASK, _AD1CSSL_CSSL14_MASK};
+
+static unsigned int AD1PCFG_POS[NUM_AD_PINS] = {_AD1PCFG_PCFG2_POSITION, _AD1PCFG_PCFG4_POSITION,
+    _AD1PCFG_PCFG8_POSITION, _AD1PCFG_PCFG10_POSITION, _AD1PCFG_PCFG12_POSITION, _AD1PCFG_PCFG14_POSITION};
+
+
+static unsigned int ActivePins;
+static unsigned int PinsToAdd;
+static unsigned int PinsToRemove;
+static unsigned int PinCount;
+static unsigned int ADValues[NUM_AD_PINS];
+static int PortMapping[NUM_AD_PINS];
+
+static char ADActive;
+static char ADNewData = FALSE;
+
+
+
+/*******************************************************************************
+ * PRIVATE FUNCTION PROTOTYPES                                                            *
+ ******************************************************************************/
+char AD_SetPins(void);
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @function AD_Init(void)
+ * @param None
+ * @return SUCCESS or ERROR
+ * @brief Initializes the A/D subsystem and enable battery voltage monitoring
+ * @author Max Dunne, 2013.08.10 */
+char AD_Init(void)
+{
+
+    if (ADActive) {
+        return ERROR;
+    }
+    int pin = 0;
+	ADActive = TRUE;
+    AD_SetPins();
+    for (pin = 0; pin < NUM_AD_PINS; pin++) {
+        ADValues[pin] = -1;
+    }
+    IEC1bits.AD1IE = 0;
+    IFS1bits.AD1IF = 0;
+    IPC6bits.AD1IP = 1;
+    IPC6bits.AD1IS = 3;
+    IEC1bits.AD1IE = 1;
+    AD1CON1bits.ON = 1;
+    ADNewData = FALSE;
+    //wait for first reading to ensure  battery monitor starts in the right spot
+    while (!AD_IsNewDataReady()) {
+#ifdef AD_DEBUG_VERBOSE
+        PutChar('.');
+#endif
+    }
+    //set the first values for the battery monitor filter
+
+    return SUCCESS;
+}
+
+/**
+ * @function AD_AddPins(unsigned int AddPins)
+ * @param AddPins - Use #defined AD_XX OR'd together for each A/D Pin you wish to add
+ * @return SUCCESS OR ERROR
+ * @brief Remove pins from the A/D system.  If any pin is not active it returns an error
+ * @author Max Dunne, 2013.08.15 */
+char AD_AddPins(unsigned int AddPins)
+{
+    if (!ADActive) {
+        dbprintf("%s called before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((AddPins == 0) || (AddPins > ALLADPINS)) {
+        dbprintf("%s returning ERROR with pins outside range: %X\r\n", __FUNCTION__, AddPins);
+        return ERROR;
+    }
+    if (ActivePins & AddPins) {
+        dbprintf("%s Returning ERROR for pins already in state: %X \r\n", __FUNCTION__, AddPins);
+        return ERROR;
+    }
+    //setting the pins to be added during the next interrupt cycle
+    PinsToAdd |= AddPins;
+    return SUCCESS;
+}
+
+/**
+ * @function AD_RemovePins(unsigned int RemovePins)
+ * @param RemovePins - Use #defined AD_XX OR'd together for each A/D Pin you wish to remove
+ * @return SUCCESS OR ERROR
+ * @brief Remove pins from the A/D system. If any pin is not active it returns an error
+ * @author Max Dunne, 2013.08.15 */
+char AD_RemovePins(unsigned int RemovePins)
+{
+    if (!ADActive) {
+        dbprintf("%s called before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((RemovePins == 0) || (RemovePins > ALLADPINS)) {
+        dbprintf("%s returning ERROR with pins outside range: %X\r\n", __FUNCTION__, RemovePins);
+        return ERROR;
+    }
+    if (!(ActivePins & RemovePins)) {
+        dbprintf("%s Returning ERROR for pins already in state: %X \r\n", __FUNCTION__, RemovePins);
+        return ERROR;
+    }
+
+    //setting the pins to be added during the next interrupt cycle
+    PinsToRemove |= RemovePins;
+    return SUCCESS;
+}
+
+/**
+ * @function AD_ActivePins(void)
+ * @param None
+ * @return Listing of all A/D pins that are active
+ * @brief Returns a variable of all active A/D pins. An individual pin can be determined if
+ *        active by "anding" with the AD_PORTXX Macros.
+ * @note This will not reflect changes made with AD_AddPins or AD_RemovePins until the next A/D
+ *       interrupt cycle.
+ * @author Max Dunne, 2013.08.15 */
+unsigned int AD_ActivePins(void)
+{
+    return ActivePins;
+}
+
+/**
+ * @function AD_IsNewDataReady(void)
+ * @param None
+ * @return TRUE or FALSE
+ * @brief This function returns a flag indicating that the A/D has new values since the last
+ *        read of a value
+ * @author Max Dunne, 2013.08.15 */
+char AD_IsNewDataReady(void)
+{
+    if (ADNewData) {
+        ADNewData = FALSE;
+        return TRUE;
+    }
+    return FALSE;
+}
+
+/**
+ * @function AD_ReadADPin(unsigned int Pin)
+ * @param Pin - Used #defined AD_XX to select pin
+ * @return 10-bit AD Value or ERROR
+ * @brief Reads current value from buffer for given pin
+ * @author Max Dunne, 2011.12.10 */
+unsigned int AD_ReadADPin(unsigned int Pin)
+{
+    if (!ADActive) {
+        dbprintf("%s returning ERROR before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if (!(ActivePins & Pin)) {
+        dbprintf("%s returning error with unactivated pin: %X %X\r\n", __FUNCTION__, Pin);
+        return ERROR;
+    }
+    unsigned char TranslatedPin = 0;
+    while (Pin > 1) {
+
+        Pin >>= 1;
+        TranslatedPin++;
+    }
+    return ADValues[PortMapping[TranslatedPin]];
+}
+
+/**
+ * @function AD_End(void)
+ * @param None
+ * @return None
+ * @brief Disables the A/D subsystem and release the pins used
+ * @author Max Dunne, 2013.09.20 */
+void AD_End(void)
+{
+    int pin;
+    if (!ADActive) {
+        return;
+    }
+    IEC1bits.AD1IE = 0;
+    AD1CON1CLR = _AD1CON1_ON_MASK;
+    PinsToRemove = ALLADPINS;
+    AD_SetPins();
+    for (pin = 0; pin < NUM_AD_PINS; pin++) {
+        ADValues[pin] = -1;
+    }
+    ActivePins = 0;
+    PinCount = 0;   
+    AD1PCFG = 0xFF;
+}
+
+/*******************************************************************************
+ * PRIVATE FUNCTIONS                                                       *
+ ******************************************************************************/
+
+/**
+ * @function AD_SetPins(void)
+ * @param None
+ * @return SUCCESS OR ERROR
+ * @brief Connects pins in PinstoAdd to the A/D system and removes the pins in PinsToRemove
+ * @note Private Function. DO NOT USE.
+ * @author Max Dunne, 2013.08.15 */
+char AD_SetPins(void)
+{
+    if (!ADActive) {
+        return ERROR;
+    }
+    unsigned int cssl = 0;
+    unsigned int pcfg = 0;
+    unsigned int rempcfg = 0;
+    unsigned char CurPin = 0;
+    unsigned int CurPinOrder = 0x00;
+    int ADMapping[NUM_AD_PINS_UNO];
+    AD1CON1CLR = _AD1CON1_ON_MASK; //disable A/D system and interrupt
+    IEC1bits.AD1IE = 0;
+    PinCount = 0;
+
+    //determine the new set of active pins
+    ActivePins |= PinsToAdd;
+    ActivePins &= ~PinsToRemove;
+    //initialize the mapping array to -1
+    for (CurPin = 0; CurPin < NUM_AD_PINS_UNO; CurPin++) {
+        ADMapping[CurPin] = -1;
+    }
+    for (CurPin = 0; CurPin < NUM_AD_PINS; CurPin++) {
+        PortMapping[CurPin] = -1; //reset all ports to unmapped
+        if ((ActivePins & (1 << CurPin)) != 0) { //if one of the pins is active
+            //build masks and remap pins
+            cssl |= AD1CSSL_MASKS[CurPin];
+            pcfg |= AD1PCFG_MASKS[CurPin];
+            ADMapping[AD1PCFG_POS[CurPin]] = CurPin;
+            PinCount++;
+        }
+        if ((PinsToRemove & (1 << CurPin)) != 0) {//generate removal masks
+            rempcfg |= AD1PCFG_MASKS[CurPin];
+        }
+    }
+    for (CurPin = 0; CurPin < NUM_AD_PINS_UNO; CurPin++) {//translate AD Mapping to Port Mapping
+        if (ADMapping[CurPin] != -1) {
+            PortMapping[ADMapping[CurPin]] = CurPinOrder;
+            CurPinOrder++;
+        }
+    }
+    
+    // this realistically does not need to be done every time we add a pin but it makes sure it works
+    // future revisions many of these settings should be handled in the init
+    AD1CON1bits.FORM = 0; // output is unsigned integer
+    AD1CON1bits.SSRC = 0b111; // internal counter handles timing of sampling an conversion
+    AD1CON1bits.ASAM = 1; // start sampling again after conversion is complete
+
+    AD1CON2bits.VCFG = 0; // use AVdd and AVss for + and -
+    AD1CON2bits.CSCNA = 1; // mux inputs together
+    AD1CON2bits.SMPI = PinCount - 1; // set the number to scan for 1 less than wanted as zero is 1 to scan
+    AD1CON2bits.BUFM = 0; // configure bugger as one large buffer
+
+    AD1CON3bits.ADRC = 0; // use Peripheral clock for timing
+    AD1CON3bits.SAMC = 29; // set the sample time, completely arbitrary, nearly the slowest possible
+    AD1CON3bits.ADCS = 0x32; // set the conversion time, again arbitrary 
+
+    AD1PCFGCLR = pcfg;
+    TRISBSET = pcfg;
+    AD1CSSL = cssl;
+    AD1PCFGSET = rempcfg;
+    AD1CON1SET = _AD1CON1_ON_MASK;
+    PinsToAdd = 0;
+    PinsToRemove = 0;
+    IEC1bits.AD1IE = 1;
+    return SUCCESS;
+}
+
+/**
+ * @function ADCIntHandler
+ * @param None
+ * @return None
+ * @brief Interrupt Handler for A/D. Reads all used pins into buffer.
+ * @note This function is not to be called by the user
+ * @author Max Dunne, 2013.08.25 */
+void __ISR(_ADC_VECTOR, ipl1auto) ADCIntHandler(void)
+{
+    unsigned char CurPin = 0;
+    IFS1bits.AD1IF = 0;
+    for (CurPin = 0; CurPin <= PinCount; CurPin++) {
+        ADValues[CurPin] = (*(&ADC1BUF0+((CurPin) * 4))); //read in new set of values, pointer math from microchip
+    }
+    //calculate new filtered battery voltage
+
+    //if pins are changed add pins
+    if (PinsToAdd | PinsToRemove) {
+        AD_SetPins();
+    }
+    ADNewData = TRUE;
+}
+
+
+
+
+
+//#define AD_TEST
+#ifdef AD_TEST
+
+
+
+#include <xc.h>
+#include "serial.h"
+#include "AD.h"
+#include <stdio.h>
+
+#define DELAY(x)    {int wait; for (wait = 0; wait <= x; wait++) {asm("nop");}}
+#define A_BIT       18300
+#define A_LOT       183000
+//#define DISABLE_ADINIT
+#define TIMES_TO_READ 4000
+
+#define ODD_ACTIVE (AD_A1|AD_A3|AD_A5)
+#define EVEN_ACTIVE (AD_A0|AD_A2|AD_A4)
+
+#define ALLADMINUSBATT ALLADPINS 
+
+//#define ADPinHasChanged(PinsAdded)
+
+int main(void)
+{
+    unsigned int wait = 0;
+    int readcount = 0;
+    unsigned int CurPin = 0;
+    unsigned int PinListing = 0;
+    char FunctionResponse = 0;
+    char TestFailed = FALSE;
+    BOARD_Init();
+    AD_Init();
+    AD_AddPins(AD_A0);
+    while(1){
+        if(AD_IsNewDataReady())
+        {
+            printf("\r\nReading: %d", AD_ReadADPin(AD_A0));
+            DELAY(A_BIT);
+        }
+    }
+//    //END MAXL
+//    printf("\r\nUno A/D Test Harness\r\nThis will initialize all A/D pins and read them %d times\r\n", TIMES_TO_READ);
+//    //printf("Value of pcfg before test: %X\r\n", AD1PCFG);
+//    // while(!IsTransmitEmpty());
+//    //AD_Init(BAT_VOLTAGE);
+//    //AD_Init();
+//    printf("Testing functionality before initialization\r\n");
+//
+//    /*adding pins individually */
+//    printf("AD_AddPins on each pin indvidually which results in failure: ");
+//    for (CurPin = 1; CurPin < ALLADPINS; CurPin <<= 1) {
+//        FunctionResponse = AD_AddPins(CurPin);
+//        if (FunctionResponse != ERROR) {
+//            TestFailed = TRUE;
+//            break;
+//        }
+//    }
+//    if (TestFailed) {
+//        printf("FAIL\r\n");
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    TestFailed = FALSE;
+//    /*removing pins individually*/
+//    printf("AD_RemovePins on each pin indvidually which results in failure: ");
+//    for (CurPin = 1; CurPin < ALLADPINS; CurPin <<= 1) {
+//        FunctionResponse = AD_RemovePins(CurPin);
+//        if (FunctionResponse != ERROR) {
+//            TestFailed = TRUE;
+//            break;
+//        }
+//    }
+//    if (TestFailed) {
+//        printf("FAIL\r\n");
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    TestFailed = FALSE;
+//    /*listing pins while inactive*/
+//    printf("AD_ActivePins which should return 0: ");
+//    PinListing = AD_ActivePins();
+//    if (PinListing != 0x0) {
+//        printf("FAILED\r\n");
+//
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    //    /*calling ned when inactive*/
+//    //        printf("AD_End which should fail: ");
+//    //        FunctionResponse = AD_End();
+//    //        if (FunctionResponse != ERROR) {
+//    //            printf("FAILED\r\n");
+//    //        } else {
+//    //            printf("PASSED\r\n");
+//    //        }
+//    /*activating module*/
+//    printf("initializing using AD_Init: ");
+//    FunctionResponse = AD_Init();
+//    if (FunctionResponse != SUCCESS) {
+//        printf("FAILED\r\n");
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    /*attempting to reactivate*/
+//    printf("initializing using AD_Init again returns error: ");
+//    FunctionResponse = AD_Init();
+//    if (FunctionResponse != ERROR) {
+//        printf("FAILED\r\n");
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    /*each pin added should succeed*/
+//    printf("Adding each pin using AD_AddPins indivdually: ");
+//    for (CurPin = 1; CurPin < ALLADMINUSBATT; CurPin <<= 1) {
+//        PinListing = AD_ActivePins();
+//        FunctionResponse = AD_AddPins(CurPin);
+//        if (FunctionResponse != SUCCESS) {
+//            TestFailed = TRUE;
+//            break;
+//        }
+//        while (AD_ActivePins() != (PinListing | CurPin));
+//    }
+//    if (TestFailed) {
+//        printf("FAIL\r\n");
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    /*removing each pin should succeed */
+//    printf("Removing each pin using AD_RemovePins indivdually: ");
+//    for (CurPin = 1; CurPin < ALLADMINUSBATT; CurPin <<= 1) {
+//        PinListing = AD_ActivePins();
+//        FunctionResponse = AD_AddPins(CurPin);
+//        if (FunctionResponse != SUCCESS) {
+//            TestFailed = TRUE;
+//            break;
+//        }
+//        while (AD_ActivePins() != (PinListing | CurPin));
+//    }
+//    if (TestFailed) {
+//        printf("FAIL: %X\r\n", 0xFEED);
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    while (1);
+//    printf("We will now add the odd pins and wait for them to be activated");
+//    AD_AddPins(ODD_ACTIVE);
+//    while (!(AD_ActivePins() & ODD_ACTIVE)) {
+//        if (IsTransmitEmpty()) {
+//            printf("%X\r\n", AD_ActivePins());
+//        }
+//    }
+//    printf("The Odd pins are now active as shown by Active pins: %X\r\n", AD_ActivePins());
+//    printf("We will now enable the even pins and wait for them to be activated");
+//    AD_AddPins(EVEN_ACTIVE);
+//    while (!(AD_ActivePins() & EVEN_ACTIVE));
+//    printf("The Even pins are now active as shown by Active pins: %X\r\n", AD_ActivePins());
+//
+//
+//    char numtoread = NUM_AD_PINS;
+//    unsigned char cur = 0;
+//    DELAY(400000)
+//    while (readcount <= TIMES_TO_READ) {
+//        DELAY(100000);
+//        printf("\r\n");
+//        for (cur = 0; cur < numtoread; cur++) {
+//            printf("%d\t", AD_ReadADPin(1 << cur));
+//        }
+//        printf("\r\n");
+//        readcount++;
+//    }
+//    printf("Done Reading Them\r\n");
+//    AD_End();
+//    printf("Value of pcfg after test: %X", AD1PCFG);
+//
+//    return 0;
+}
+#endif
\ No newline at end of file
diff --git a/Common/AD.h b/Common/AD.h
new file mode 100644
index 0000000..26218dd
--- /dev/null
+++ b/Common/AD.h
@@ -0,0 +1,96 @@
+/*
+ * File:   AD.h
+ * Author: mdunne
+ *
+ * Software module to enable the Analog to Digital converter of the Uno32 boards.
+ * NOTE: Analog pins automatically take over digital I/O regardless of which TRIS
+ *       state it is in. There remains an error in the ADC code such that if all 12
+ *       pins are enabled, one of them does not respond.
+ *
+ * AD_TEST (in the .c file) conditionally compiles the test harness for the code. 
+ * Make sure it is commented out for module useage.
+ *
+ * Created on November 22, 2011, 8:57 AM
+ */
+
+#ifndef AD_H
+#define AD_H
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+
+
+#define AD_A0 (1<<0) // NOte that this is also the pot on board
+#define AD_A1 (1<<1)
+#define AD_A2 (1<<2)
+#define AD_A3 (1<<3)
+#define AD_A4 (1<<4)
+#define AD_A5 (1<<5)
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @function AD_Init(void)
+ * @param None
+ * @return SUCCESS or ERROR
+ * @brief Initializes the A/D subsystem and enable battery voltage monitoring
+ * @author Max Dunne, 2013.08.10 */
+char AD_Init(void);
+
+/**
+ * @function AD_AddPins(unsigned int AddPins)
+ * @param AddPins - Use #defined AD_XX OR'd together for each A/D Pin you wish to add
+ * @return SUCCESS OR ERROR
+ * @brief Remove pins from the A/D system.  If any pin is not active it returns an error
+ * @author Max Dunne, 2013.08.15 */
+char AD_AddPins(unsigned int AddPins);
+
+/**
+ * @function AD_RemovePins(unsigned int RemovePins)
+ * @param RemovePins - Use #defined AD_XX OR'd together for each A/D Pin you wish to remove
+ * @return SUCCESS OR ERROR
+ * @brief Remove pins from the A/D system. If any pin is not active it returns an error
+ * @author Max Dunne, 2013.08.15 */
+char AD_RemovePins(unsigned int RemovePins);
+
+/**
+ * @function AD_ActivePins(void)
+ * @param None
+ * @return Listing of all A/D pins that are active
+ * @brief Returns a variable of all active A/D pins. An individual pin can be determined if
+ *        active by "anding" with the AD_XX Macros.
+ * @note This will not reflect changes made with AD_AddPins or AD_RemovePins until the next A/D
+ *       interrupt cycle.
+ * @author Max Dunne, 2013.08.15 */
+unsigned int AD_ActivePins(void);
+
+/**
+ * @function AD_IsNewDataReady(void)
+ * @param None
+ * @return TRUE or FALSE
+ * @brief This function returns a flag indicating that the A/D has new values since the last
+ *        read of a value
+ * @author Max Dunne, 2013.08.15 */
+char AD_IsNewDataReady(void);
+
+/**
+ * @function AD_ReadADPin(unsigned int Pin)
+ * @param Pin - Used #defined AD_XX to select pin
+ * @return 10-bit AD Value or ERROR
+ * @brief Reads current value from buffer for given pin
+ * @author Max Dunne, 2011.12.10 */
+unsigned int AD_ReadADPin(unsigned int Pin);
+
+/**
+ * @function AD_End(void)
+ * @param None
+ * @return None
+ * @brief Disables the A/D subsystem and release the pins used
+ * @author Max Dunne, 2013.09.20 */
+void AD_End(void);
+
+#endif
diff --git a/Common/Ascii.c b/Common/Ascii.c
new file mode 100644
index 0000000..4452aa2
--- /dev/null
+++ b/Common/Ascii.c
@@ -0,0 +1,857 @@
+#include "Ascii.h"
+
+/*
+ * This file defines a bitmap font corresponding to the standard ASCII character set (0-7F).
+ */
+const unsigned char ascii[256][6] =
+{
+    // Non-printing characters 0x00 - 0x1F
+    {0,0,0,0,0,0},
+	{ // top of oven, on (0x01)
+        0b00000101,
+        0b11110011,
+        0b00000101,
+        0b11110011,
+        0b00000101,
+        0b11110011
+    },
+	{ // top of oven, off (0x02)
+        0b00000101,
+        0b00000011,
+        0b00000101,
+        0b00000011,
+        0b00000101,
+        0b00000011
+    },
+	{ // bottom of oven, on (0x03)
+        0b10100000,
+        0b11001111,
+        0b10100000,
+        0b11001111,
+        0b10100000,
+        0b11001111
+    },
+	{ // bottom of oven, off (0x04)
+        0b10100000,
+        0b11000000,
+        0b10100000,
+        0b11000000,
+        0b10100000,
+        0b11000000
+    },{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+
+    { // (space) 0x20
+        0b00000000,
+        0b00000000,
+        0b00000000,
+        0b00000000,
+        0b00000000,
+        0b00000000
+    },
+    { // ! 0x21
+        0b00000000,
+        0b00000000,
+        0b01011110,
+        0b00000000,
+        0b00000000,
+        0b00000000
+    },
+    { // " 0x22
+        0b00001100,
+        0b00000010,
+        0b00000000,
+        0b00001100,
+        0b00000010,
+        0b00000000
+    },
+    { // # 0x23
+        0b00010100,
+        0b01111111,
+        0b00010100,
+        0b01111111,
+        0b00010100,
+        0b00000000
+    },
+    { // $ 0x24
+        0b00100100,
+        0b00101010,
+        0b01111111,
+        0b00101010,
+        0b00010010,
+        0b00000000
+    },
+    { // % 0x25
+        0b00100011,
+        0b00010011,
+        0b00001000,
+        0b01100100,
+        0b01100010,
+        0b00000000
+    },
+    { // & 0x26
+        0b00110110,
+        0b01001001,
+        0b01010001,
+        0b00100010,
+        0b01010000,
+        0b00000000
+    },
+    { // ' 0x27
+        0b00000000,
+        0b00000000,
+        0b00001100,
+        0b00000010,
+        0b00000000,
+        0b00000000
+    },
+    { // ( 0x28
+        0b00000000,
+        0b00000000,
+        0b00111110,
+        0b01000001,
+        0b00000000,
+        0b00000000
+    },
+    { // ) 0x29
+        0b00000000,
+        0b01000001,
+        0b00111110,
+        0b00000000,
+        0b00000000,
+        0b00000000
+    },
+    { // * 0x2A
+        0b00001010,
+        0b00000100,
+        0b00011111,
+        0b00000100,
+        0b00001010,
+        0b00000000
+    },
+    { // + 0x2B
+        0b00001000,
+        0b00001000,
+        0b00111110,
+        0b00001000,
+        0b00001000,
+        0b00000000
+    },
+    { // , 0x2C
+        0b00000000,
+        0b00000000,
+        0b01010000,
+        0b00110000,
+        0b00000000,
+        0b00000000
+    },
+    { // - 0x2D
+        0b00001000,
+        0b00001000,
+        0b00001000,
+        0b00001000,
+        0b00001000,
+        0b00000000
+    },
+    { // . 0x2E
+        0b00000000,
+        0b01100000,
+        0b01100000,
+        0b00000000,
+        0b00000000,
+        0b00000000
+    },
+    { // / 0x2F
+        0b01000000,
+        0b00110000,
+        0b00001000,
+        0b00000110,
+        0b00000001,
+        0b00000000
+    },
+    { // 0 0x30
+        0b00111110,
+        0b01010001,
+        0b01001001,
+        0b01000101,
+        0b00111110,
+        0b00000000
+    },
+    { // 1 0x31
+        0b01000010,
+        0b01000010,
+        0b01111111,
+        0b01000000,
+        0b01000000,
+        0b00000000
+    },
+    { // 2 0x32
+        0b01000110,
+        0b01100001,
+        0b01010001,
+        0b01001001,
+        0b01000110,
+        0b00000000
+    },
+    { // 3 0x33
+        0b00100010,
+        0b01000001,
+        0b01001001,
+        0b01001001,
+        0b00110110,
+        0b00000000
+    },
+    { // 4 0x34
+        0b00011000,
+        0b00010100,
+        0b00010010,
+        0b01111111,
+        0b00010000,
+        0b00000000
+    },
+    { // 5 0x35
+        0b01001111,
+        0b01001001,
+        0b01001001,
+        0b01001001,
+        0b00110001,
+        0b00000000
+    },
+    { // 6 0x36
+        0b00111100,
+        0b01001010,
+        0b01001001,
+        0b01001001,
+        0b00110000,
+        0b00000000
+    },
+    { // 7 0x37
+        0b00000001,
+        0b01110001,
+        0b00001001,
+        0b00000101,
+        0b00000011,
+        0b00000000
+    },
+    { // 8 0x38
+        0b00110110,
+        0b01001001,
+        0b01001001,
+        0b01001001,
+        0b00110110,
+        0b00000000
+    },
+    { // 9 0x39
+        0b00000110,
+        0b01001001,
+        0b01001001,
+        0b00101001,
+        0b00011110,
+        0b00000000
+    },
+    { // : 0x3A
+        0b00000000,
+        0b00000000,
+        0b00110110,
+        0b00110110,
+        0b00000000,
+        0b00000000
+    },
+    { // ; 0x3B
+        0b00000000,
+        0b00000000,
+        0b01010110,
+        0b00110110,
+        0b00000000,
+        0b00000000
+    },
+    { // < 0x3C
+        0b00001000,
+        0b00010100,
+        0b00100010,
+        0b01000001,
+        0b00000000,
+        0b00000000
+    },
+    { // = 0x3D
+        0b00010100,
+        0b00010100,
+        0b00010100,
+        0b00010100,
+        0b00010100,
+        0b00000000
+    },
+    { // > 0x3E
+        0b00000000,
+        0b01000001,
+        0b00100010,
+        0b00010100,
+        0b00001000,
+        0b00000000
+    },
+    { // ? 0x3F
+        0b00000110,
+        0b00000001,
+        0b01010001,
+        0b00001001,
+        0b00000110,
+        0b00000000
+    },
+    { // @ 0x40
+        0b00111110,
+        0b01000001,
+        0b01011101,
+        0b01010101,
+        0b00111110,
+        0b00000000
+    },
+    { // A 0x41
+        0b01111110,
+        0b00001001,
+        0b00001001,
+        0b00001001,
+        0b01111110,
+        0b00000000
+    },
+    { // B 0x42
+        0b01111111,
+        0b01001001,
+        0b01001001,
+        0b01001001,
+        0b00110110,
+        0b00000000
+    },
+    { // C 0x43
+        0b00111110,
+        0b01000001,
+        0b01000001,
+        0b01000001,
+        0b01000001,
+        0b00000000
+    },
+    { // D 0x44
+        0b01111111,
+        0b01000001,
+        0b01000001,
+        0b01000001,
+        0b00111110,
+        0b00000000
+    },
+    { // E 0x45
+        0b01111111,
+        0b01001001,
+        0b01001001,
+        0b01001001,
+        0b01000001,
+        0b00000000
+    },
+    { // F 0x46
+        0b01111111,
+        0b00001001,
+        0b00001001,
+        0b00001001,
+        0b00000001,
+        0b00000000
+    },
+    { // G 0x47
+        0b00111110,
+        0b01000001,
+        0b01000001,
+        0b01001001,
+        0b00111001,
+        0b00000000
+    },
+    { // H 0x48
+        0b01111111,
+        0b00001000,
+        0b00001000,
+        0b00001000,
+        0b01111111,
+        0b00000000
+    },
+    { // I 0x49
+        0b01000001,
+        0b01000001,
+        0b01111111,
+        0b01000001,
+        0b01000001,
+        0b00000000
+    },
+    { // J 0x4A
+        0b00110001,
+        0b01000001,
+        0b01000001,
+        0b00111111,
+        0b00000001,
+        0b00000000
+    },
+    { // K 0x4B
+        0b01111111,
+        0b00001000,
+        0b00001000,
+        0b00010100,
+        0b01100011,
+        0b00000000
+    },
+    { // L 0x4C
+        0b01111111,
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b00000000
+    },
+    { // M 0x4D
+        0b01111111,
+        0b00000010,
+        0b00001100,
+        0b00000010,
+        0b01111111,
+        0b00000000
+    },
+    { // N 0x4E
+        0b01111111,
+        0b00000100,
+        0b00001000,
+        0b00010000,
+        0b01111111,
+        0b00000000
+    },
+    { // O 0x4F
+        0b00111110,
+        0b01000001,
+        0b01000001,
+        0b01000001,
+        0b00111110,
+        0b00000000
+    },
+    { // P 0x50
+        0b01111111,
+        0b00001001,
+        0b00001001,
+        0b00001001,
+        0b00000110,
+        0b00000000
+    },
+    { // Q 0x51
+        0b00111110,
+        0b01000001,
+        0b01010001,
+        0b00100001,
+        0b01011110,
+        0b00000000
+    },
+    { // R 0x52
+        0b01111111,
+        0b00001001,
+        0b00001001,
+        0b00001001,
+        0b01110110,
+        0b00000000
+    },
+    { // S 0x53
+        0b01000110,
+        0b01001001,
+        0b01001001,
+        0b01001001,
+        0b00110001,
+        0b00000000
+    },
+    { // T 0x54
+        0b00000001,
+        0b00000001,
+        0b01111111,
+        0b00000001,
+        0b00000001,
+        0b00000000
+    },
+    { // U 0x55
+        0b00111111,
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b00111111,
+        0b00000000
+    },
+    { // V 0x56
+        0b00011111,
+        0b00100000,
+        0b01000000,
+        0b00100000,
+        0b00011111,
+        0b00000000
+    },
+    { // W 0x57
+        0b00111111,
+        0b01000000,
+        0b00110000,
+        0b01000000,
+        0b00111111,
+        0b00000000
+    },
+    { // X 0x58
+        0b01100011,
+        0b00010100,
+        0b00001000,
+        0b00010100,
+        0b01100011,
+        0b00000000
+    },
+    { // Y 0x59
+        0b00000111,
+        0b00001000,
+        0b01110000,
+        0b00001000,
+        0b00000111,
+        0b00000000
+    },
+    { // Z 0x5A
+        0b01100001,
+        0b01010001,
+        0b01001001,
+        0b01000101,
+        0b01000011,
+        0b00000000
+    },
+    { // [ 0x5B
+        0b00000000,
+        0b01111111,
+        0b01000001,
+        0b01000001,
+        0b00000000,
+        0b00000000
+    },
+    { // \ 0x5C
+        0b00000001,
+        0b00000110,
+        0b00001000,
+        0b00110000,
+        0b01000000,
+        0b00000000
+    },
+    { // ] 0x5D
+        0b00000000,
+        0b01000001,
+        0b01000001,
+        0b01111111,
+        0b00000000,
+        0b00000000
+    },
+    { // ^ 0x5E
+        0b00000100,
+        0b00000010,
+        0b00000001,
+        0b00000010,
+        0b00000100,
+        0b00000000
+    },
+    { // _ 0x5F
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b00000000
+    },
+    { // ` 0x60
+        0b00000000,
+        0b00000001,
+        0b00000010,
+        0b00000100,
+        0b00000000,
+        0b00000000
+    },
+    { // a 0x61
+        0b00100000,
+        0b01010100,
+        0b01010100,
+        0b01010100,
+        0b01111000,
+        0b00000000
+    },
+    { // b 0x62
+        0b01111111,
+        0b01000100,
+        0b01000100,
+        0b01000100,
+        0b00111000,
+        0b00000000
+    },
+    { // c 0x63
+        0b00111000,
+        0b01000100,
+        0b01000100,
+        0b01000100,
+        0b01000100,
+        0b00000000
+    },
+    { // d 0x64
+        0b00111000,
+        0b01000100,
+        0b01000100,
+        0b01000100,
+        0b01111111,
+        0b00000000
+    },
+    { // e 0x65
+        0b00111000,
+        0b01010100,
+        0b01010100,
+        0b01010100,
+        0b01011000,
+        0b00000000
+    },
+    { // f 0x66
+        0b00001000,
+        0b01111110,
+        0b00001001,
+        0b00001001,
+        0b00000010,
+        0b00000000
+    },
+    { // g 0x67
+        0b00001000,
+        0b01010100,
+        0b01010100,
+        0b01010100,
+        0b00111000,
+        0b00000000
+    },
+    { // h 0x68
+        0b01111111,
+        0b00000100,
+        0b00000100,
+        0b00000100,
+        0b01111000,
+        0b00000000
+    },
+    { // i 0x69
+        0b00000000,
+        0b01001000,
+        0b01111010,
+        0b01000000,
+        0b00000000,
+        0b00000000
+    },
+    { // j 0x6A
+        0b00100000,
+        0b01000000,
+        0b01000000,
+        0b00111010,
+        0b00000000,
+        0b00000000,
+    },
+    { // k 0x6B
+        0b01111111,
+        0b00010000,
+        0b00010000,
+        0b00101000,
+        0b01000100,
+        0b00000000
+    },
+    { // l 0x6C
+        0b00000000,
+        0b00000001,
+        0b01111111,
+        0b01000000,
+        0b00000000,
+        0b00000000
+    },
+    { // m 0x6D
+        0b01111100,
+        0b00000100,
+        0b01111000,
+        0b00000100,
+        0b01111100,
+        0b00000000
+    },
+    { // n 0x6E
+        0b01111100,
+        0b00001000,
+        0b00000100,
+        0b00000100,
+        0b01111000,
+        0b00000000
+    },
+    { // o 0x6F
+        0b00111000,
+        0b01000100,
+        0b01000100,
+        0b01000100,
+        0b00111000,
+        0b00000000
+    },
+    { // p 0x70
+        0b11111100,
+        0b00100100,
+        0b00100100,
+        0b00100100,
+        0b00011000,
+        0b00000000
+    },
+    { // q 0x71
+        0b00011000,
+        0b00100100,
+        0b00100100,
+        0b00100100,
+        0b11111100,
+        0b00000000
+    },
+    { // r 0x72
+        0b01111100,
+        0b00001000,
+        0b00000100,
+        0b00000100,
+        0b00000100,
+        0b00000000
+    },
+    { // s 0x73
+        0b01001000,
+        0b01010100,
+        0b01010100,
+        0b01010100,
+        0b00100100,
+        0b00000000
+    },
+    { // t 0x74
+        0b00000100,
+        0b00111110,
+        0b01000100,
+        0b01000100,
+        0b00000000,
+        0b00000000
+    },
+    { // u 0x75
+        0b00111100,
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b00111100,
+        0b00000000
+    },
+    { // v 0x76
+        0b00011100,
+        0b00100000,
+        0b01000000,
+        0b00100000,
+        0b00011100,
+        0b00000000
+    },
+    { // w 0x77
+        0b00111100,
+        0b01000000,
+        0b00100000,
+        0b01000000,
+        0b00111100,
+        0b00000000
+    },
+    { // x 0x78
+        0b01000100,
+        0b00101000,
+        0b00010000,
+        0b00101000,
+        0b01000100,
+        0b00000000
+    },
+    { // y 0x79
+        0b00001100,
+        0b01010000,
+        0b01010000,
+        0b01010000,
+        0b00111100,
+        0b00000000
+    },
+    { // z 0x7A
+        0b01000100,
+        0b01100100,
+        0b01010100,
+        0b01001100,
+        0b01000100,
+        0b00000000
+    },
+    { // { 0x7B
+        0b00001000,
+        0b00001000,
+        0b00110110,
+        0b01000001,
+        0b00000000,
+        0b00000000
+    },
+    { // | 0x7C
+        0b00000000,
+        0b00000000,
+        0b01111111,
+        0b00000000,
+        0b00000000,
+        0b00000000
+    },
+    { // } 0x7D
+        0b00000000,
+        0b01000001,
+        0b00110110,
+        0b00001000,
+        0b00001000,
+        0b00000000
+    },
+    { // ~ 0x7E
+        0b00001000,
+        0b00000100,
+        0b00001000,
+        0b00001000,
+        0b00000100,
+        0b00000000
+    },
+    { // DEL 0x7F
+        0b00000000,
+        0b00010000,
+        0b00111000,
+        0b00010000,
+        0b00000000,
+        0b00000000
+    },
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 131
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 135
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 139
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 143
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 147
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 151
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 155
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 159
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 163
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 167
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 171
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 175
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 179
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 183
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 187
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 191
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 195
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 199
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 203
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 207
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 211
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 215
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 219
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 223
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 227
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 231
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 235
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 239
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 243
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 247
+	{ // degree 0xF8 (248)
+        0b00000000,
+        0b00000110,
+        0b00001001,
+        0b00001001,
+        0b00000110,
+        0b00000000
+    },
+	{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 251
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}  // 255
+};
\ No newline at end of file
diff --git a/Common/Ascii.h b/Common/Ascii.h
new file mode 100644
index 0000000..f2c9b20
--- /dev/null
+++ b/Common/Ascii.h
@@ -0,0 +1,26 @@
+#ifndef ASCII_H
+#define ASCII_H
+
+#include <stdint.h>
+
+// Specify the height and width of the characters defined in this library.
+#define ASCII_FONT_HEIGHT 8
+#define ASCII_FONT_WIDTH  6
+
+/**
+ * Pack a font for most of the standard ASCII characters into a byte array. Each character is stored
+ * as ASCII_FONT_WIDTH number of bytes which each byte corresponding to a vertical line of 8 pixels
+ * on the display.
+ *
+ * Some extended ASCII characters are supported:
+ *  0xF8: Degree symbol
+ *
+ * Some custom characters have also been implemented in lieu of some non-printing characters:
+ *  0x01: Top of oven, on
+ *  0x02: Top of oven, off
+ *  0x03: Bottom of oven, on
+ *  0x04: Bottom of oven, off
+ */
+extern const uint8_t ascii[256][ASCII_FONT_WIDTH];
+
+#endif // ASCII_H
\ No newline at end of file
diff --git a/Common/BOARD.c b/Common/BOARD.c
new file mode 100644
index 0000000..effaa15
--- /dev/null
+++ b/Common/BOARD.c
@@ -0,0 +1,174 @@
+/*
+ * File:   BOARD.c
+ * Author: Max
+ *
+ * Created on December 19, 2012, 2:08 PM
+ */
+
+
+#include <BOARD.h>
+#include <xc.h>
+#ifndef BOARD_TEST
+#include <serial.h>
+#endif
+
+
+
+/*******************************************************************************
+ * PRAGMAS                                                                     *
+ ******************************************************************************/
+// Configuration Bits
+// SYSCLK = 80MHz
+// PBCLK  = 40MHz
+// using POSC w/ PLL, XT mode
+#pragma config FPBDIV     = DIV_2
+#pragma config FPLLIDIV   = DIV_2     // Set the PLL input divider to 2, seems to
+#pragma config IESO       = OFF       // Internal/External Switch
+#pragma config POSCMOD    = XT        // Primary Oscillator Configuration for XT osc mode
+#pragma config OSCIOFNC   = OFF       // Disable clock signal output
+#pragma config FCKSM      = CSECMD    // Clock Switching and Monitor Selection
+#pragma config WDTPS      = PS1       // Specify the watchdog timer interval (unused)
+#pragma config FWDTEN     = OFF       // Disable the watchdog timer
+#pragma config ICESEL     = ICS_PGx2  // Allow for debugging with the Uno32
+#pragma config PWP        = OFF       // Keep the program flash writeable
+#pragma config BWP        = OFF       // Keep the boot flash writeable
+#pragma config CP         = OFF       // Disable code protect
+#pragma config FNOSC 		= PRIPLL	//Oscillator Selection Bits
+#pragma config FSOSCEN 		= OFF		//Secondary Oscillator Enable
+#pragma config FPLLMUL 		= MUL_20	//PLL Multiplier
+#pragma config FPLLODIV 	= DIV_1 	//System PLL Output Clock Divide
+
+
+
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+#define SYSTEM_CLOCK 80000000L
+#define  PB_CLOCK SYSTEM_CLOCK/2
+#define TurnOffAndClearInterrupt(Name) INTEnable(Name,INT_DISABLED); INTClearFlag(Name)
+
+/**
+ * @function BOARD_Init(void)
+ * @param None
+ * @return None
+ * @brief Set the clocks up for the board, initializes the serial port, and turns on the A/D
+ *        subsystem for battery monitoring
+ * @author Max Dunne, 2013.09.15  */
+void BOARD_Init()
+{
+    //sets the system clock to the optimal frequency given the system clock
+    //SYSTEMConfig(SYSTEM_CLOCK, SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
+    //sets the divisor to 2 to ensure 40Mhz peripheral bus
+    //OSCSetPBDIV(OSC_PB_DIV_2);
+
+
+    //disables all A/D pins for a clean start
+    AD1PCFG = 0xffff;
+
+    // get rid of JTAG before it kills us
+    DDPCONbits.JTAGEN = 0;
+
+
+    // this section of code comes from microchips deprecated plib
+    // dealing with the interrupt handler is tricky enough to the point of I have no desire to re-invent the wheel
+
+    unsigned int val;
+    // set the CP0 cause IV bit high
+    asm volatile("mfc0   %0,$13" : "=r"(val));
+    val |= 0x00800000;
+    asm volatile("mtc0   %0,$13" : "+r"(val));
+    INTCONSET = _INTCON_MVEC_MASK;
+    unsigned int status = 0;
+    asm volatile("ei    %0" : "=r"(status));
+
+
+#ifndef BOARD_TEST
+    //initializes the uart to give printf capabilities
+    SERIAL_Init();
+#endif
+    //printf("CMPE118 IO stack is now initialized\r\n");
+    char Time[] = __TIME__;
+    srand(Time[7] << Time[0]);
+
+}
+
+/**
+ * @function BOARD_End(void)
+ * @param None
+ * @return None
+ * @brief Shuts down all peripherals. Turns all pins into input
+ * @author Max Dunne, 2013.09.20  */
+void BOARD_End()
+{
+
+    // kill off all interrupts except serial and clear their flags
+    IEC0CLR = ~(_IEC0_U1TXIE_MASK | _IEC0_U1RXIE_MASK);
+    IFS0CLR = ~(_IFS0_U1TXIF_MASK | _IFS0_U1RXIF_MASK);
+
+    // kill off all interrupts except A/D and clear their flags
+    IEC1CLR = ~(_IEC1_AD1IE_MASK);
+    IFS0CLR = ~(_IFS1_AD1IF_MASK);
+
+    // set all ports to be digital inputs
+    TRISB = 0xff;
+    TRISC = 0xff;
+    TRISD = 0xff;
+    TRISE = 0xff;
+    TRISF = 0xff;
+    TRISG = 0xff;
+
+
+}
+
+/**
+ * @function BOARD_GetPBClock(void)
+ * @param None
+ * @return PB_CLOCK - Speed the peripheral clock is running in hertz
+ * @brief Returns the speed of the peripheral clock.  Nominally at 40Mhz
+ * @author Max Dunne, 2013.09.01  */
+unsigned int BOARD_GetPBClock()
+{
+    return PB_CLOCK;
+}
+
+
+#ifdef BOARD_TEST
+
+
+#define MAXPOWTWO 20
+
+int main(void)
+{
+    BOARD_Init();
+
+    //    int curPow2 = 12;
+    //    int i;
+    TRISDbits.TRISD4 = 0;
+    LATDbits.LATD4 = 0;
+    TRISE = 0; // turn on the leds on the top board
+    
+    unsigned int ledCount = 0;
+    
+    //will do a pulse of each power of two
+    //using scope can determine the length of timing for nops in test harnesses
+    //    for(curPow2=0;curPow2<=MAXPOWTWO;curPow2++)
+    //    {
+    //    while (1) {
+    //        LATDbits.LATD4 ^= 1;
+    //        for (i = 0; i < 1830000; i++) {
+    //            asm("nop");
+    //        }
+    //        //LATDbits.LATD4 = 0;
+    //    }
+    //will need a scope to test this module, the led should blink at the maximum rate
+    while (1) {
+        LATDbits.LATD4 ^= 1;
+        LATE = (ledCount>>16) & 0xFF;
+        ledCount++;
+    }
+}
+
+
+#endif
\ No newline at end of file
diff --git a/Common/BOARD.h b/Common/BOARD.h
new file mode 100644
index 0000000..79a48b8
--- /dev/null
+++ b/Common/BOARD.h
@@ -0,0 +1,96 @@
+/* 
+ * File:   BOARD.h
+ * Author: Max Dunne
+ *
+ * Created on December 19, 2012, 2:08 PM
+ */
+
+#ifndef BOARD_H
+#define	BOARD_H
+
+#include <stdint.h>
+#include <GenericTypeDefs.h>
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+
+//suppresses various warnings that we don't need to worry about for CMPE13
+#ifndef _SUPPRESS_PLIB_WARNING
+#define _SUPPRESS_PLIB_WARNING
+#endif
+
+#ifndef _DISABLE_OPENADC10_CONFIGPORT_WARNING
+#define _DISABLE_OPENADC10_CONFIGPORT_WARNING
+#endif
+
+/*****************************************************************************/
+// Boolean defines for TRUE, FALSE, SUCCESS and ERROR
+#ifndef FALSE
+//#define FALSE ((int8_t) 0)
+//#define TRUE ((int8_t) 1)
+#endif
+#define ERROR ((int8_t) -1)
+#define SUCCESS ((int8_t) 1)
+
+
+// Define macros for referring to the single-bit values of the switches.
+#define SW1 PORTDbits.RD8
+#define SW2 PORTDbits.RD9
+#define SW3 PORTDbits.RD10
+#define SW4 PORTDbits.RD11
+
+/**
+ * Provides a way to quickly get the status of all 4 switches as a nibble, where a bit is 1 if
+ * the button is being pressed and 0 if it's not. The buttons are ordered such that bit 3 is switch
+ * 4 and bit 0 is switch 1.
+ * @see enum ButtonStateFlags
+ */
+#define SWITCH_STATES() ((PORTD >> 8) & 0x0F)
+
+// Define macros for referring to the single-bit values of the buttons.
+#define BTN1 PORTFbits.RF1
+#define BTN2 PORTDbits.RD5
+#define BTN3 PORTDbits.RD6
+#define BTN4 PORTDbits.RD7
+
+/**
+ * Provides a way to quickly get the status of all 4 pushbuttons in to 4-bits, where a bit is 1 if
+ * the button is being pressed and 0 if it's not. The buttons are ordered such that bit 3 is button
+ * 4 and bit 0 is button 1.
+ * @see enum ButtonStateFlags
+ */
+#define BUTTON_STATES() (((PORTD >> 4) & 0x0E) | ((PORTF >> 1) & 0x01))
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @function BOARD_Init(void)
+ * @param None
+ * @return None
+ * @brief Set the clocks up for the board, initializes the serial port, and turns on the A/D
+ *        subsystem for battery monitoring
+ * @author Max Dunne, 2013.09.15  */
+void BOARD_Init();
+
+
+/**
+ * @function BOARD_End(void)
+ * @param None
+ * @return None
+ * @brief Shuts down all peripherals except for serial and A/D. Turns all pins into input
+ * @author Max Dunne, 2013.09.20  */
+void BOARD_End();
+
+/**
+ * @function BOARD_GetPBClock(void)
+ * @param None
+ * @return PB_CLOCK - Speed the peripheral clock is running in hertz
+ * @brief Returns the speed of the peripheral clock.  Nominally at 40Mhz
+ * @author Max Dunne, 2013.09.01  */
+unsigned int BOARD_GetPBClock();
+
+
+#endif	/* BOARD_H */
+
diff --git a/Common/CAPTOUCH.h b/Common/CAPTOUCH.h
new file mode 100644
index 0000000..92c1cfd
--- /dev/null
+++ b/Common/CAPTOUCH.h
@@ -0,0 +1,81 @@
+/**
+ * @file    CAPTOUCH.h
+ * @brief   Capacitive touch sensing module
+ * @author  CMPE167 Staff
+ * @date    1/15/2019
+ * @detail  This module uses the input capture peripheral to detect touch inputs.
+ *          If you are unfamiliar with input capture please read the lab appendix before beginning.
+ *          The peripheral is configured to generate an interrupt every rising edge which means
+ *          that the difference of two interrupts gives you the period of the signal.
+ *          NOTE: Given the limited number of timers on board this module is incompatible with PWM
+ * 
+ *          To alleviate setup headaches the code for setting up the peripheral and the interrupt is below.
+ *          The library is using IC4 or pin 35 for the input capture. The timer is configured with a 1:8 
+ *          prescaler to to have the timer period be reasonable and useful.
+ * 
+ *          char CAPTOUCH_Init(void)
+ *          {
+ // following block inits the timer
+ *             T2CON = 0;
+ *             T2CONbits.TCKPS = 0b011;
+ *             PR2 = 0xFFFF;
+ *             T2CONbits.ON = 1;
+    
+ *             //this block inits input capture
+ *             IC4CON = 0;
+ *             IC4CONbits.ICTMR = 1;
+ *             IC4CONbits.ICM = 0b010;
+    
+ *             IFS0bits.IC4IF = 0;
+ *             IPC4bits.IC4IP = 7;
+ *             IEC0bits.IC4IE = 1;
+ *             IC4CONbits.ON = 1;
+ *             // whatever else you need to do to initialize your module
+ *          }
+ * 
+ *          void __ISR(_INPUT_CAPTURE_4_VECTOR) InputCapture_Handler(void)
+ *          {
+ *              IFS0bits.IC4IF = 0;
+ *              // IC4BUF contains the timer value when the rising edge occurred.
+ *          }
+ *          
+ */
+
+#ifndef CAPTOUCH_H
+#define CAPTOUCH_H
+
+/*******************************************************************************
+ * INCLUDES                                                                    *
+ ******************************************************************************/
+#include "BOARD.h"
+#include <xc.h>
+#include <sys/attribs.h>
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @function    CAPTOUCH_Init(void)
+ * @brief       This function initializes the module for use. Initialization is 
+ *              done by opening and configuring timer 2, opening and configuring the input capture
+ *              peripheral, and setting up the interrupt.
+ * @return      SUCCESS or ERROR (as defined in BOARD.h)
+ */
+char CAPTOUCH_Init(void);
+
+/**
+ * @function    CAPTOUCH_IsTouched(void)
+ * @brief       Returns TRUE if finger is detected. Averaging of previous measurements 
+ *              may occur within this function, however you are NOT allowed to do any I/O
+ *              inside this function.
+ * @return      TRUE or FALSE
+ */
+char CAPTOUCH_IsTouched(void);
+
+#endif  /* CAPTOUCH_H */
\ No newline at end of file
diff --git a/Common/I2C.c b/Common/I2C.c
new file mode 100644
index 0000000..da13e35
--- /dev/null
+++ b/Common/I2C.c
@@ -0,0 +1,274 @@
+/* 
+ * File:   I2C.c
+ * Author: Max
+ *
+ * Created on February 22, 2018, 1:06 PM
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <BOARD.h>
+#include <serial.h>
+#include <I2C.h>
+#include <xc.h>
+
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+#define F_PB (BOARD_GetPBClock())
+
+//#define DEBUG_I2C_CHANNEL
+
+
+#ifdef DEBUG_I2C_CHANNEL
+#define dbprintf(...) printf(__VA_ARGS__)
+#else
+#define dbprintf(...)
+#endif
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                           *
+ ******************************************************************************/
+static char I2C_Inited = FALSE;
+static char lastCommandError = FALSE;
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @Function I2C_Init(Rate)
+ * @param Rate - Clock rate for the I2C system
+ * @return The clock rate set for the I2C system, 0 if already inited
+ * @brief  Initializes the I2C System for use with the IMU
+ * @author Max Dunne */
+unsigned int I2C_Init(unsigned int Rate) {
+    unsigned int RealRate = 0;
+    if (!I2C_Inited) {
+
+        I2C1CONbits.ON = 0;
+
+        I2C1BRG = (F_PB / (2 * Rate)) - 2;
+
+
+        I2C1CONbits.ON = 1;
+        I2C_Inited = TRUE;
+        RealRate = (F_PB) / ((I2C1BRG + 2)*2);
+        I2C1CONbits.PEN = 1;
+    while (I2C1CONbits.PEN == 1);
+    }
+    
+    return RealRate;
+}
+
+
+/**
+ * @Function I2C_ReadRegister(unsigned char I2CAddress,unsigned char deviceRegisterAddress)
+ * @param I2CAddresss - 7-bit address of I2C device wished to interact with
+ * @param deviceRegisterAddress - 8-bit address of register on device
+ * @return Value at Register or 0
+ * @brief  Reads one device register on chosen I2C device
+ * @author Max Dunne*/
+unsigned char I2C_ReadRegister(unsigned char I2CAddress, unsigned char deviceRegisterAddress) {
+    unsigned char regContents = 0;
+    lastCommandError = FALSE;
+    if (!I2C_Inited) {
+        return 0;
+    }
+
+    I2C1CONbits.SEN = 1; // send a start condition
+    while (I2C1CONbits.SEN == 1); //wait for it to end, this is internal and can not stall
+
+    I2C1TRN = I2CAddress << 1; // load transmission buffer with address and R/W and transmit
+
+    while (I2C1STATbits.TRSTAT != 0); //wait for it, again no error possible
+
+    if (I2C1STATbits.ACKSTAT == 1) {
+        dbprintf("\r\nDevice failed to ACK\r\n");
+        return 0;
+    }
+
+    I2C1TRN = deviceRegisterAddress;
+
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        dbprintf("\r\nDevice failed to ACK\r\n");
+        return 0;
+    }
+    I2C1CONbits.RSEN = 1;
+
+    while (I2C1CONbits.RSEN == 1);
+    I2C1TRN = (I2CAddress << 1) + 1;
+
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        dbprintf("\r\nDevice failed to ACK\r\n");
+        return 0;
+    }
+    I2C1CONbits.RCEN = 1;
+    while (I2C1STATbits.RBF != 1);
+    regContents = I2C1RCV;
+    I2C1CONbits.PEN = 1;
+    while (I2C1CONbits.PEN == 1);
+    return regContents;
+
+
+
+    return regContents;
+}
+
+
+/**
+ * @Function I2C_WriteReg(unsigned char I2CAddress, unsigned char deviceRegisterAddress, char data)
+ * @param I2CAddresss - 7-bit address of I2C device wished to interact with
+ * @param deviceRegisterAddress - 8-bit address of register on device
+ * @param data - data wished to be written to register
+ * @return 0 if error and 1 if success
+ * @brief  Writes one device register on chosen I2C device
+ * @author Max Dunne*/
+unsigned char I2C_WriteReg(unsigned char I2CAddress,unsigned char deviceRegisterAddress, char data) {
+
+    I2C1CONbits.SEN = 1;
+    while (I2C1CONbits.SEN == 1);
+    I2C1TRN = (I2CAddress << 1);
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        //printf("Device Responded with NACK upon addressing");
+        return 0;
+    }
+
+    I2C1TRN = deviceRegisterAddress;
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+
+        return 0;
+    }
+    I2C1TRN = data;
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        return 0;
+    }
+    I2C1CONbits.PEN = 1;
+    while (I2C1CONbits.PEN == 1);
+
+    return 1;
+}
+
+
+/**
+ * @Function I2C_ReadInt(char I2CAddress, char deviceRegisterAddress, char isBigEndian)
+ * @param I2CAddresss - 7-bit address of I2C device wished to interact with
+ * @param deviceRegisterAddress - 8-bit lower address of register on device
+ * @param isBigEndian - Boolean determining if device is big or little endian
+ * @return 0 if error and 1 if success
+ * @brief  Reads two sequential registers to build a 16-bit value. isBigEndian
+ * whether the first bits are either the high or low bits of the value
+ * @author Max Dunne*/
+int I2C_ReadInt(char I2CAddress, char deviceRegisterAddress, char isBigEndian) {
+    short Data = 0;
+    I2C1CONbits.SEN = 1;
+    while (I2C1CONbits.SEN == 1);
+    I2C1TRN = I2CAddress << 1;
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        //printf("Device Responded with NACK");
+        return 0;
+    }
+    I2C1TRN = deviceRegisterAddress;
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        //printf("Device Responded with NACK");
+        return 0;
+    }
+    I2C1CONbits.RSEN = 1;
+    while (I2C1CONbits.RSEN == 1);
+    I2C1TRN = (I2CAddress << 1) + 1;
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        //printf("Device Responded with NACK");
+        return 0;
+    }
+    I2C1CONbits.RCEN = 1;
+    //while(I2C1CONbits.RCEN==1);
+    while (I2C1STATbits.RBF != 1);
+    if (isBigEndian) {
+        Data = I2C1RCV << 8;
+    } else {
+        Data = I2C1RCV;
+    }
+    I2C1CONbits.ACKEN = 1;
+    while (I2C1CONbits.ACKEN == 1);
+    I2C1CONbits.RCEN = 1;
+
+    while (I2C1STATbits.RBF != 1);
+    if (isBigEndian) {
+        Data |= I2C1RCV;
+    } else {
+        Data |= I2C1RCV << 8;
+    }
+    I2C1CONbits.ACKDT = 1;
+    I2C1CONbits.ACKEN = 1;
+    while (I2C1CONbits.ACKEN == 1);
+    I2C1CONbits.ACKDT = 0;
+    I2C1CONbits.PEN = 1;
+    while (I2C1CONbits.PEN == 1);
+    return Data;
+
+
+}
+
+
+
+#ifdef I2C_TEST_HARNESS
+
+#define I2C_ADDRESS 0b1001000 
+
+static enum {
+    TEMPERATURE_REGISTER,
+    CONFIGURATION_REGISTER,
+    TEMPERATURE_HYST_REGISTER,
+    TEMPERATURE_LIMIT_REGISTER
+} TCN75A_REGISTERS;
+
+int main(void) {
+
+    BOARD_Init();
+
+
+    char conRegister = 0;
+    char newconRegister = 0;
+    unsigned int temperatureValue = 0;
+
+    printf("\r\nStarting I2C at %d and getting %d", I2C_DEFUALT_RATE, I2C_Init(I2C_DEFUALT_RATE));
+
+    printf("\r\nWe will now read in a config register, alter its value, write it back, and confirm the change");
+
+    conRegister = I2C_ReadRegister(I2C_ADDRESS, CONFIGURATION_REGISTER);
+    printf("\r\nConfiguration register is currently 0X%X", conRegister);
+    conRegister ^= 0b10;
+    printf("\r\nWe wish to change con register to   0X%X", conRegister);
+    printf("\r\nThis changes the alert pin which will have no side effects");
+    I2C_WriteReg(I2C_ADDRESS, CONFIGURATION_REGISTER, conRegister);
+
+    newconRegister = I2C_ReadRegister(I2C_ADDRESS, CONFIGURATION_REGISTER);
+
+    if (newconRegister == conRegister) {
+        printf("\r\nConfiguration successfully changed to 0X%X", newconRegister);
+    } else {
+        printf("\r\nFailed configuration change");
+        while (1);
+    }
+    printf("The code will now print 16-bit temperature data at max serial rate");
+
+    while (1) {
+        if (IsTransmitEmpty()) {
+            temperatureValue = I2C_ReadInt(I2C_ADDRESS, TEMPERATURE_REGISTER, TRUE);
+            printf("\r\nCurrent Temperature is %f", (float) (temperatureValue >> 4) / 16.0); //need to convert to celsius fp
+        }
+    }
+    while (1);
+    return 1;
+}
+
+#endif
\ No newline at end of file
diff --git a/Common/I2C.h b/Common/I2C.h
new file mode 100644
index 0000000..e198108
--- /dev/null
+++ b/Common/I2C.h
@@ -0,0 +1,57 @@
+/* 
+ * File:   I2C.h
+ * Author: Max
+ *
+ * Created on February 22, 2018, 1:17 PM
+ */
+
+#ifndef I2C_H
+#define	I2C_H
+
+
+#define I2C_DEFAULT_RATE 100000
+
+/**
+ * @Function I2C_Init(Rate)
+ * @param Rate - Clock rate for the I2C system
+ * @return The clock rate set for the I2C system, 0 if already inited
+ * @brief  Initializes the I2C System for use with the IMU
+ * @author Max Dunne */
+unsigned int I2C_Init(unsigned int Rate);
+
+
+
+/**
+ * @Function I2C_ReadRegister(unsigned char I2CAddress,unsigned char deviceRegisterAddress)
+ * @param I2CAddresss - 7-bit address of I2C device wished to interact with
+ * @param deviceRegisterAddress - 8-bit address of register on device
+ * @return Value at Register or 0
+ * @brief  Reads one device register on chosen I2C device
+ * @author Max Dunne*/
+unsigned char I2C_ReadRegister(unsigned char I2CAddress,unsigned char deviceRegisterAddress);
+
+
+/**
+ * @Function I2C_WriteReg(unsigned char I2CAddress, unsigned char deviceRegisterAddress, char data)
+ * @param I2CAddresss - 7-bit address of I2C device wished to interact with
+ * @param deviceRegisterAddress - 8-bit address of register on device
+ * @param data - data wished to be written to register
+ * @return 0 if error and 1 if success
+ * @brief  Writes one device register on chosen I2C device
+ * @author Max Dunne*/
+unsigned char I2C_WriteReg(unsigned char I2CAddress, unsigned char deviceRegisterAddress, char data);
+
+
+/**
+ * @Function I2C_ReadInt(char I2CAddress, char deviceRegisterAddress, char isBigEndian)
+ * @param I2CAddresss - 7-bit address of I2C device wished to interact with
+ * @param deviceRegisterAddress - 8-bit lower address of register on device
+ * @param isBigEndian - Boolean determining if device is big or little endian
+ * @return 0 if error and 1 if success
+ * @brief  Reads two sequential registers to build a 16-bit value. isBigEndian
+ * whether the first bits are either the high or low bits of the value
+ * @author Max Dunne*/
+int I2C_ReadInt(char I2CAddress, char deviceRegisterAddress, char isBigEndian);
+
+#endif	/* I2C_H */
+
diff --git a/Common/ICM20948.c b/Common/ICM20948.c
new file mode 100644
index 0000000..c5fbfb3
--- /dev/null
+++ b/Common/ICM20948.c
@@ -0,0 +1,320 @@
+#include <ICM20948.h>
+#include <I2C.h>
+#include <BOARD.h>
+#include <xc.h>
+#include <stdio.h>
+
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+#define ACCGYR_I2C_ADDRESS 0x69
+#define ACCGYR_WHO_AM_I_VAL 0xEA
+
+#define MAG_AK09916_I2C_ADDR 0x0C
+#define MAG_AK09916_WHO_AM_I_VAL 0x9
+
+#define MAG_MODE_WANTED 0b01000
+
+#define ICM_POWER_SETTING 0x02
+
+#define ICM_BYPASS_EN 0x02
+
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                           *
+ ******************************************************************************/
+
+static enum {
+    ICM_WHO_AM_I = 0, // Value of 0xEA stored in ACCGYR_WHO_AM_I_VAL
+    LP_CONFIG = 0x05,
+    PWR_MGMT_1, // power controls including sleep bit
+    PWR_MGMT_2,
+    INT_PIN_CONFIG = 0x0F, //I2C bypass annoyance
+    INT_ENABLE,
+    INT_ENABLE_1,
+    INT_ENABLE_2,
+    INT_ENABLE_3,
+    I2C_MST_STATUS = 0x17,
+    INT_STATUS = 0x19,
+    INT_STATUS_1,
+    INT_STATUS_2,
+    INT_STATUS_3,
+    DELAY_TIMEH = 0x28,
+    DELAY_TIMEL,
+    ACCEL_XOUT_H = 0x2D,
+    ACCEL_XOUT_L,
+    ACCEL_YOUT_H,
+    ACCEL_YOUT_L,
+    ACCEL_ZOUT_H,
+    ACCEL_ZOUT_L,
+    GYRO_XOUT_H,
+    GYRO_XOUT_L,
+    GYRO_YOUT_H,
+    GYRO_YOUT_L,
+    GYRO_ZOUT_H,
+    GYRO_ZOUT_L,
+    TEMP_OUT_H,
+    TEMP_OUT_L,
+    REG_BANK_SEL = 0x7F
+
+} ICM20948_REGISTERS;
+
+static enum {
+    MAG_WHO_AM_I = 0x1, // should read 0x9
+    MAG_ST1 = 0x10,
+    MAG_HXL = 0x11,
+    MAG_HXH,
+    MAG_HYL,
+    MAG_HYH,
+    MAG_HZL,
+    MAG_HZH,
+    MAG_ST2 = 0x18, // status register needs to be read every time so data actually changes
+    MAG_CNTL1 = 0x30, // despite being named as a control register it is a dummy
+    MAG_CNTL2, // allows setting of mode, section 9.3 of datasheet covers them
+    MAG_CNTL3, // software reset
+
+
+} AK09916_REGISTERS;
+
+/*******************************************************************************
+ * PRIVATE FUNCTION PROTOTYPES
+ ******************************************************************************/
+void DelayMicros(uint32_t microsec);
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @Function ICM20948_Init(Rate)
+
+ * @return 0 if error, 1 if succeeded
+ * @brief  Initializes the ICM20948 for usage. This will set all sensors to approximately 100HZ
+ * and Accel: 2g,Gyro:  250dps and Mag: 16-bit for the sensors
+ * @author Max Dunne */
+char ICM20948_Init(void)
+{
+    unsigned int intReturn;
+    unsigned char byteReturn;
+    DelayMicros(250000 << 2); // delaying to ensure that successive programs do not glitch the sensor
+
+    intReturn = I2C_Init(I2C_DEFAULT_RATE);
+    if (intReturn != I2C_DEFAULT_RATE) {
+        return FALSE;
+    }
+    
+    I2C1CONbits.PEN = 1; // after the delay we are also going to send a stop condition to supposedly clear the bus
+    while (I2C1CONbits.PEN == 1); 
+    
+    I2C_WriteReg(ACCGYR_I2C_ADDRESS, REG_BANK_SEL, 0); // need to be in bank 1 for the initial settings
+    byteReturn = I2C_ReadRegister(ACCGYR_I2C_ADDRESS, ICM_WHO_AM_I);
+    if (byteReturn != ACCGYR_WHO_AM_I_VAL) {
+        printf("IMU Did not respond to Who Am I.");
+        return FALSE;
+
+    }
+    // wake up the device from sleep along with setting the clock to a reasonable source
+    I2C_WriteReg(ACCGYR_I2C_ADDRESS, PWR_MGMT_1, ICM_POWER_SETTING);
+
+    // in default mode the device does not allow access to the mage directly, something we want so it needs to get changed
+    I2C_WriteReg(ACCGYR_I2C_ADDRESS, INT_PIN_CONFIG, ICM_BYPASS_EN);
+
+    byteReturn = I2C_ReadRegister(MAG_AK09916_I2C_ADDR, MAG_WHO_AM_I);
+    if (byteReturn != MAG_AK09916_WHO_AM_I_VAL) {
+        printf("Magnetometer Did not respond to Who Am I\r\n");
+        return FALSE;
+    }
+
+    // turn on the mag at 100Hz
+    byteReturn = I2C_WriteReg(MAG_AK09916_I2C_ADDR, MAG_CNTL2, MAG_MODE_WANTED);
+    if (!byteReturn) {
+        printf("Configuration of Mag Failed\r\n");
+        return FALSE;
+    }
+
+    // TODO: using the default settings for the gyro/accel which does mean a DLPF is enabled
+    // potentially it makes sense to disable it in future quarters
+
+
+    I2C_WriteReg(ACCGYR_I2C_ADDRESS, REG_BANK_SEL, 0); // when config complete want to be in bank 0
+    return TRUE;
+
+
+}
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadAccelX(void)
+{
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, ACCEL_XOUT_H, TRUE);
+}
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadAccelY(void)
+{
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, ACCEL_YOUT_H, TRUE);
+}
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadAccelZ(void)
+{
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, ACCEL_ZOUT_H, TRUE);
+}
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadGyroX(void)
+{
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, GYRO_XOUT_H, TRUE);
+}
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadGyroY(void)
+{
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, GYRO_YOUT_H, TRUE);
+}
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadGyroZ(void)
+{
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, GYRO_ZOUT_H, TRUE);
+}
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadMagX(void)
+{
+    int sensorValue = I2C_ReadInt(MAG_AK09916_I2C_ADDR, MAG_HXL, FALSE);
+    I2C_ReadRegister(MAG_AK09916_I2C_ADDR, MAG_ST2); // read the status register to clear it
+    return sensorValue;
+}
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadMagY(void)
+{
+    int sensorValue = I2C_ReadInt(MAG_AK09916_I2C_ADDR, MAG_HYL, FALSE);
+    I2C_ReadRegister(MAG_AK09916_I2C_ADDR, MAG_ST2); // read the status register to clear it
+    return sensorValue;
+}
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadMagZ(void)
+{
+    int sensorValue = I2C_ReadInt(MAG_AK09916_I2C_ADDR, MAG_HZL, FALSE);
+    I2C_ReadRegister(MAG_AK09916_I2C_ADDR, MAG_ST2); // read the status register to clear it
+    return sensorValue;
+}
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadTemp(void)
+{
+
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, TEMP_OUT_H, TRUE);
+}
+
+/*******************************************************************************
+ * PRIVATE FUNCTIONS                                                           *
+ ******************************************************************************/
+
+void DelayMicros(uint32_t microsec)
+{
+    uint32_t tWait, tStart, tCurrent;
+
+    // Calculate the amount of wait time in terms of core processor frequency.
+    tWait = (80000000L / 2000000) * microsec;
+    asm volatile("mfc0   %0, $9" : "=r"(tStart));
+    tCurrent = tStart;
+    while ((tCurrent - tStart) < tWait) {
+        asm volatile("mfc0   %0, $9" : "=r"(tCurrent));
+    }// wait for the time to pass
+}
+
+
+#ifdef ICM20948_TEST
+
+#include "serial.h"
+#include <xc.h>
+
+#define POWERPIN_LAT LATFbits.LATF1
+#define POWERPIN_TRIS TRISFbits.TRISF1
+
+int main(void)
+{
+    char initResult;
+    BOARD_Init();
+
+    printf("Welcome to the ICM20948 test compiled at " __DATE__ " " __TIME__ ". Sensor will be brought up and then values displayed\r\n");
+    while (!IsTransmitEmpty());
+    POWERPIN_LAT = 0;
+    POWERPIN_TRIS = 0;
+    POWERPIN_LAT = 1;
+
+    DelayMicros(100000);
+    initResult = ICM20948_Init();
+    if (initResult != TRUE) {
+        printf("Initialization of IMU failed, stopping here\r\n");
+    } else {
+        printf("Initialization succeeded\r\n");
+        while (1) {
+            if (IsTransmitEmpty()) {
+                printf("Gyro: (%+06d, %+06d, %+06d)   ", ICM20948_ReadGyroX(), ICM20948_ReadGyroY(), ICM20948_ReadGyroZ());
+                printf("Accel: (%+06d, %+06d, %+06d)   ", ICM20948_ReadAccelX(), ICM20948_ReadAccelY(), ICM20948_ReadAccelZ());
+                printf("Mag: (%+06d, %+06d, %+06d)   ", ICM20948_ReadMagX(), ICM20948_ReadMagY(), ICM20948_ReadMagZ());
+                printf("Temp: %+06d", ICM20948_ReadTemp());
+                printf("\r\n");
+                DelayMicros(100000);
+            }
+        }
+    }
+    while (1);
+}
+
+#endif
\ No newline at end of file
diff --git a/Common/ICM20948.h b/Common/ICM20948.h
new file mode 100644
index 0000000..2200920
--- /dev/null
+++ b/Common/ICM20948.h
@@ -0,0 +1,154 @@
+/*
+ * File:   ICM20948.h
+ * Author: mdunne
+ *
+ * Software module to communicate with the IMU over I2C.
+ * Provides access to each raw sensor axis along with raw temperature
+ * 
+ */
+
+#ifndef ICM20948_H
+#define ICM20948_H
+
+
+/**
+ * @Function ICM20948_Init(Rate)
+
+ * @return 0 if error, 1 if succeeded
+ * @brief  Initializes the ICM 20948 for usage. Sensors will be at Accel: 2g,Gyro:  250dps and Mag: 16-bit
+ * @author Max Dunne */
+char ICM20948_Init(void);
+
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadAccelX(void);
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadAccelY(void);
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadAccelZ(void);
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadGyroX(void);
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadGyroY(void);
+
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadGyroZ(void);
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadAccelX(void);
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadAccelY(void);
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadAccelZ(void);
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadGyroX(void);
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadGyroY(void);
+
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadGyroZ(void);
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadMagX(void);
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadMagY(void);
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadMagZ(void);
+
+
+/**
+ * @Function ICM20948_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int ICM20948_ReadTemp(void);
+
+#endif
\ No newline at end of file
diff --git a/Common/Oled.c b/Common/Oled.c
new file mode 100644
index 0000000..fe4771c
--- /dev/null
+++ b/Common/Oled.c
@@ -0,0 +1,235 @@
+#include <stddef.h>
+
+
+#include "OledDriver.h"
+#include "Oled.h"
+#include "Ascii.h"
+
+// in simulator we do nothing with the hardware, printing instead
+
+void OledInit(void)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    // First initialize the PIC32 to be able to talk over SPI to the OLED.
+    OledHostInit();
+
+    // Now send initialization commands to the OLED.
+    OledDriverInitDisplay();
+
+    // Clear the frame buffer by filling it with black pixels.
+    OledClear(OLED_COLOR_BLACK);
+
+    // Finally update the screen, triggering a write of all black pixels to the screen.
+    OledUpdate();
+#endif
+}
+
+void OledSetPixel(int x, int y, OledColor color)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    // Check for valid inputs before doing anything.
+    if (x >= OLED_DRIVER_PIXEL_COLUMNS || y >= OLED_DRIVER_PIXEL_ROWS || x < 0 || y < 0) {
+        return;
+    }
+
+    // Map the x/y coordinates into a byte/bit index.
+    unsigned int index = ((y & 0xFFF8) << 4) + x;
+    unsigned int shift = y & 0x0007;
+
+    // Now set the pixel to the proper color, doing nothing if an invalid color was specified.
+    if (color == OLED_COLOR_WHITE) {
+        rgbOledBmp[index] = rgbOledBmp[index] | (1 << shift);
+    } else if (color == OLED_COLOR_BLACK) {
+        rgbOledBmp[index] = rgbOledBmp[index] & ~(1 << shift);
+    } else {
+        return;
+    }
+#endif
+}
+
+int OledGetPixel(int x, int y)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    // Check for valid inputs before doing anything.
+    if (x >= OLED_DRIVER_PIXEL_COLUMNS || y >= OLED_DRIVER_PIXEL_ROWS || x < 0 || y < 0) {
+        return OLED_COLOR_BLACK;
+    }
+
+    // Map the x/y coordinates into a byte/bit index.
+    unsigned int index = ((y & 0xFFF8) << 4) + x;
+    unsigned int shift = y & 0x0007;
+
+    // Now return the desired bit.
+    return (rgbOledBmp[index] >> shift) & 0x01;
+#else
+    return OLED_COLOR_BLACK;
+#endif
+}
+
+//in simulator this is the same as putchar
+
+uint8_t OledDrawChar(int x, int y, char c)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    if (x <= OLED_DRIVER_PIXEL_COLUMNS - ASCII_FONT_WIDTH && y <= OLED_DRIVER_PIXEL_ROWS - ASCII_FONT_HEIGHT) {
+        // We need to convert our signed char into an unsigned value to index into the ascii[] array.
+        int charIndex = (int) (unsigned char) c;
+
+        // Now first determine the columns and rows of the OLED bits that need to be modified
+        int rowMin, rowMax, colMin, colMax;
+        rowMin = y / ASCII_FONT_HEIGHT;
+        int rowY = y % ASCII_FONT_HEIGHT;
+        rowMax = (y + ASCII_FONT_HEIGHT) / OLED_DRIVER_BUFFER_LINE_HEIGHT;
+        colMin = x;
+        colMax = x + ASCII_FONT_WIDTH;
+        {
+            // Generate a positive mask for where in the column the new symbol will be drawn.
+            int colMask = ((1 << ASCII_FONT_HEIGHT) - 1) << rowY;
+            int j;
+            for (j = 0; j < colMax - colMin; ++j) {
+                int oledCol = colMin + j;
+                uint8_t newCharCol = rgbOledBmp[rowMin * OLED_DRIVER_PIXEL_COLUMNS + oledCol] & ~colMask;
+                // Make sure we always grab from the top part of the character.
+                newCharCol |= (ascii[charIndex][j] & (colMask >> rowY)) << rowY;
+                rgbOledBmp[rowMin * OLED_DRIVER_PIXEL_COLUMNS + oledCol] = newCharCol;
+            }
+        }
+        if (rowMax > rowMin) {
+            // Generate a positive mask for where in the column the new symbol will be drawn.
+            // Since we need the lower portion of the symbol, we recalculate its height.
+            int colMask = ((1 << ASCII_FONT_HEIGHT) - 1) >> (OLED_DRIVER_BUFFER_LINE_HEIGHT - rowY);
+            int j;
+            for (j = 0; j < colMax - colMin; ++j) {
+                int oledCol = colMin + j;
+                uint8_t newCharCol = rgbOledBmp[rowMax * OLED_DRIVER_PIXEL_COLUMNS + oledCol] & ~colMask;
+                // Make sure we grab the proper part of the character from the font.
+                newCharCol |= (ascii[charIndex][j] & (colMask << (OLED_DRIVER_BUFFER_LINE_HEIGHT - rowY))) >>
+                        (OLED_DRIVER_BUFFER_LINE_HEIGHT - rowY);
+                rgbOledBmp[rowMax * OLED_DRIVER_PIXEL_COLUMNS + oledCol] = newCharCol;
+            }
+        }
+    }
+#else
+    putchar(c);
+#endif
+
+    return FALSE;
+}
+
+void OledDrawString(const char *string)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    if (string == NULL) {
+        return;
+    }
+
+    // Track the current line number we're in on the OLED. Valid values are [0, OLED_NUM_LINES).
+    int line = 0;
+
+    // Track the current character we're writing to the OLED. Valid values are
+    // [0, OLED_CHARS_PER_LINE).
+    int column = 0;
+
+    // Run through all characters. The maximum length can be the number of lines times the number
+    // of characters per line + three newlines.
+    int i;
+    for (i = 0; string[i] != '\0' && i < (OLED_NUM_LINES * OLED_CHARS_PER_LINE + 3); ++i) {
+        // Move the cursor to the next line if a newline character is encountered. This allows for
+        // early line ending.
+        if (string[i] == '\n') {
+            ++line;
+            column = 0;
+            continue;
+        } else {
+            // Reset to the start of the next line if we've hit the character limit of this line
+            // without seeing a newline.
+            if (column == OLED_CHARS_PER_LINE) {
+                ++line;
+                column = 0;
+            }
+
+            // Now if we're < OLED_NUM_LINES and < OLED_CHARS_PER_LINE we can proceed. The second
+            // check is implicitly handled by the above if-statement that forces a newline after
+            // encountering a full line of characters.
+            if (line == OLED_NUM_LINES) {
+                break;
+            }
+
+            // Finally at this point, we can write characters to the OLED.
+            OledDrawChar(column * ASCII_FONT_WIDTH, line * ASCII_FONT_HEIGHT, string[i]);
+            ++column;
+        }
+    }
+#else
+    printf("%s",string);
+#endif
+}
+
+void OledClear(OledColor p)
+{
+    int i;
+    for (i = 0; i < OLED_DRIVER_BUFFER_SIZE; i++) {
+        if (p == OLED_COLOR_WHITE) {
+            rgbOledBmp[i] = 0xFF;
+        } else {
+            rgbOledBmp[i] = 0;
+        }
+    }
+}
+
+void OledSetDisplayInverted(void)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    OledDriverSetDisplayInverted();
+#endif
+}
+
+void OledSetDisplayNormal(void)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    OledDriverSetDisplayNormal();
+#endif
+}
+
+void OledOn(void)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    OledDriverInitDisplay();
+#endif
+}
+
+void OledOff(void)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    OledDriverDisableDisplay();
+#endif
+}
+
+void OledUpdate(void)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    OledDriverUpdateDisplay();
+#endif
+}
+
+
+
+
+#ifdef OLED_TEST
+#include <stdio.h>
+
+int main(void)
+{
+    BOARD_Init();
+    OledInit();
+    char SecondLine[40];
+    OledDrawString(__DATE__ "\n "__TIME__);
+    sprintf(SecondLine,"\n\nRandom: %d",rand());
+    OledDrawString(SecondLine);
+    OledUpdate();
+    printf("\r\nTesting at " __TIME__);
+    while(1);
+    return 0;
+    
+}
+#endif
\ No newline at end of file
diff --git a/Common/Oled.h b/Common/Oled.h
new file mode 100644
index 0000000..dfd5e26
--- /dev/null
+++ b/Common/Oled.h
@@ -0,0 +1,148 @@
+#ifndef OLED_H
+#define OLED_H
+
+/**
+ * This file provides a complete interface for interacting with the OLED on Digilent's I/O Shield.
+ * It works by storing a backend array of pixel data for storing modifications and then flushing
+ * that to the screen to update it when OledUpdate() is called. Since OledUpdate() is very slow,
+ * this allows for batching together a lot of drawing operations before finally updating the screen
+ * at the end in one go.
+ *
+ * This OLED is a monochrome display, offering black and white as your color options. These can be
+ * specified as arguments to OledDrawChar() and OledClear(). Note that this coloring can be inverted
+ * on the display itself by calling OledSetDisplayInverted(). This doesn't actually modify the data
+ * stored in the pixels, but merely switches what colors each bit value represents.
+ *
+ * The OLED offers both a pixel interface and a text interface for drawing. Individual pixels can be
+ * read and changed with the Oled*Pixel() functions.
+ *
+ * Higher-level text operations can be done through OledDrawChar() and OledDrawString, with the
+ * latter function being the easier one to use. It allows for writing text across all OLED_NUM_LINES
+ * lines on the display where each line can hold up to OLED_CHARS_PER_LINE complete characters.
+ *
+ * The font (defined in Ascii.h) used for drawing characters is a custom monospaced font. It
+ * provides glyphs for most of the basic ASCII character set, but is incomplete. Additionally some
+ * non-printing characters have been repurposed for custom characters for specific uses
+ * (@see Ascii.h).
+ */
+
+
+#include "Ascii.h"
+#include "OledDriver.h"
+#include "BOARD.h"
+
+/**
+ * Define constants for available colors for the OLED: either white or black.
+ */
+typedef enum {
+    OLED_COLOR_BLACK = 0,
+    OLED_COLOR_WHITE = 1
+} OledColor;
+
+// Define how many lines of text the display can show.
+#define OLED_NUM_LINES         (OLED_DRIVER_PIXEL_ROWS / ASCII_FONT_HEIGHT)
+
+// Define how many complete characters can be displayed on a row of text.
+#define OLED_CHARS_PER_LINE  (OLED_DRIVER_PIXEL_COLUMNS / ASCII_FONT_WIDTH)
+
+/**
+ * Initializes the OLED, turns it on, and clears the screen.
+ */
+void OledInit(void);
+
+/**
+ * Sets a specific pixel in the frame buffer, available colors are black or white.
+ * @note OledUpdate() must be called before the OLED will actually display these changes.
+ * @param x The X position (left is zero)
+ * @param y The Y position (top is zero)
+ * @param color OLED_COLOR_WHITE or OLED_COLOR_BLACK
+ */
+void OledSetPixel(int x, int y, OledColor color);
+
+/**
+ * Reads a pixel from the frame buffer.
+ * @param x The X position (left is zero)
+ * @param y The Y position (top is zero)
+ * @return OLED_COLOR_WHITE or OLED_COLOR_BLACK
+ */
+int OledGetPixel(int x, int y);
+
+/**
+ * Draws the specified character at the specified position, using Ascii.h as the font.
+ * @note OledUpdate() must be called before the OLED will actually display these changes.
+ * @param x The x-position to use as the left-most value for the character.
+ * @param y The y-position to use as the top-most value for the character
+ * @param c The character to write. Uses the character array defined in Ascii.h
+ * @return True if the write succeeded. Fails on invalid inputs.
+ */
+uint8_t OledDrawChar(int x, int y, char c);
+
+/**
+ * Draws a string to the screen buffer, starting on the top line. OLED_CHARS_PER_LINE characters fit
+ * on each of the OLED_NUM_LINES lines on the screen. A newline in the string will start the
+ * subsequent characters on the next line, otherwise once a line has run out of room no more
+ * characters will display on the screen. There is no other special processing of the input string
+ * besides this newline functionality, for example backspace characters just render as blank
+ * characters.
+ *
+ * For example, the following code example shows Hello World I'm Working! on the OLED with each word
+ * on its own line:
+ *   OledInit();
+ *   OledDrawString("Hello\nWorldI'm\nWorking!\n");
+ *   OledUpdate();
+ *
+ * @note OledUpdate() must be called before the OLED will actually display these changes.
+ * @param string A null-terminated string to print.
+ */
+void OledDrawString(const char *string);
+
+/**
+ * Writes the specified color pixels to the entire frame buffer.
+ * @note OledUpdate() must be called before the OLED will actually display these changes.
+ * @param p The color to write all pixels in the OLED to.
+ */
+void OledClear(OledColor p);
+
+/**
+ * Sets the display to display pixels the opposite color than what was intended. This does not
+ * change the stored value for any pixel.
+ * @see OledSetDisplayNormal
+ */
+void OledSetDisplayInverted(void);
+
+/**
+ * Displays all pixels as they are stored, where a 0 indicates black and a 1 indicates white. This
+ * is the default setting for the OLED on startup. This undoes `OledSetDisplayInverted()`.
+ * @see OledSetDisplayInverted
+ */
+void OledSetDisplayNormal(void);
+
+/**
+ * Turns on the OLED display.
+ * @note This is not required as part of initialization, as `OledInit()` already does this.
+ */
+void OledOn(void);
+
+/**
+ * Turns off the OLED display.
+ * @note This is not required as part of initialization, as `OledInit()` already does this.
+ */
+void OledOff(void);
+
+/**
+ * Refreshes the OLED display to reflect any changes. Should be called after any operation that
+ * changes the display: OledSetPixel(), OledDrawChar(), OledDrawString(), and OledClear().
+ *
+ * This function is very slow and so shouldn't be called too often or the OLED might look dim or
+ * even show no data at all. This is because it uses a blocking SPI interface to push out the entire
+ * screen of pixel data every time it's called. Like I said, very slow function!
+ *
+ * For example, the following code example shows Hello World I'm Workin! on the OLED with each word
+ * on its own line:
+ *   OledInit();
+ *   OledDrawString("Hello\nWorldI'm\nWorking!\n");
+ *   OledUpdate();
+ */
+void OledUpdate(void);
+
+#endif
\ No newline at end of file
diff --git a/Common/OledDriver.c b/Common/OledDriver.c
new file mode 100644
index 0000000..4f4333b
--- /dev/null
+++ b/Common/OledDriver.c
@@ -0,0 +1,266 @@
+#include <stdint.h>
+
+//CMPE13 Support Library
+#include "BOARD.h"
+
+#include <xc.h>
+
+
+#include "OledDriver.h"
+
+#define SPI_CHANNEL SPI_CHANNEL2
+
+/**
+ * Constants for the various command values that can be sent to the OLED driver.
+ */
+typedef enum {
+    OLED_COMMAND_SET_DISPLAY_LOWER_COLUMN_0 = 0x00,
+    OLED_COMMAND_SET_DISPLAY_UPPER_COLUMN_0 = 0x10,
+    OLED_COMMAND_SET_PAGE = 0x22,
+    OLED_COMMAND_SET_CHARGE_PUMP = 0x8D,
+    OLED_COMMAND_SET_SEGMENT_REMAP = 0xA1,
+    OLED_COMMAND_DISPLAY_NORMAL = 0xA6,
+    OLED_COMMAND_DISPLAY_INVERTED = 0xA7,
+    OLED_COMMAND_DISPLAY_OFF = 0xAE,
+    OLED_COMMAND_DISPLAY_ON = 0xAF,
+    OLED_COMMAND_SET_PRECHARGE_PERIOD = 0xD9,
+    OLED_COMMAND_SET_COM_PINS_CONFIG = 0xDA
+} OledCommand;
+
+/**
+ * Store constants for all settings used with the OLED driver.
+ */
+typedef enum {
+    OLED_SETTING_ENABLE_CHARGE_PUMP = 0x14,
+    OLED_SETTING_MAXIMUM_PRECHARGE = 0xF1,
+    OLED_SETTING_SEQUENTIAL_COM_NON_INTERLEAVED = 0x20,
+    OLED_SETTING_REVERSE_ROW_ORDERING = 0xC8
+} OledSetting;
+
+#define OLED_DRIVER_PAGES 4
+
+/**
+ * This array is the off-screen frame buffer used for rendering.
+ * It isn't possible to read back from the OLED display device,
+ * so display data is rendered into this off-screen buffer and then
+ * copied to the display.
+ * @note Any time this is updated, An `OledDriverUpdateDisplay()` call must be performed.
+ */
+uint8_t rgbOledBmp[OLED_DRIVER_BUFFER_SIZE];
+
+// Function prototypes for internal-use functions.
+void OledPutBuffer(int size, uint8_t *buffer);
+uint8_t Spi2Put(uint8_t bVal);
+void DelayMs(unsigned int msec);
+
+/**
+ * Initialize the PIC32MX to communicate with the UG-23832HSWEG04 OLED display through the SSD1306
+ * display controller.
+ */
+void OledHostInit(void)
+{
+    // Open SPI2 as a master in 1-byte mode running at 10MHz.
+    // The peripheral bus is running at 10Mhz, and we want a 10MHz SPI bus clock.
+    int pbClkDiv = 20000000 / 10000000;
+    SPI2CON = 0; // reset and clear the SPI config register
+    SPI2CONbits.MSTEN = 1; // We are a Master
+    SPI2CONbits.CKP = 1; // Idle is high level
+    SPI2BRG = (pbClkDiv >> 1) - 1; // set the baud rate to the correct setting.
+    SPI2CONbits.ON = 1; // turn it on
+
+
+    // Set RF4-6 as digital outputs for controlling data/command selection, logic power, and display
+    // power. They're all initialized high beforehand, because that disables power.
+    OLED_DRIVER_CONTROLLER_POWER_PORT = 1;
+    OLED_DRIVER_OLED_POWER_PORT = 1;
+    OLED_DRIVER_MODE_PORT = 1;
+
+    OLED_DRIVER_MODE_TRIS = 0;
+    OLED_DRIVER_CONTROLLER_POWER_TRIS = 0;
+    OLED_DRIVER_OLED_POWER_TRIS = 0;
+
+    // Set RG9 as a digital output, tied to the reset pin on the SG1306 controller, low => reset.
+    OLED_DRIVER_RESET_PORT = 1;
+    OLED_DRIVER_RESET_TRIS = 0;
+}
+
+/**
+ * Initialize the OLED display and driver circuitry.
+ */
+void OledDriverInitDisplay(void)
+{
+    // Set the OLED into command mode.
+    OLED_DRIVER_MODE_PORT = 0;
+
+    // Power on the display logic, waiting 1ms for it to start up.
+    OLED_DRIVER_CONTROLLER_POWER_PORT = 0;
+    DelayMs(1);
+
+    // Turn off the display.
+    Spi2Put(OLED_COMMAND_DISPLAY_OFF);
+
+    // Toggle the reset pin.
+    OLED_DRIVER_RESET_PORT = 0;
+    DelayMs(1);
+    OLED_DRIVER_RESET_PORT = 1;
+
+    // Enable the charge pump and
+    Spi2Put(OLED_COMMAND_SET_CHARGE_PUMP);
+    Spi2Put(OLED_SETTING_ENABLE_CHARGE_PUMP);
+    Spi2Put(OLED_COMMAND_SET_PRECHARGE_PERIOD);
+    Spi2Put(OLED_SETTING_MAXIMUM_PRECHARGE);
+
+    // Power on the display, giving it 100ms to start up.
+    OLED_DRIVER_OLED_POWER_PORT = 0;
+
+    DelayMs(100);
+
+    // Invert row numbering so that (0,0) is upper-right.
+    Spi2Put(OLED_COMMAND_SET_SEGMENT_REMAP);
+    Spi2Put(OLED_SETTING_REVERSE_ROW_ORDERING);
+
+    // Set sequential COM configuration with non-interleaved memory.
+    Spi2Put(OLED_COMMAND_SET_COM_PINS_CONFIG);
+    Spi2Put(OLED_SETTING_SEQUENTIAL_COM_NON_INTERLEAVED);
+
+    // And turn on the display.
+    Spi2Put(OLED_COMMAND_DISPLAY_ON);
+}
+
+/**
+ * Set the LCD to display pixel values as the opposite of how they are actually stored in NVRAM. So
+ * pixels set to black (0) will display as white, and pixels set to white (1) will display as black.
+ */
+void OledDriverSetDisplayInverted(void)
+{
+    // Set the OLED into command mode.
+    OLED_DRIVER_MODE_PORT = 0;
+
+    Spi2Put(OLED_COMMAND_DISPLAY_INVERTED);
+}
+
+/**
+ * Set the LCD to display pixel values normally, where a 1 indicates white and a 0 indicates black.
+ * This is the default operating mode of the LCD and the mode it starts up in.
+ */
+void OledDriverSetDisplayNormal(void)
+{
+    // Set the OLED into command mode.
+    OLED_DRIVER_MODE_PORT = 0;
+
+    Spi2Put(OLED_COMMAND_DISPLAY_NORMAL);
+}
+
+/**
+ * Disable the Oled display before power-off. This means powering it up, sending the display off
+ * command, and finally disabling Vbat.
+ */
+void OledDriverDisableDisplay(void)
+{
+    // Set the OLED into command mode.
+    OLED_DRIVER_MODE_PORT = 0;
+
+    // Power on the OLED display logic, waiting for 1ms for it to start up.
+    OLED_DRIVER_CONTROLLER_POWER_PORT = 0;
+    DelayMs(1);
+
+    // Send the display off command.
+    Spi2Put(OLED_COMMAND_DISPLAY_OFF);
+
+    // And finally power off the display, giving it 100ms to do so.
+    OLED_DRIVER_CONTROLLER_POWER_PORT = 1;
+    DelayMs(100);
+}
+
+/**
+ * Update the display with the contents of rgb0ledBmp.
+ */
+void OledDriverUpdateDisplay(void)
+{
+    uint8_t *pb = rgbOledBmp;
+    int page;
+    for (page = 0; page < OLED_DRIVER_PAGES; page++) {
+        // Set the LCD into command mode.
+        //        PORTClearBits(OLED_DRIVER_MODE_PORT, OLED_DRIVER_MODE_BIT);
+        OLED_DRIVER_MODE_PORT = 0;
+
+        // Set the desired page.
+        Spi2Put(OLED_COMMAND_SET_PAGE);
+        Spi2Put(page);
+
+        // Set the starting column back to the origin.
+        Spi2Put(OLED_COMMAND_SET_DISPLAY_LOWER_COLUMN_0);
+        Spi2Put(OLED_COMMAND_SET_DISPLAY_UPPER_COLUMN_0);
+
+        // Return the LCD to data mode.
+        //        PORTSetBits(OLED_DRIVER_MODE_PORT, OLED_DRIVER_MODE_BIT);
+        OLED_DRIVER_MODE_PORT = 1;
+
+        // Finally write this entire column to the OLED.
+        //		SpiChnPutS()
+        OledPutBuffer(OLED_DRIVER_PIXEL_COLUMNS, pb);
+        pb += OLED_DRIVER_PIXEL_COLUMNS;
+    }
+}
+
+/**
+ * Write an entire array of uint8_ts over SPI2.
+ * @param size The number of uint8_ts to write.
+ * @param buffer The start of the uint8_t array to write.
+ */
+void OledPutBuffer(int size, uint8_t *buffer)
+{
+    uint8_t bTmp = 0;
+    int i = bTmp; //non ideal way of forcing Wall error to go away
+    for (i = 0; i < size; ++i) {
+        // Make sure the transmitter is ready
+        while (SPI2STATbits.SPITBE == 0);
+
+        // Then transmit the desired uint8_t.
+        SPI2BUF = *buffer++;
+
+        // And wait for a response. It's ignored, but we read it out of the buffer anyways to keep
+        // the buffer clear.
+        while (SPI2STATbits.SPIRBF == 0);
+        bTmp = SPI2BUF;
+    }
+}
+
+/**
+ * Performs a blocking write of a single uint8_t over SPI2. The response uint8_t is returned.
+ * @param bVal The uint8_t to write over SPI.
+ * @return The response to the transmission.
+ */
+uint8_t Spi2Put(uint8_t bVal)
+{
+    // Make sure the transmitter is ready
+    while (SPI2STATbits.SPITBE == 0);
+
+    // Then transmit the desired uint8_t.
+    SPI2BUF = bVal;
+
+    // And wait for a response.
+    while (SPI2STATbits.SPIRBF == 0);
+
+    // Before returning it.
+    uint8_t bRx = SPI2BUF;
+    return bRx;
+}
+
+/**
+ * Block the processor for the desired number of milliseconds.
+ * @note Assumes processor frequency of 80Mhz.
+ * @param msec The number of milliseconds to block for.
+ */
+void DelayMs(uint32_t msec)
+{
+    uint32_t tWait, tStart, tCurrent;
+
+    // Calculate the amount of wait time in terms of core processor frequency.
+    tWait = (80000000L / 2000) * msec;
+    asm volatile("mfc0   %0, $9" : "=r"(tStart));
+    tCurrent = tStart;
+    while ((tCurrent - tStart) < tWait) {
+        asm volatile("mfc0   %0, $9" : "=r"(tCurrent));
+    }// wait for the time to pass
+}
\ No newline at end of file
diff --git a/Common/OledDriver.h b/Common/OledDriver.h
new file mode 100644
index 0000000..0cde9bf
--- /dev/null
+++ b/Common/OledDriver.h
@@ -0,0 +1,87 @@
+#ifndef OLED_DRIVER_H
+#define OLED_DRIVER_H
+
+// Include standard C libraries.
+#include <stdint.h>
+
+// Include Microchip C libraries.
+#include <xc.h>
+
+/**
+ * Configure the port and pins for each of the 4 control signals used with the OLED:
+ *   * F6: Controls the power to the controller logic. Active-low, so a 0 powers it on.
+ *   * F5: Controls the power to the OLED display. Active-low, so a 0 powers it on.
+ *   * F4: Sets the input mode of the controller logic. High indicates incoming data is display
+ *         data, while low indicates they're commands.
+ *   * G9: Reset pin connected to the display controller. Active-low, so a 0 holds the logic in
+ *         reset.
+ */
+
+#define OLED_DRIVER_CONTROLLER_POWER_PORT PORTFbits.RF6
+#define OLED_DRIVER_CONTROLLER_POWER_TRIS TRISFbits.TRISF6
+
+#define OLED_DRIVER_OLED_POWER_PORT PORTFbits.RF5
+#define OLED_DRIVER_OLED_POWER_TRIS TRISFbits.TRISF5
+
+#define OLED_DRIVER_MODE_PORT PORTFbits.RF4
+#define OLED_DRIVER_MODE_TRIS TRISFbits.TRISF4
+
+#define OLED_DRIVER_RESET_PORT PORTGbits.RG9
+#define OLED_DRIVER_RESET_TRIS TRISGbits.TRISG9
+
+
+// The number of pixel columns in the OLED display.
+#define OLED_DRIVER_PIXEL_COLUMNS                                                          128
+
+// The number of pixel rows in the OLED display.
+#define OLED_DRIVER_PIXEL_ROWS                                                              32
+
+// Store how high each column is for the OLED in bits in terms of data structure storage.
+#define OLED_DRIVER_BUFFER_LINE_HEIGHT                                                       8
+
+// The number of bytes required to store all the data for the whole display. 1 bit / pixel.
+#define OLED_DRIVER_BUFFER_SIZE     ((OLED_DRIVER_PIXEL_COLUMNS * OLED_DRIVER_PIXEL_ROWS) / 8)
+
+/**
+ * This array is the off-screen frame buffer used for rendering. It isn't possible to read back from
+ * the OLED display device, so display data is rendered into this off-screen buffer and then copied
+ * to the display. The high-order bits equate to the lower pixel rows.
+ * @note Any time this is updated, An `OledDriverUpdateDisplay()` call must be performed.
+ */
+extern uint8_t rgbOledBmp[OLED_DRIVER_BUFFER_SIZE];
+
+/**
+ * Initialize the PIC32MX to communicate with the UG-23832HSWEG04 OLED display through the SSD1306
+ * display controller.
+ */
+void OledHostInit(void);
+
+/**
+ * Initialize the OLED display and driver circuitry.
+ */
+void OledDriverInitDisplay(void);
+
+/**
+ * Disable the Oled display before power-off. This means powering it up, sending the display off
+ * command, and finally disabling Vbat.
+ */
+void OledDriverDisableDisplay(void);
+
+/**
+ * Update the display with the contents of rgb0ledBmp.
+ */
+void OledDriverUpdateDisplay(void);
+
+/**
+ * Set the LCD to display pixel values as the opposite of how they are actually stored in NVRAM. So
+ * pixels set to black (0) will display as white, and pixels set to white (1) will display as black.
+ */
+void OledDriverSetDisplayInverted(void);
+
+/**
+ * Set the LCD to display pixel values normally, where a 1 indicates white and a 0 indicates black.
+ * This is the default operating mode of the LCD and the mode it starts up in.
+ */
+void OledDriverSetDisplayNormal(void);
+
+#endif // OLED_DRIVER_H
\ No newline at end of file
diff --git a/Common/PING.h b/Common/PING.h
new file mode 100644
index 0000000..49583db
--- /dev/null
+++ b/Common/PING.h
@@ -0,0 +1,101 @@
+/**
+ * @file    PING.h
+ * @brief   Ultrasonic Ping Sensor sensing module
+ * @author  CMPE167 Staff
+ * @date    1/15/2019
+ * @detail  This module uses the timer and the change notify peripheral to interface to an
+ *          ultrasonic ranging sensor. 
+ *          If you are unfamiliar with change notify or timers, please read the lab appendix before beginning.
+ *          The timer peripheral is used to create the required trigger pulses. To do so you will need to modify when
+ *          the next interrupt occurs by modifying the PR4 register to create the periodic pulse.
+ *          The timer has already been set up with a 64:1 prescaler. The trigger pin has not been set and is up to you.
+ *
+ *          The change notify is configured to operate on CN14 or pin 34 on the I/O shield.  
+ *          Instead of using a hardware timer we will use the TIMERS library to calculate the duration of the pulse
+ *          in microseconds.
+ *          To alleviate setup headaches the code for setting up the peripherals and interrupts is below.
+ *
+ *          char PING_Init(void) {
+ *            // following block inits the timer
+ *            T4CON = 0;
+ *            T4CONbits.TCKPS = 0b110;
+ *            PR4 = 0xFFFF;  // this is not the timer value wanted
+ *            T4CONbits.ON = 1;
+ *            IFS0bits.T4IF = 0;
+ *            IPC4bits.T4IP = 3;
+ *            IEC0bits.T4IE = 1;
+ * 
+ *            // following block inits change notify
+ *            CNCONbits.ON = 1; // Change Notify On
+ *            CNENbits.CNEN14 = 1;
+ *            int temp = PORTD; // this is intentional to ensure a interrupt occur immediately upon enabling
+ *            IFS1bits.CNIF = 0; // clear interrupt flag
+ *            IPC6bits.CNIP = 1; //set priority
+ *            IPC6bits.CNIS = 3; // and sub priority
+ *            IEC1bits.CNIE = 1; // enable change notify
+ *              //Anything else that needs to occur goes here
+ *          }
+ * 
+ *          void __ISR(_CHANGE_NOTICE_VECTOR) ChangeNotice_Handler(void) {
+ *              static char readPort = 0;
+ *              readPort = PORTD; // this read is required to make the interrupt work
+ *              IFS1bits.CNIF = 0; 
+ *              //Anything else that needs to occur goes here
+ *          }
+ * 
+ *          void __ISR(_TIMER_4_VECTOR) Timer4IntHandler(void) {
+ *              IFS0bits.T4IF = 0;
+ *              //Anything else that needs to occur goes here
+ *          }
+ *          
+ */
+
+#ifndef PING_H
+#define PING_H
+
+/*******************************************************************************
+ * INCLUDES                                                                    *
+ ******************************************************************************/
+#include "BOARD.h"
+#include <xc.h>
+#include <sys/attribs.h>
+
+
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @function    PING_Init(void)
+ * @brief       Sets up both the timer and Change notify peripherals along with their
+ *              respective interrupts.  Also handles any other tasks needed such as pin 
+ *              I/O directions, and any other things you need to initialize the sensor.
+ *              TIMERS library must be inited before this library.
+ * @return      SUCCESS or ERROR (as defined in BOARD.h)
+ */
+char PING_Init(void);
+
+/**
+ * @function    PING_GetDistance(void)
+ * @brief       Returns the calculated distance in mm using the sensor model determined
+ *              experimentally. 
+ *              No I/O should be done in this function
+ * @return      distance in mm
+ */
+unsigned int PING_GetDistance(void);
+
+/**
+ * @function    PING_GetTimeofFlight(void)
+ * @brief       Returns the raw microsecond duration of the echo from the sensor.
+ *              NO I/O should be done in this function.
+ * @return      time of flight in uSec
+ */
+unsigned int PING_GetTimeofFlight(void);
+
+#endif
\ No newline at end of file
diff --git a/Common/QEI.h b/Common/QEI.h
new file mode 100644
index 0000000..f51b47c
--- /dev/null
+++ b/Common/QEI.h
@@ -0,0 +1,84 @@
+/* 
+ * @file    QEI.h
+ * @brief   Quadrature Encoder sensing module
+ * @author  CMPE167 Staff
+ * @date    1/15/2019
+ * @detail  This module uses the change notify peripheral to interface to a quadrature encoder. 
+ *          If you are unfamiliar with change notify please read the lab appendix before beginning.
+ *          The peripheral is configured to generate an interrupt on any change in input of pins RD6
+ *          or RD7 (pins 36 and 37 on the Uno32). The interrupt will not tell you which pin changed
+ *          states so you will need to implement a simple state machine to handle the transitions and
+ *          keep track of the encoder count.
+ *          NOTE: Encoder A and B must be input to pins 36 and 37
+ *
+ *          To alleviate setup headaches the code for setting up the peripheral and the interrupt is below.
+ *
+ *          char QEI_Init(void) {
+ *               // INIT Change notify
+ *               CNCONbits.ON = 1; // Change Notify On
+ *               CNENbits.CNEN15 = 1; //enable one phase
+ *               CNENbits.CNEN16 = 1; //enable other phase
+ *               int temp = PORTD; // this is intentional to ensure a interrupt occur immediately upon enabling
+ *               IFS1bits.CNIF = 0; // clear interrupt flag
+ *               IPC6bits.CNIP = 1; //set priority
+ *               IPC6bits.CNIS = 3; // and sub priority
+ *               IEC1bits.CNIE = 1; // enable change notify
+ * 
+ *                // the rest of the function goes here
+ *          }
+ *
+ *          void __ISR(_CHANGE_NOTICE_VECTOR) ChangeNotice_Handler(void) {
+ *               static char readPort = 0;
+ *               readPort = PORTD; // this read is required to make the interrupt work
+ *               IFS1bits.CNIF = 0;
+ *               //anything else that needs to happen goes here
+ *          }
+ */
+
+#ifndef QEI_H
+#define	QEI_H
+
+/*******************************************************************************
+ * INCLUDES                                                                    *
+ ******************************************************************************/
+#include "BOARD.h"
+#include <xc.h>
+#include <sys/attribs.h>
+
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+ 
+ 
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/ 
+
+ 
+/**
+ * @function QEI_Init(void)
+ * @param none
+ * @brief  Enables the Change Notify peripheral and sets up the interrupt, anything
+ *         else that needs to be done to initialize the module. 
+ * @return SUCCESS or ERROR (as defined in BOARD.h)
+*/
+char QEI_Init(void);
+
+/**
+ * @function QEI_GetPosition(void) 
+ * @param none
+ * @brief This function returns the current count of the Quadrature Encoder in ticks.      
+*/
+int QEI_GetPosition(void);
+
+/**
+ * @Function QEI_ResetPosition(void) 
+ * @param  none
+ * @return none
+ * @brief  Resets the encoder such that it starts counting from 0.
+*/
+void QEI_ResetPosition(); 
+
+#endif	/* QEI_H */
+
diff --git a/Common/ToneGeneration.c b/Common/ToneGeneration.c
new file mode 100644
index 0000000..8baa04b
--- /dev/null
+++ b/Common/ToneGeneration.c
@@ -0,0 +1,168 @@
+/*
+ * File:   ToneGeneration.c
+ * Author: mdunne
+ *
+ */
+
+#include "BOARD.h"
+#include "serial.h"
+#include "ToneGeneration.h"
+#include <xc.h>
+#ifdef TONEGENERATION_TEST
+#include <stdio.h>
+#endif
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+#define F_PB (BOARD_GetPBClock())
+
+
+
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                            *
+ ******************************************************************************/
+
+static unsigned char toneOn = FALSE;
+static unsigned int toneFrequency = 0;
+static unsigned char toneSystemActive = FALSE;
+
+/*******************************************************************************
+ * PRIVATE FUNCTION PROTOTYPES                                                            *
+ ******************************************************************************/
+
+#define TONEDUTY_REGISTER OC1RS
+#define TONERESET_REGISTER OC1R
+#define TONECONFIG_REGISTER OC1CON
+
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @Function ToneGeneration_Init(void)
+ * @param None
+ * @return SUCCESS or ERROR
+ * @brief  Initializes the timer and PWM for the tone system
+ * @note  None.
+ * @author Max Dunne */
+char ToneGeneration_Init(void)
+{
+    if (toneSystemActive) {
+        return ERROR;
+    }
+
+    toneSystemActive = TRUE;
+
+    ToneGeneration_SetFrequency(DEFAULT_TONE);
+
+    ToneGeneration_ToneOff();
+    TONERESET_REGISTER = 0;
+    TONECONFIG_REGISTER = (_OC1CON_ON_MASK | 0b110 << _OC1CON_OCM_POSITION | _OC1CON_OCTSEL_MASK);
+
+    return SUCCESS;
+}
+
+/**
+ * @Function ToneGeneration_SetFrequency(unsigned int NewFrequency)
+ * @param NewFrequency - new frequency to set. 
+ * @return SUCCESS OR ERROR
+ * @brief  Changes the frequency of the ToneGeneration system.
+ * @note  Behavior of ToneGeneration during Frequency change is undocumented
+ * @author Max Dunne */
+char ToneGeneration_SetFrequency(unsigned int NewFrequency)
+{
+    if (!toneSystemActive) {
+        return ERROR;
+    }
+
+    if (NewFrequency == toneFrequency) {
+        return SUCCESS;
+    }
+    if (NewFrequency < 1) {
+        return ERROR;
+    }
+
+    T3CON = 0;
+
+    if (NewFrequency <= 1000) {
+        T3CONbits.TCKPS = 0b101; // set the prescaler to 1:32
+        PR3 = F_PB / 32 / NewFrequency;
+    } else {
+        T3CONbits.TCKPS = 0;
+    }
+
+    TMR3 = 0;
+    TONEDUTY_REGISTER = (PR3 + 1) >> 1;
+    T3CONbits.ON = 1;
+    toneFrequency = NewFrequency;
+
+    return SUCCESS;
+}
+
+/**
+ * @Function ToneGeneration_GetFrequency(void)
+ * @return Frequency of system in Hertz
+ * @brief  gets the frequency of the ToneGeneration system.
+ * @author Max Dunne */
+unsigned int ToneGeneration_GetFrequency(void)
+{
+    return toneFrequency;
+}
+
+void ToneGeneration_ToneOff(void)
+{
+    TONEDUTY_REGISTER = 0;
+    toneOn = FALSE;
+}
+
+void ToneGeneration_ToneOn(void)
+{
+    if (toneOn) {
+        return;
+    }
+    toneOn = TRUE;
+    TONEDUTY_REGISTER = (PR3 + 1) >> 1;
+    //    printf("Duty Cycles: %d\t%d\r\n", PR3, TONEDUTY_REGISTER);
+}
+
+/*******************************************************************************
+ * PRIVATE FUNCTIONS                                                       *
+ ******************************************************************************/
+
+
+#ifdef TONEGENERATION_TEST
+
+#define DELAY(x)    {int wait; for (wait = 0; wait <= x; wait++) {asm("nop");}}
+#define A_BIT       18300
+#define A_LOT       183000
+static int ToneArray[] = {TONE_196, TONE_293, TONE_440, TONE_293, TONE_440, TONE_659};
+#include <stdio.h>
+
+int main(void)
+{
+
+    BOARD_Init();
+    printf("Beginning Tone Generation Test\r\n");
+
+    ToneGeneration_Init();
+
+    int curIndex;
+    while (1) {
+        for (curIndex = 0; curIndex < 6; curIndex++) {
+            ToneGeneration_SetFrequency(ToneArray[curIndex]);
+            ToneGeneration_ToneOn();
+            printf("\r\nOutputting Tone %d", ToneArray[curIndex]);
+            DELAY(A_LOT);
+        }
+        printf("\r\nOutputting Tone %d", 0);
+        ToneGeneration_ToneOff();
+        DELAY(A_LOT);
+    }
+    return 0;
+}
+
+#endif
\ No newline at end of file
diff --git a/Common/ToneGeneration.h b/Common/ToneGeneration.h
new file mode 100644
index 0000000..66cf3ae
--- /dev/null
+++ b/Common/ToneGeneration.h
@@ -0,0 +1,79 @@
+/*
+ * File:   ToneGeneration.h
+ * Author: mdunne
+ *
+ * Software module to run one PWM module for tone generation. 
+ * PIN3 on the Uno32 is used for tone generation
+ * 
+ *
+
+ */
+
+#ifndef TONEGENERATION_H
+#define TONEGENERATION_H
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+#define MIN_TONE 1
+
+
+#define TONE_196 196
+#define TONE_293 293
+#define TONE_440 440
+#define TONE_659 659
+
+
+#define DEFAULT_TONE TONE_440
+
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+
+/**
+ * @Function ToneGeneration_Init(void)
+ * @param None
+ * @return SUCCESS or ERROR
+ * @brief  Initializes the timer and PWM for the tone system
+ * @note  None.
+ * @author Max Dunne */
+char ToneGeneration_Init(void);
+
+/**
+ * @Function ToneGeneration_SetFrequency(unsigned int NewFrequency)
+ * @param NewFrequency - new frequency to set. 
+ * @return SUCCESS OR ERROR
+ * @brief  Changes the frequency of the ToneGeneration system.
+ * @note  Behavior of ToneGeneration during Frequency change is undocumented
+ * @author Max Dunne */
+char ToneGeneration_SetFrequency(unsigned int NewFrequency);
+
+
+/**
+ * @Function ToneGeneration_GetFrequency(void)
+ * @return Frequency of system in Hertz
+ * @brief  gets the frequency of the ToneGeneration system.
+ * @author Max Dunne */
+unsigned int ToneGeneration_GetFrequency(void);
+
+
+/**
+ * @Function ToneGeneration_ToneOff(void)
+ * @return Turns Tone Off
+ * @author Max Dunne */
+void ToneGeneration_ToneOff(void);
+
+
+/**
+ * @Function ToneGeneration_ToneOn(void)
+ * @return Turns Tone On
+ * @author Max Dunne */
+
+void ToneGeneration_ToneOn(void);
+
+
+
+#endif
diff --git a/Common/pwm.c b/Common/pwm.c
new file mode 100644
index 0000000..3760d34
--- /dev/null
+++ b/Common/pwm.c
@@ -0,0 +1,837 @@
+/*
+ * File:   pwm.c
+ * Author: mdunne
+ *
+ * Created on November 12, 2011, 9:28 AM
+ */
+
+#include <xc.h>
+#include <BOARD.h>
+
+#include <pwm.h>
+#include <stdio.h>
+
+
+
+
+
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+#define F_PB (BOARD_GetPBClock())
+
+//#define PWM_DEBUG_VERBOSE
+#ifdef PWM_DEBUG_VERBOSE
+#include "serial.h"
+#define dbprintf(...) while(!IsTransmitEmpty()); printf(__VA_ARGS__)
+#else
+#define dbprintf(...)
+#endif
+
+#define ALLPWMPINS (PWM_PORTZ06|PWM_PORTY12|PWM_PORTY10|PWM_PORTY04|PWM_PORTX11)
+#define NUM_PWM_CHANNELS 5
+
+
+
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                            *
+ ******************************************************************************/
+static unsigned char PWMActive = FALSE;
+//static unsigned int usedChannels;
+static volatile unsigned int * const Duty_Registers[] = {&OC1RS, &OC2RS, &OC3RS, &OC4RS, &OC5RS};
+static volatile unsigned int * const Reset_Registers[] = {&OC1R, &OC2R, &OC3R, &OC4R, &OC5R};
+static volatile unsigned int * const Config_Registers[] = {&OC1CON, &OC2CON, &OC3CON, &OC4CON, &OC5CON};
+static unsigned int PWMActivePins;
+static unsigned int PWMFrequency;
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @Function PWM_Init(void)
+ * @param None
+ * @return SUCCESS or ERROR
+ * @brief  Initializes the timer for the PWM system and set is to the default frequency
+ * @note  None.
+ * @author Max Dunne, 2011.11.12 */
+char PWM_Init(void)
+{
+    if (PWMActive) {
+        dbprintf("%s tried to init when already initialized", __FUNCTION__);
+        return ERROR;
+    }
+    PWMActive = TRUE;
+    PWM_SetFrequency(PWM_DEFAULT_FREQUENCY);
+    PWMActivePins = 0;
+    return SUCCESS;
+}
+
+/**
+ * @Function PWM_SetFrequency(unsigned int NewFrequency)
+ * @param NewFrequency - new frequency to set. best to use #defined from header
+ * @return SUCCESS OR ERROR
+ * @brief  Changes the frequency of the PWM system.
+ * @note  Behavior of PWM channels during Frequency change is undocumented
+ * @author Max Dunne, 2013.08.19 */
+char PWM_SetFrequency(unsigned int NewFrequency)
+{
+    if (!PWMActive) {
+        dbprintf("%s called before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((NewFrequency < MIN_PWM_FREQ) | (MAX_PWM_FREQ < NewFrequency)) {
+        dbprintf("%s called with frequency outside bounds: %d", __FUNCTION__, NewFrequency);
+        return ERROR;
+    }
+    if (NewFrequency != 0) {
+        //turn off the timer in preperation to restarting it with the new fequency
+        T2CON = 0;
+    }
+    if (NewFrequency <= 1000) {
+        T2CONbits.TCKPS = 0b101; // set the prescaler to 1:32
+        PR2 = F_PB / 32 / NewFrequency;
+        dbprintf("Period less than 1KHz, setting prescaler to 32\r\n");
+    } else {
+        T2CONbits.TCKPS = 0;
+        PR2 = F_PB / NewFrequency;
+        dbprintf("Period greater than 1KHz, setting prescaler to 1\r\n");
+    }
+    TMR2 = 0;
+    T2CONbits.ON = 1;
+    PWMFrequency = NewFrequency;
+    return SUCCESS;
+}
+
+/**
+ * @Function PWM_GetFrequency(void)
+ * @return Frequency of system in Hertz
+ * @brief  gets the frequency of the PWM system.
+ * @author Max Dunne, 2013.08.19 */
+unsigned int PWM_GetFrequency(void)
+{
+    if (!PWMActive) {
+        dbprintf("%s called before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    return (PWMFrequency);
+}
+
+/**
+ * @Function PWM_AddPins(unsigned short int AddPins)
+ * @param AddPins - use #defined PWM_PORTxxx OR'd together for each A/D Pin you wish to add
+ * @return SUCCESS OR ERROR
+ * @brief  Adds new pins to the PWM system.  If any pin is already active it errors 
+ * out
+ * @author Max Dunne, 2013.08.15 */
+char PWM_AddPins(unsigned short int AddPins)
+{
+    if (!PWMActive) {
+        dbprintf("%s returning ERROR before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((AddPins == 0) || (AddPins > ALLPWMPINS)) {
+        dbprintf("%s returning ERROR with pins outside range: %X\r\n", __FUNCTION__, AddPins);
+        return ERROR;
+    }
+
+    if (PWMActivePins & AddPins) {
+        dbprintf("%s Returning ERROR for pins already in state: %X \r\n", __FUNCTION__, AddPins);
+        return ERROR;
+    }
+    int PinCount = 0;
+    //sets new pwm pins in the on state while setting their duty cycles to zero
+    for (PinCount = 0; PinCount < ALLPWMPINS; PinCount++) {
+        if (AddPins & (1 << PinCount)) {
+            *Duty_Registers[PinCount] = 0;
+            *Reset_Registers[PinCount] = 0;
+            // we can use OC1 for all masks as the registers don't change
+            *Config_Registers[PinCount] = (_OC1CON_ON_MASK | 0b110 << _OC1CON_OCM_POSITION);
+            dbprintf("PWM pin #%d has been added to the system\r\n", PinCount);
+        }
+    }
+
+    PWMActivePins |= AddPins;
+    return SUCCESS;
+}
+
+/**
+ * @Function PWM_RemovePins(unsigned int PWMPins)
+ * @param RemovePins - use #defined AD_PORTxxx OR'd together for each A/D Pin you wish to remove
+ * @return SUCCESS OR ERROR
+ * @brief  Remove pins from the PWM system.  If any pin is not active it errors out
+ * @author Max Dunne, 2013.08.15 */
+char PWM_RemovePins(unsigned int PWMPins)
+{
+    if (!PWMActive) {
+        dbprintf("%s returning ERROR before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((PWMPins == 0) || (PWMPins > ALLPWMPINS)) {
+        dbprintf("%s returning ERROR with pins outside range: %X\r\n", __FUNCTION__, PWMPins);
+        return ERROR;
+    }
+    if (!(PWMActivePins & PWMPins)) {
+        dbprintf("%s Returning ERROR for pins already in state: %X \r\n", __FUNCTION__, PWMPins);
+        return ERROR;
+    }
+    int PinCount = 0;
+    for (PinCount = 0; PinCount < ALLPWMPINS; PinCount++) {
+        if (PWMPins & (1 << PinCount)) {
+            *Duty_Registers[PinCount] = 0;
+            *Reset_Registers[PinCount] = 0;
+            *Config_Registers[PinCount] &= (~_OC1CON_ON_MASK);
+        }
+    }
+    PWMActivePins &= (~PWMPins);
+    return SUCCESS;
+}
+
+/**
+ * @Function PWM_ListPins(void)
+ * @param None
+ * @return Listing of all PWM pins that are active.
+ * @brief  Returns a variable of all active pwm pins. An individual pin can be determined 
+ * if active by "anding" with the pwm_PORTXX Macros
+ * @author Max Dunne, 2013.08.19 */
+unsigned int PWM_ListPins(void)
+{
+    return PWMActivePins;
+}
+
+/**
+ * Function  PWM_SetDutyCycle
+ * @param Channels, use #defined PWM_PORTxxx
+ * @param Duty, duty cycle for the channel (0-1000)
+ * @return SUCCESS or ERROR
+ * @remark Sets the Duty Cycle for a Single Channel and returns error if that channel is not enabled
+ * @author Max Dunne
+ * @date 2011.11.12  */
+char PWM_SetDutyCycle(unsigned char Channel, unsigned int Duty)
+{
+    if (!PWMActive) {
+        dbprintf("%s returning ERROR before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((Channel == 0 || Channel > ALLPWMPINS)) {
+        dbprintf("%s returning error with pin out of bounds: %X\r\n", __FUNCTION__, Channel);
+        return ERROR;
+    }
+    if (!(Channel & PWMActivePins)) {
+        dbprintf("%s returning error with unactivated pin: %X %X\r\n", __FUNCTION__, Channel, PWMActivePins);
+        return ERROR;
+    }
+    if (Duty < 0 || Duty > 1000) {
+        dbprintf("%s returning error with duty cycle out of bounds: %d\r\n", __FUNCTION__, Duty);
+        return ERROR;
+    }
+
+    unsigned int ScaledDuty = 0;
+    unsigned int TranslatedChannel = 0;
+    ScaledDuty = ((PR2 + 1) * Duty) / MAX_PWM;
+    while (Channel > 1) {
+        Channel >>= 1;
+        TranslatedChannel++;
+    }
+    dbprintf("Translated Channel is %d and Scaled Duty is %d\r\n", TranslatedChannel, ScaledDuty);
+    *Duty_Registers[TranslatedChannel] = ScaledDuty;
+    return SUCCESS;
+
+}
+
+/**
+ * Function  PWM_GetDutyCycle
+ * @param Channels, use #defined PWM_PORTxxx
+ *
+ * @return Duty cycle
+ * @remark Gets the Duty Cycle for a Single Channel and returns error if that channel is not enabled
+ * @author Max Dunne
+ * @date 2011.11.12  */
+unsigned int PWM_GetDutyCycle(char Channel)
+{
+    if (!PWMActive) {
+        dbprintf("%s returning ERROR before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((Channel == 0 || Channel > ALLPWMPINS)) {
+        dbprintf("%s returning error with pin out of bounds: %X\r\n", __FUNCTION__, Channel);
+        return ERROR;
+    }
+    if (!(Channel & PWMActivePins)) {
+        dbprintf("%s returning error with unactivated pin: %X %X\r\n", __FUNCTION__, Channel, PWMActivePins);
+        return ERROR;
+    }
+
+    unsigned int ScaledDuty = 0;
+    unsigned int Duty = 0;
+    unsigned int TranslatedChannel = 0;
+
+    while (Channel > 1) {
+        Channel >>= 1;
+        TranslatedChannel++;
+    }
+    ScaledDuty = *Duty_Registers[TranslatedChannel];
+    Duty = (ScaledDuty * MAX_PWM) / (PR2 + 1) + 1;
+    if (Duty > MAX_PWM) {
+        //one off error due to integer division
+        Duty = MAX_PWM;
+    }
+    dbprintf("Translated Channel is %d and unScaled Duty is %d\r\n", TranslatedChannel, Duty);
+
+    return Duty;
+
+}
+
+/**
+ * Function: PWM_End
+ * @param None
+ * @return SUCCESS or ERROR
+ * @remark Disables the PWM sub-system and releases all pins.
+ * @author Max Dunne
+ * @date 2011.11.12  */
+char PWM_End(void)
+{
+    int Curpin;
+    if (!PWMActive) {
+        return ERROR;
+    }
+    for (Curpin = 0; Curpin < NUM_PWM_CHANNELS; Curpin++) {
+        *Duty_Registers[Curpin] = 0;
+        *Reset_Registers[Curpin] = 0;
+    }
+    IEC0CLR = _IEC0_T2IE_MASK | _IEC0_OC1IE_MASK | _IEC0_OC2IE_MASK | _IEC0_OC3IE_MASK | _IEC0_OC4IE_MASK | _IEC0_OC5IE_MASK;
+
+    PWMActive = FALSE;
+    PWMFrequency = 0;
+    return SUCCESS;
+}
+
+
+/*******************************************************************************
+ * TEST HARNESS                                                                *
+ ******************************************************************************/
+#ifdef PWM_TEST
+
+#include <xc.h>
+#include <serial.h>
+#include "PWM.h"
+#include <stdio.h>
+
+
+#define DELAY(x)    for (wait = 0; wait <= x; wait++) {asm("nop");}
+#define A_BIT       40000
+#define A_LOT       80000
+#define NUM2SWEEP   10
+#define NUM2SPIN    2
+#define INC         100
+#define PWM_PORT     PWM_PORTX04
+
+#define FIFTY_PERCENT_DUTY 500
+//#define GetArray(Name)  Name ## Goober
+//#define GetArrayWrapper()
+//#define Str(x)   #Str
+//GetArray(__FUNCTION__)[0]=3;
+
+int main(void)
+{
+    unsigned int wait = 0;
+    unsigned short int duty;
+    unsigned short int i, j, k;
+    char testPassed = FALSE;
+    //    int8_t wantedResult = SUCCESS;
+    DELAY(A_BIT);
+
+    BOARD_Init();
+    printf("\nCMPE118 PWM module test harness.");
+    printf("\nInitial Test, ensure all functions return ERROR "
+            "before PWM_Init() is run\n");
+
+    /***************************************************************************
+     *            TEST PWM MODULE ERROR CHECKING BEFORE ENABLE                  *
+     ***************************************************************************/
+    //
+    // PWM_AddPins() should FAIL before enable
+    //
+    printf("\nTesting: PWM_AddPins() for each pin before enable: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_AddPins(i) == ERROR) {
+
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_AddPins(0x%03x) returned SUCCESS: TEST FAILED", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+
+    //
+    // PWM_RemovePins() should FAIL before enable
+    //
+    printf("\nTesting: PWM_RemovePins() for each pin before enable: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_RemovePins(i) == ERROR) {
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_RemovePins(0x%03x) returned SUCCESS: TEST FAILED", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+
+    //
+    // PWM_SetDutyCycle() should FAIL before enable
+    //
+    printf("\nTesting: PWM_SetDutyCycle() for each pin before enable: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_SetDutyCycle(i, FIFTY_PERCENT_DUTY) == ERROR) {
+            DELAY(A_BIT);
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_SetDutyCycle(0x%03x) returned SUCCESS "
+                    "before enable: FAILED TEST", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+
+    //
+    // PWM_GetPulseTime() should FAIL before enable
+    //
+    printf("\nTesting: PWM_GetPulseTime() for each pin before enable: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_GetDutyCycle(i) == ERROR) {
+            DELAY(A_BIT);
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_GetPulseTime(0x%03x) returned SUCCESS "
+                    "before enable: FAILED TEST", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+
+    //
+    // PWM_ListPins() should return all zeros
+    //
+    printf("\nTesting: PWM_ListPins() before enable: ");
+    if (PWM_ListPins() == 0x000) {
+        printf("PASSED");
+    } else {
+        printf("FAILED");
+        printf("\nPWM_ListPins() = 0x%03x, FAILED TEST", PWM_ListPins());
+    }
+
+    //
+    // PWM_End() should FAIL before enable
+    //
+    printf("\nTesting: PWM_End() before enable: ");
+    if (PWM_End() == ERROR) {
+        printf("PASSED");
+    } else {
+        printf("FAILED TEST");
+    }
+    printf("\nPWM Module tests before PWM_Init() complete.\n");
+
+    /***************************************************************************
+     *            ENABLE PWM MODULE TEST INIT AND END                           *
+     ***************************************************************************/
+    //
+    //Enable module, test error checking on all functions
+    //
+    DELAY(A_BIT);
+    printf("\nTesting: Enable Module and re-test bounds checking");
+    printf("\nEnabling PWM module with PWM_Init(): ");
+    if (PWM_Init() == SUCCESS) {
+        printf("PASSED");
+    } else {
+        printf("FAILED TEST");
+    }
+    DELAY(A_BIT);
+    printf("\nRe-enabling PWM module with PWM_Init(): ");
+    if (PWM_Init() == SUCCESS) {
+        printf("FAILED TEST");
+    } else {
+        printf("PASSED");
+    }
+    DELAY(A_BIT);
+    printf("PWM Frequency: %d\r\n\r\n", PWM_GetFrequency());
+    /***************************************************************************
+     *            TEST PWM_ADDPIN()                                             *
+     ***************************************************************************/
+    printf("\n\nTesting PWM_AddPins() functionality");
+    printf("\nTesting: PWM_AddPins(0x000) out of bounds: ");
+    if (PWM_AddPins(0x000) == SUCCESS) {
+        printf("FAILED TEST");
+    } else {
+        printf("PASSED");
+    }
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_AddPins(0xFFF), out of bounds: ");
+    if (PWM_AddPins(0xFFF) == SUCCESS) {
+        printf("FAILED TEST");
+    } else {
+        printf("PASSED");
+    }
+
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_AddPins() for each pin: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_AddPins(i) == SUCCESS) {
+
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_AddPins(0x%03x) returned ERROR: TEST FAILED", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_AddPins() for each pin already enabled: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_AddPins(i) == ERROR) {
+            DELAY(A_BIT);
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_AddPins(0x%03x) returned SUCCESS with pin "
+                    "already enabled: TEST FAILED", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+    printf("\nTesting PWM_ListPins() with all pins enabled: ");
+    if (PWM_ListPins() == ALLPWMPINS) {
+        printf("PASSED");
+    } else {
+        printf("FAILED");
+        printf("\nPWM_ListPins() = 0x%03x, FAILED TEST", PWM_ListPins());
+    }
+    PWM_RemovePins(PWM_ListPins()); // get rid of all pins
+
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_AddPins() for two pins simultaneously: ");
+    testPassed = TRUE;
+    for (j = 1; j <= ALLPWMPINS; j <<= 1) {
+        for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+            if (PWM_AddPins(i | j) == SUCCESS) {
+            } else {
+                testPassed = FALSE;
+                printf("\nPWM_AddPins(0x%03x) returned ERROR: TEST FAILED", i | j);
+            }
+            PWM_RemovePins(i | j); // remove currently enabled pins
+
+        }
+    }
+    if (testPassed) printf("PASSED");
+    printf("\nPWM_AddPins() Tests complete.");
+
+
+    /***************************************************************************
+     *            TEST PWM_REMOVEPIN()                                          *
+     ***************************************************************************/
+    PWM_AddPins(ALLPWMPINS); // enable all pins for remove pin test
+
+    printf("\n\nTesting PWM_RemovePins() functionality");
+    printf("\nTesting: PWM_RemovePins(0x000) out of bounds: ");
+    if (PWM_RemovePins(0x000) == SUCCESS) {
+        printf("FAILED TEST");
+    } else {
+        printf("PASSED");
+    }
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_RemovePins(0xFFF), out of bounds: ");
+    if (PWM_RemovePins(0xFFF) == SUCCESS) {
+        printf("FAILED TEST");
+    } else {
+        printf("PASSED");
+    }
+
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_RemovePins() for each pin: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_RemovePins(i) == SUCCESS) {
+
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_RemovePins(0x%03x) returned ERROR: TEST FAILED", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_RemovePins() for each pin already disabled: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_RemovePins(i) == ERROR) {
+            DELAY(A_BIT);
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_RemovePins(0x%03x) returned SUCCESS with pin "
+                    "already disabled: TEST FAILED", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+    printf("\nTesting: PWM_ListPins() with all pins disabled: ");
+    if (PWM_ListPins() == 0x000) {
+        printf("PASSED");
+    } else {
+        printf("FAILED");
+        printf("\nPWM_ListPins() = 0x%03x, FAILED TEST", PWM_ListPins());
+    }
+    printf("\nPWM_RemovePins() Tests complete.");
+
+    /***************************************************************************
+     *            TEST PWM_LISTPINS()                                            *
+     ***************************************************************************/
+    printf("\n\nTesting PWM_ListPins() functionality");
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_ListPins() for each individual pin: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        PWM_AddPins(i);
+
+        if (PWM_ListPins() != i) {
+            testPassed = FALSE;
+            printf("\nPWM_ListPins() = 0x%03x does not "
+                    "match [0x%03x]: TEST FAILED", PWM_ListPins(), i);
+        }
+        PWM_RemovePins(i);
+
+    }
+    if (testPassed) printf("PASSED");
+    // now do it with all pins active
+    printf("\nTesting: PWM_ListPins() for aggregate pins: ");
+    testPassed = TRUE;
+    PWM_RemovePins(PWM_ListPins()); // get rid of all pins
+
+    for (i = 1; i <= ALLPWMPINS; i = (i << 1) + 1) {
+        PWM_AddPins(i);
+
+        if (PWM_ListPins() != i) {
+            testPassed = FALSE;
+            printf("\nPWM_ListPins() = 0x%03x does not "
+                    "match [0x%03x]: TEST FAILED", PWM_ListPins(), i);
+        }
+        PWM_RemovePins(i);
+
+    }
+    if (testPassed) printf("PASSED");
+    // now test for all enabled but one
+    printf("\nTesting: PWM_ListPins() for all pins except one: ");
+    testPassed = TRUE;
+    PWM_RemovePins(PWM_ListPins()); // get rid of all pins
+
+    PWM_AddPins(ALLPWMPINS);
+
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_RemovePins(i) == SUCCESS) {
+
+            if (PWM_ListPins() != (ALLPWMPINS & (~i))) {
+                testPassed = FALSE;
+                printf("\nPWM_ListPins() = 0x%03x does not "
+                        "match [0x%03x]: TEST FAILED", PWM_ListPins(), (ALLPWMPINS & (~i)));
+            }
+            PWM_AddPins(i);
+
+        }
+    }
+    if (testPassed) printf("PASSED");
+    PWM_End();
+    DELAY(A_LOT);
+
+    printf("\nPWM_ListPins() Tests complete.");
+
+    /***************************************************************************
+     *            TEST PWM_SETPULSE()                                            *
+     ***************************************************************************/
+    PWM_Init();
+    printf("\n\nTesting PWM_SetDutyCycle() functionality");
+    printf("\nALL pinse set to SERVOCENTER, all attached servos should center");
+    PWM_AddPins(ALLPWMPINS);
+
+    if (PWM_ListPins() != ALLPWMPINS) {
+        printf("ERROR, pins not enabled");
+    }
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        PWM_SetDutyCycle(i, FIFTY_PERCENT_DUTY);
+    }
+    printf("\n ");
+    for (k = 0; k < NUM2SWEEP; k++) {
+        DELAY(A_LOT);
+        printf(". ");
+    }
+
+    printf("\nSweeping pulse on ALL pins from MIN_PWM to MAX_PWM (%d times)", NUM2SWEEP);
+    printf("\nAny servos attached to pins should move from FULL CCW to FULL CW and back");
+    printf("\nOn cycle: ");
+    for (k = 0; k < NUM2SWEEP; k++) {
+        printf("%d ", k);
+        for (duty = MIN_PWM; duty < MAX_PWM; duty += INC) {
+            for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+                PWM_SetDutyCycle(i, duty);
+            }
+            DELAY(A_LOT);
+        }
+        for (duty = MIN_PWM; duty >= MAX_PWM; duty -= INC) {
+            for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+                PWM_SetDutyCycle(i, duty);
+            }
+            DELAY(A_LOT);
+        }
+    }
+    printf("\n\nSweeping pulse on EACH pin from MIN_PWM to MAX_PWM (%d times)", NUM2SPIN);
+    printf("\nAll servos attached should remain centered, each servo "
+            "will turn from FULL CCW to FULL CW in turn");
+    printf("\nOn Servo: ");
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        PWM_SetDutyCycle(i, FIFTY_PERCENT_DUTY);
+    }
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        printf("[0x%03x] ", i);
+        for (k = 0; k < NUM2SPIN; k++) {
+            for (duty = MIN_PWM; duty <= MAX_PWM; duty += INC) {
+                PWM_SetDutyCycle(i, duty);
+                DELAY(A_LOT);
+            }
+            for (duty = MAX_PWM; duty <= MIN_PWM; duty -= INC) {
+                PWM_SetDutyCycle(i, duty);
+                DELAY(A_LOT);
+            }
+        }
+        PWM_SetDutyCycle(i, FIFTY_PERCENT_DUTY);
+    }
+    printf("\nPWM_SetDutyCycle Tests complete");
+
+
+    /***************************************************************************
+     *            TEST PWM_GETPULSE()                                            *
+     ***************************************************************************/
+    printf("\n\nTesting PWM_GetPulseTime() functionality");
+    printf("\nTesting: PWM_GetPulseTime() for each pin set to SERVOCENTER: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        PWM_SetDutyCycle(i, FIFTY_PERCENT_DUTY);
+        if (PWM_GetDutyCycle(i) != FIFTY_PERCENT_DUTY) {
+            printf("\nPWM_GetPulseTime(0x%03X) FAILED: returned %d "
+                    "instead of %d", i, PWM_GetDutyCycle(i), FIFTY_PERCENT_DUTY);
+            while (!IsTransmitEmpty());
+            testPassed = FALSE;
+        }
+    }
+    if (testPassed) printf("PASSED");
+
+    printf("\nTesting: PWM_GetPulseTime() for each pin set to MIN_PWM: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        PWM_SetDutyCycle(i, MIN_PWM);
+        if (PWM_GetDutyCycle(i) != MIN_PWM) {
+            printf("\nPWM_GetPulseTime(0x%03X) FAILED: returned %d "
+                    "instead of %d", i, PWM_GetDutyCycle(i), MIN_PWM);
+            testPassed = FALSE;
+        }
+    }
+    if (testPassed) printf("PASSED");
+    while (!IsTransmitEmpty());
+    printf("\nTesting: PWM_GetPulseTime() for each pin set to MAX_PWM: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        PWM_SetDutyCycle(i, MAX_PWM);
+        if (PWM_GetDutyCycle(i) != MAX_PWM) {
+            printf("\nPWM_GetPulseTime(0x%03X) FAILED: returned %d "
+                    "instead of %d", i, PWM_GetDutyCycle(i), MAX_PWM);
+
+            testPassed = FALSE;
+        }
+    }
+    if (testPassed) printf("PASSED");
+    while (!IsTransmitEmpty());
+    printf("\nTesting: PWM_GetDutyCycle() for each pin variable value: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        for (duty = MIN_PWM; duty < MAX_PWM; duty += INC) {
+            PWM_SetDutyCycle(i, duty);
+            if (PWM_GetDutyCycle(i) != duty) {
+                printf("\nPWM_GetPulseTime(0x%03X) FAILED: returned %d "
+                        "instead of %d", i, PWM_GetDutyCycle(i), duty);
+                testPassed = FALSE;
+            }
+        }
+    }
+    if (testPassed) printf("PASSED");
+    printf("\nPWM_GetPulseTime() Tests complete");
+
+
+
+    /***************************************************************************
+     *            TEST PWM_END()                                                *
+     ***************************************************************************/
+    printf("\nTesting: PWM_End() while enabled: ");
+    if (PWM_End() == SUCCESS) {
+        printf("PASSED");
+        printf("\nAll enabled pins should be high impedance (inputs)");
+    } else {
+        printf("FAILED TEST");
+    }
+    printf("\nPWM_End() Testing complete.");
+    printf("\n\nPWM MODULE Testing complete.");
+
+    while (1) {
+        ;
+    }
+}
+#endif
+
+// #ifdef PWM_TEST
+
+// #include <serial.h>
+// #include <BOARD.h>
+
+// #define MIN_RAMP 0
+// #define MAX_RAMP 1000
+// #define FIRST_PERIOD PWM_20KHZ
+// #define SECOND_PERIOD PWM_500HZ
+// #define DELAY() for(i=0;i < NOPCOUNT; i++) __asm("nop")
+// #define NOPCOUNT 520000
+
+// int main(void) {
+// unsigned int i, j;
+// BOARD_Init();
+// printf("Uno PWM Test Harness\r\n");
+// PWM_Init();
+// PWM_AddPins(PWM_PORTX11 | PWM_PORTY04 | PWM_PORTY10 | PWM_PORTY12 | PWM_PORTZ06);
+// PWM_SetFrequency(FIRST_PERIOD);
+
+
+// printf("Ramping PWM from %d-%d%% in 10%% steps at %d with a delay between\r\n", MIN_RAMP, MAX_RAMP, FIRST_PERIOD);
+// unsigned char ch = 0;
+// for (j = MIN_RAMP; j <= MAX_RAMP; j += 100) {
+// PWM_SetDutyCycle(PWM_PORTX11, j);
+// PWM_SetDutyCycle(PWM_PORTY04, j + 20);
+// PWM_SetDutyCycle(PWM_PORTY10, j + 40);
+// PWM_SetDutyCycle(PWM_PORTY12, j + 60);
+// PWM_SetDutyCycle(PWM_PORTZ06, j + 80);
+// printf("Outputting %d%% Duty Cycle\r\n", j / 10);
+// DELAY();
+// }
+// printf("Setting Period to %d and repeating ramp\r\n", SECOND_PERIOD);
+// PWM_End();
+// PWM_Init();
+// PWM_AddPins(PWM_PORTX11 | PWM_PORTY04 | PWM_PORTY10 | PWM_PORTY12 | PWM_PORTZ06);
+// PWM_SetFrequency(FIRST_PERIOD);
+// for (j = MIN_RAMP; j <= MAX_RAMP; j += 100) {
+// PWM_SetDutyCycle(PWM_PORTX11, j);
+// PWM_SetDutyCycle(PWM_PORTY04, j + 20);
+// PWM_SetDutyCycle(PWM_PORTY10, j + 40);
+// PWM_SetDutyCycle(PWM_PORTY12, j + 60);
+// PWM_SetDutyCycle(PWM_PORTZ06, j + 80);
+// printf("Outputting %d%% Duty Cycle\r\n", j / 10);
+// DELAY();
+// }
+// PWM_End();
+// return 0;
+// while (1);
+// }
+
+// #endif
\ No newline at end of file
diff --git a/Common/pwm.h b/Common/pwm.h
new file mode 100644
index 0000000..107ee90
--- /dev/null
+++ b/Common/pwm.h
@@ -0,0 +1,133 @@
+/*
+ * File:   pwm.h
+ * Author: mdunne
+ *
+ * Software module to run the PWM module of the Uno32. The available pins for
+ * which the PWM works are #defined below (PortZ-6, PortY-4,10,12, and PortX-11),
+ * and are set by the hardware (cannot be modified).
+ *
+ * NOTE: Module uses TIMER2 for its interrupts.
+ *
+ * PWM_TEST (in the .c file) conditionally compiles the test harness for the code. 
+ * 
+ *
+ * Created on November 12, 2011, 9:27 AM
+ */
+
+#ifndef pwm_H
+#define pwm_H
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+#define MIN_PWM_FREQ 100
+#define PWM_500HZ 500
+#define PWM_1KHZ 1000
+#define PWM_2KHZ 2000
+#define PWM_5KHZ 5000
+#define PWM_10KHZ 10000
+#define PWM_20KHZ 20000
+#define PWM_30KHZ 30000
+#define PWM_40KHZ 40000
+#define MAX_PWM_FREQ 100000
+#define PWM_DEFAULT_FREQUENCY PWM_1KHZ
+
+#define PWM_PORTZ06 (1<<0)
+#define PWM_PORTY12 (1<<1)
+#define PWM_PORTY10 (1<<2)
+#define PWM_PORTY04 (1<<3)
+#define PWM_PORTX11 (1<<4)
+
+#define MIN_PWM 0
+#define MAX_PWM 1000
+
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @Function PWM_Init(void)
+ * @param None
+ * @return SUCCESS or ERROR
+ * @brief  Initializes the timer for the PWM system and set is to the default frequency
+ * @note  None.
+ * @author Max Dunne, 2013.08.25 */
+char PWM_Init(void);
+
+/**
+ * @Function PWM_SetFrequency(unsigned int NewFrequency)
+ * @param NewFrequency - new frequency to set. best to use #defined from header
+ * @return SUCCESS OR ERROR
+ * @brief  Changes the frequency of the PWM system.
+ * @note  Behavior of PWM channels during Frequency change is undocumented
+ * @author Max Dunne, 2013.08.19 */
+char PWM_SetFrequency(unsigned int NewFrequency);
+
+/**
+ * @Function PWM_GetFrequency(void)
+ * @return Frequency of system in Hertz
+ * @brief  gets the frequency of the PWM system.
+ * @author Max Dunne, 2013.08.19 */
+unsigned int PWM_GetFrequency(void);
+
+/**
+ * @Function PWM_AddPins(unsigned short int AddPins)
+ * @param AddPins - use #defined PWM_PORTxxx OR'd together for each A/D Pin you wish to add
+ * @return SUCCESS OR ERROR
+ * @brief  Adds new pins to the PWM system.  If any pin is already active it errors
+ * out
+ * @author Max Dunne, 2013.08.15 */
+char PWM_AddPins(unsigned short int PWMpins);
+
+/**
+ * @Function PWM_RemovePins(unsigned int PWMPins)
+ * @param RemovePins - use #defined AD_PORTxxx OR'd together for each A/D Pin you wish to remove
+ * @return SUCCESS OR ERROR
+ * @brief  Remove pins from the PWM system.  If any pin is not active it errors out
+ * @author Max Dunne, 2013.08.15 */
+char PWM_RemovePins(unsigned int PWMPins);
+
+/**
+ * @Function PWM_ListPins(void)
+ * @param None
+ * @return Listing of all PWM pins that are active.
+ * @brief  Returns a variable of all active pwm pins. An individual pin can be determined
+ * if active by "anding" with the pwm_PORTXX Macros
+ * @author Max Dunne, 2013.08.19 */
+unsigned int PWM_ListPins(void);
+
+/**
+ * Function  PWM_SetDutyCycle
+ * @param Channels, use #defined PWM_PORTxxx
+ * @param Duty, duty cycle for the channel (0-1000)
+ * @return SUCCESS or ERROR
+ * @remark Sets the Duty Cycle for a Single Channel and returns error if that channel is not enabled
+ * @author Max Dunne
+ * @date 2011.11.12  */
+char PWM_SetDutyCycle(unsigned char Channel, unsigned int Duty);
+
+/**
+ * Function  PWM_GetDutyCycle
+ * @param Channels, use #defined PWM_PORTxxx
+ * 
+ * @return Duty cycle
+ * @remark Gets the Duty Cycle for a Single Channel and returns error if that channel is not enabled
+ * @author Max Dunne
+ * @date 2011.11.12  */
+unsigned int PWM_GetDutyCycle(char Channel);
+
+/**
+ * Function: PWM_End
+ * @param None
+ * @return SUCCESS or ERROR
+ * @remark Disables the PWM sub-system and releases all pins.
+ * @author Max Dunne
+ * @date 2011.11.12  */
+char PWM_End(void);
+
+
+
+
+#endif
diff --git a/Common/serial.c b/Common/serial.c
new file mode 100644
index 0000000..ef5e909
--- /dev/null
+++ b/Common/serial.c
@@ -0,0 +1,479 @@
+
+/*
+ * File:   uart.c
+ * Author: mdunne
+ *
+ * Created on November 10, 2011, 8:42 AM
+ */
+
+#include <xc.h>
+#include <serial.h>
+#include <sys/attribs.h>
+#include <BOARD.h>
+#include <stdint.h>
+//#include <stdlib.h>
+
+
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+#define F_PB (BOARD_GetPBClock())
+#define QUEUESIZE 512
+
+/*******************************************************************************
+ * PRIVATE DATATYPES                                                           *
+ ******************************************************************************/
+typedef struct CircBuffer {
+    unsigned char buffer[QUEUESIZE];
+    int head;
+    int tail;
+    unsigned int size;
+    unsigned char overflowCount;
+} CircBuffer;
+typedef struct CircBuffer* CBRef;
+
+
+/*******************************************************************************
+ * PRIVATE FUNCTIONS PROTOTYPES                                                *
+ ******************************************************************************/
+void newCircBuffer(CBRef cB);
+void freeCircBuffer(CBRef* cB);
+unsigned int getLength(CBRef cB);
+int readHead(CBRef cB);
+int readTail(CBRef cB);
+unsigned char peak(CBRef cB);
+unsigned char readFront(CBRef cB);
+unsigned char writeBack(CBRef cB, unsigned char data);
+
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                           *
+ ******************************************************************************/
+struct CircBuffer outgoingUart;
+CBRef transmitBuffer;
+struct CircBuffer incomingUart;
+CBRef receiveBuffer;
+static uint8_t AddingToTransmit = FALSE;
+static uint8_t GettingFromReceive = FALSE;
+static uint8_t TransmitCollisionOccured = FALSE;
+static uint8_t ReceiveCollisionOccured = FALSE;
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @Function SERIAL_Init(void)
+ * @param none
+ * @return none
+ * @brief  Initializes the UART subsystem to 115200 and sets up the circular buffer
+ * @author Max Dunne, 2011.11.10 */
+
+void SERIAL_Init(void)
+{
+    transmitBuffer = (struct CircBuffer*) &outgoingUart; //set up buffer for receive
+    newCircBuffer(transmitBuffer);
+
+    receiveBuffer = (struct CircBuffer*) &incomingUart; //set up buffer for transmit
+    newCircBuffer(receiveBuffer);
+
+    U1MODE = 0;
+    U1STA = 0;
+
+    // calculate BRG value
+    unsigned int brgValue = F_PB;
+    brgValue >>= 3;
+    brgValue /= 115200;
+    brgValue++;
+    brgValue >>= 1;
+    brgValue--;
+    U1BRG = brgValue; // set the baud rate to 115200
+    // have interrupts occur whenever RX is not empty
+    U1STAbits.URXISEL = 0;
+
+    IPC6bits.U1IP = 4; //set the interrupt priority
+
+    // we now enable the module and both RX and TX
+    U1MODEbits.ON = 1; // turn on uart itself
+    U1STAbits.UTXEN = 1; // turn on TX
+    U1STAbits.URXEN = 1; // turn on RX
+    // enable the interrupts
+    IEC0bits.U1RXIE = 1;
+    IEC0bits.U1TXIE = 1;
+}
+
+/**
+ * @Function PutChar(char ch)
+ * @param ch - the char to be sent out the serial port
+ * @return None.
+ * @brief  adds char to the end of the circular buffer and forces the interrupt flag 
+ * high if nothing is currently transmitting
+ * @author Max Dunne, 2011.11.10 */
+void PutChar(char ch)
+{
+    if (getLength(transmitBuffer) != QUEUESIZE) {
+        AddingToTransmit = TRUE;
+        writeBack(transmitBuffer, ch);
+        AddingToTransmit = FALSE;
+        if (U1STAbits.TRMT) {
+            IFS0bits.U1TXIF = 1;
+        }
+        //re-enter the interrupt if we removed a character while getting another one
+        if (TransmitCollisionOccured) {
+            IFS0bits.U1TXIF = 1;
+            TransmitCollisionOccured = FALSE;
+        }
+    }
+}
+
+/**
+ * @Function GetChar(void)
+ * @param None.
+ * @return ch - char from the serial port
+ * @brief  reads first character from buffer or returns 0 if no chars available
+ * @author Max Dunne, 2011.11.10 */
+char GetChar(void)
+{
+    char ch;
+    if (getLength(receiveBuffer) == 0) {
+        ch = 0;
+    } else {
+        GettingFromReceive = TRUE;
+        ch = readFront(receiveBuffer);
+        GettingFromReceive = FALSE;
+    }
+    //re-enter the interrupt if we added a character while transmitting another one
+    if (ReceiveCollisionOccured) {
+        IFS0bits.U1RXIF = 1;
+        ReceiveCollisionOccured = FALSE;
+    }
+    return ch;
+}
+
+/**
+ * @Function _mon_putc(char c)
+ * @param c - char to be sent
+ * @return None.
+ * @brief  overwrites weakly define extern to use circular buffer instead of Microchip 
+ * functions
+ * @author Max Dunne, 2011.11.10 */
+void _mon_putc(char c)
+{
+    PutChar(c);
+}
+
+/**
+ * @Function _mon_puts(const char* s)
+ * @param s - pointer to the string to be sent
+ * @return None.
+ * @brief  overwrites weakly defined extern to use circular buffer instead of Microchip 
+ * functions
+ * @author Max Dunne, 2011.11.10 */
+void _mon_puts(const char* s)
+{
+    int i;
+    for (i = 0; i<sizeof (s); i++)
+        PutChar(s[i]);
+}
+
+/**
+ * @Function _mon_getc(int CanBlock)
+ * @param CanBlock - unused variable but required to match Microchip form
+ * @return None.
+ * @brief  overwrites weakly defined extern to use circular buffer instead of Microchip 
+ * functions
+ * @author Max Dunne, 2011.11.10 */
+int _mon_getc(int CanBlock)
+{
+    if (getLength(receiveBuffer) == 0)
+        return -1;
+    return GetChar();
+}
+
+/**
+ * @Function IsReceiveEmpty(void)
+ * @param None.
+ * @return TRUE or FALSE
+ * @brief  returns the state of the receive buffer
+ * @author Max Dunne, 2011.12.15 */
+char IsReceiveEmpty(void)
+{
+    if (getLength(receiveBuffer) == 0)
+        return TRUE;
+    return FALSE;
+}
+
+/**
+ * @Function IsTransmitEmpty(void)
+ * @param None.
+ * @return TRUE or FALSE
+ * @brief  returns the state of the receive buffer
+ * @author Max Dunne, 2011.12.15 */
+char IsTransmitEmpty(void)
+{
+    if (getLength(transmitBuffer) == 0)
+        return TRUE;
+    return FALSE;
+}
+
+/****************************************************************************
+ Function
+    IntUart1Handler
+
+ Parameters
+    None.
+
+ Returns
+    None.
+
+ Description
+    Interrupt Handle for the uart. with the PIC32 architecture both send and receive are handled within the same interrupt
+
+ Notes
+
+
+ Author
+ Max Dunne, 2011.11.10
+ ****************************************************************************/
+void __ISR(_UART1_VECTOR) IntUart1Handler(void)
+{
+    if (IFS0bits.U1RXIF) {
+        IFS0bits.U1RXIF = 0;
+        if (!GettingFromReceive) {
+            writeBack(receiveBuffer, (unsigned char) U1RXREG);
+        } else {
+            //acknowledge we have a collision and return
+            ReceiveCollisionOccured = TRUE;
+        }
+    }
+    if (IFS0bits.U1TXIF) {
+        IFS0bits.U1TXIF = 0;
+        if (!(getLength(transmitBuffer) == 0)) {
+            if (!AddingToTransmit) {
+                U1TXREG = readFront(transmitBuffer);
+            } else {
+                //acknowledge we have a collision and return
+                TransmitCollisionOccured = TRUE;
+            }
+        }
+    }
+
+}
+
+/*******************************************************************************
+ * PRIVATE FUNCTIONS                                                          *
+ ******************************************************************************/
+
+void newCircBuffer(CBRef cB)
+{
+
+    // initialize to zero
+    int i;
+    for (i = 0; i < QUEUESIZE; i++) {
+        cB->buffer[i] = 0;
+    }
+
+    // initialize the data members
+    cB->head = 0;
+    cB->tail = 0;
+    cB->size = QUEUESIZE;
+    cB->overflowCount = 0;
+
+}
+
+// this function frees the Circular Buffer CB Ref
+
+void freeCircBuffer(CBRef* cB)
+{
+    // if it is already null, nothing to free
+    if (cB == NULL || *cB == NULL) {
+        return;
+    }
+
+    // free and nil the pointer
+    //free(*cB);
+    *cB = NULL;
+}
+
+
+
+
+// Accesor Methods
+// ===============
+
+// returns the amount of unread bytes in the circular buffer
+
+unsigned int getLength(CBRef cB)
+{
+    // if the circular buffer is not null
+    if (cB != NULL) {
+        if (cB->head <= cB->tail) {
+            return (cB->tail - cB->head);
+        } else {
+            return (cB->size + cB->tail - cB->head);
+        }
+    } else {
+        return 0;
+    }
+
+
+}
+
+// returns the actual index of the head
+
+int readHead(CBRef cB)
+{
+    // if the circular buffer is not null
+    if (cB != NULL) {
+        return (cB->head);
+    } else {
+        return 0;
+    }
+
+}
+
+// returns the actual index of the tail
+
+int readTail(CBRef cB)
+{
+    // if the circular buffer is not null
+    if (cB != NULL) {
+        return (cB->tail);
+    } else {
+        return 0;
+    }
+
+}
+
+// returns the byte (actual value) that the head points to. this
+// does not mark the byte as read, so succesive calls to peak will
+// always return the same value
+
+unsigned char peak(CBRef cB)
+{
+    // if the circular buffer is not null
+    if (cB != NULL) {
+        // if there are bytes in the buffer
+        if (getLength(cB) > 0) {
+            return cB->buffer[cB->head];
+        }
+    }
+    return 0;
+}
+
+
+// Manipulation Procedures
+// ======================
+// returns the front of the circular buffer and marks the byte as read
+
+unsigned char readFront(CBRef cB)
+{
+    // if the circular buffer is not null
+    if (cB != NULL) {
+        char retVal;
+        // if there are bytes in the buffer
+        if (getLength(cB) > 0) {
+            retVal = cB->buffer[cB->head];
+            cB->head = cB->head < (cB->size - 1) ? cB->head + 1 : 0;
+            return retVal;
+        }
+        return 128;
+    }
+    return 254;
+}
+
+// writes one byte at the end of the circular buffer,
+// increments overflow count if overflow occurs
+
+unsigned char writeBack(CBRef cB, unsigned char data)
+{
+    // if the circular buffer is not null
+    if (cB != NULL) {
+        if (getLength(cB) == (cB->size - 1)) {
+            cB->overflowCount++;
+            //return 1;
+        } else {
+            cB->buffer[cB->tail] = data;
+            cB->tail = cB->tail < (cB->size - 1) ? cB->tail + 1 : 0;
+            //return 0;
+        }
+        //return 0;
+    } else {
+        return 1;
+    }
+    return 0;
+}
+
+// empties the circular buffer. It does not change the size. use with caution!!
+
+void makeEmpty(CBRef cB)
+{
+    if (cB != NULL) {
+        int i;
+        for (i = 0; i < cB->size; ++i) {
+            cB->buffer[i] = 0;
+        }
+        cB->head = 0;
+        cB->tail = 0;
+        cB->overflowCount = 0;
+    }
+}
+
+// returns the amount of times the CB has overflown;
+
+unsigned char getOverflow(CBRef cB)
+{
+    if (cB != NULL) {
+        return cB->overflowCount;
+    }
+    return 0;
+}
+
+
+
+//#define SERIAL_TEST
+#ifdef SERIAL_TEST
+#include "serial.h"
+#include "BOARD.h"
+#include <GenericTypeDefs.h>
+#include <stdio.h>
+
+//#include <plib.h>
+#define MAX_RAND (1<<10)
+//#define INUNDATION_TEST
+
+int main(void)
+{
+    BOARD_Init();
+    unsigned int i;
+    printf("\r\nUno Serial Test Harness\r\nAfter this Message the terminal should mirror any single character you type.\r\n");
+    // while(!IsTransmitEmpty());
+    unsigned int NopCount = 0;
+    unsigned char CharCount = 0;
+#ifdef INUNDATION_TEST
+    while (1) {
+        NopCount = rand() % MAX_RAND + 1;
+        //printf("%X\r\n",rand());
+        for (i = 0; i < NopCount; i++) {
+            asm("Nop");
+        }
+        for (CharCount = 32; CharCount < 128; CharCount++) {
+            //printf("%c", CharCount);
+            putchar(CharCount);
+        }
+
+    }
+#endif
+    GetChar();
+    //    unsigned char ch = 0;
+    while (1) {
+        if (IsTransmitEmpty() == TRUE)
+            if (IsReceiveEmpty() == FALSE)
+                PutChar(GetChar());
+    }
+
+    return 0;
+}
+
+#endif
\ No newline at end of file
diff --git a/Common/serial.h b/Common/serial.h
new file mode 100644
index 0000000..a5f0e27
--- /dev/null
+++ b/Common/serial.h
@@ -0,0 +1,63 @@
+/*
+   File:   serial.h
+   Author: mdunne
+
+   Created on November 10, 2011, 8:43 AM
+ */
+
+#ifndef SERIAL_H
+#define SERIAL_H
+
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+
+/**
+ * @Function SERIAL_Init(void)
+ * @param none
+ * @return none
+ * @brief  Initializes the UART subsystem to 115200 and sets up the circular buffer
+ * @author Max Dunne, 2011.11.10 */
+void SERIAL_Init(void);
+
+/**
+ * @Function PutChar(char ch)
+ * @param ch - the char to be sent out the serial port
+ * @return None.
+ * @brief  adds char to the end of the circular buffer and forces the interrupt flag
+ * high if nothing is currently transmitting
+ * @author Max Dunne, 2011.11.10 */
+void PutChar(char ch);
+
+/**
+ * @Function GetChar(void)
+ * @param None.
+ * @return ch - char from the serial port
+ * @brief  reads first character from buffer or returns 0 if no chars available
+ * @author Max Dunne, 2011.11.10 */
+char GetChar(void);
+
+/**
+ * @Function IsTransmitEmpty(void)
+ * @param None.
+ * @return TRUE or FALSE
+ * @brief  returns the state of the receive buffer
+ * @author Max Dunne, 2011.12.15 */
+char IsTransmitEmpty(void);
+
+/**
+ * @Function IsReceiveEmpty(void)
+ * @param None.
+ * @return TRUE or FALSE
+ * @brief  returns the state of the receive buffer
+ * @author Max Dunne, 2011.12.15 */
+char IsReceiveEmpty(void);
+
+#endif // serial_h
diff --git a/Common/timers.c b/Common/timers.c
new file mode 100644
index 0000000..b104b27
--- /dev/null
+++ b/Common/timers.c
@@ -0,0 +1,129 @@
+/*
+ * File:   timers.c
+ * Author: mdunne
+ *
+ * Created on November 15, 2011, 9:53 AM
+ */
+
+#include <xc.h>
+#include <BOARD.h>
+#include "timers.h"
+#include <sys/attribs.h>
+
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+//#define TIMERS_TEST
+
+#define F_PB (BOARD_GetPBClock())
+#define TIMER_FREQUENCY 1000
+
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                           *
+ ******************************************************************************/
+
+static unsigned int milliSecondCount;
+static unsigned int microSecondCount;
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @Function TIMERS_Init(void)
+ * @param none
+ * @return None.
+ * @brief  Initializes the timer module
+ * @author Max Dunne */
+void TIMERS_Init(void)
+{
+    T5CON = 0;
+    T5CONbits.TCKPS = 0b01;
+    PR5 = (F_PB / TIMER_FREQUENCY) >> 1;
+    T5CONbits.ON = 1;
+    IFS0bits.T5IF = 0;
+    IPC5bits.T5IP = 3;
+    IEC0bits.T5IE = 1;
+}
+
+/**
+ * Function: TIMERS_GetMilliSeconds
+ * @param None
+ * @return the current MilliSecond Count
+ * @author Max Dunne
+ */
+unsigned int TIMERS_GetMilliSeconds(void)
+{
+    return milliSecondCount;
+}
+
+/**
+ * Function: TIMERS_GetMicroSeconds
+ * @param None
+ * @return the current MicroSecond Count, it will roll over in 1.9 hours
+ * @author Max Dunne
+ */
+
+unsigned int TIMERS_GetMicroSeconds(void)
+{
+    return (microSecondCount + TMR5 / 20);
+}
+
+/**
+ * @Function Timer5IntHandler(void)
+ * @param None.
+ * @return None.
+ * @brief  This is the interrupt handler to support the timer module. It will increment 
+ * time
+ * @author Max Dunne */
+
+void __ISR(_TIMER_5_VECTOR) Timer5IntHandler(void)
+{
+    IFS0bits.T5IF = 0;
+    milliSecondCount++;
+    microSecondCount += 1000;
+}
+
+
+
+
+#ifdef TIMERS_TEST
+#include "serial.h"
+#include "timers.h"
+#include <stdio.h>
+
+int main(void)
+{
+    int i = 0;
+    BOARD_Init();
+    int curMilliSeconds;
+    int curMicroSeconds;
+    printf("Welcome to The Timers Test, Module will Init and then print times, get a stopwatch and compare\r\n");
+    while (!IsTransmitEmpty());
+
+    TIMERS_Init();
+    unsigned int tick = 0;
+    //    while (1) {
+    //        if (IsTransmitEmpty()) {
+    //            printf("%d\r\n",TIMERS_GetMilliSeconds());
+    //        }
+    //    }
+    while (1) {
+        if (TIMERS_GetMilliSeconds() - tick >= 10) {
+            tick = TIMERS_GetMilliSeconds();
+            if (IsTransmitEmpty()) {
+                curMicroSeconds = TIMERS_GetMicroSeconds();
+                curMilliSeconds = TIMERS_GetMilliSeconds();
+                printf("ms: %d\tus: %d\tus/1000: %d\r\n",
+                        curMilliSeconds, curMicroSeconds, curMicroSeconds / 1000);
+            }
+        }
+    }
+
+
+
+    while (1);
+}
+
+#endif
\ No newline at end of file
diff --git a/Common/timers.h b/Common/timers.h
new file mode 100644
index 0000000..d518142
--- /dev/null
+++ b/Common/timers.h
@@ -0,0 +1,56 @@
+/*
+ * File:   timers.h
+ * Author: mdunne
+ *
+ * Software module to enable a bank of software timers with a resolution time of
+ * one msecond for each. The timers can be individually started, stopped, expired, etc.
+ *
+ * NOTE: Module uses TIMER5 for its interrupts.
+ *
+ * TIMERS_TEST (in the .c file) conditionally compiles the test harness for the code. 
+ * Make sure it is commented out for module useage.
+ *
+ * Created on November 15, 2011, 9:54 AM
+ */
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+#ifndef timers_H
+#define timers_H
+
+
+
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @Function TIMERS_Init(void)
+ * @param none
+ * @return None.
+ * @brief  Initializes the timer module
+ * @author Max Dunne, 2011.11.15 */
+void TIMERS_Init(void);
+
+/**
+ * Function: TIMERS_GetMilliSeconds
+ * @param None
+ * @return the current MilliSecond Count
+ * @author Max Dunne
+   */
+unsigned int TIMERS_GetMilliSeconds(void);
+
+/**
+ * Function: TIMERS_GetMicroSeconds
+ * @param None
+ * @return the current MicroSecond Count, it will roll over in 1.9 hours
+ * @author Max Dunne
+   */
+unsigned int TIMERS_GetMicroSeconds(void);
+
+
+
+#endif
diff --git a/matlab/Lab3/CalibrateEllipseData2D.m b/matlab/Lab3/CalibrateEllipseData2D.m
new file mode 100644
index 0000000..382d2cd
--- /dev/null
+++ b/matlab/Lab3/CalibrateEllipseData2D.m
@@ -0,0 +1,62 @@
+function [Atilde,Btilde] = CalibrateEllipseData2D(x,y,kstep,plotFlag)
+% function [Atilde,Btilde] = CalibrateEllipseData2D(x,y,kstep,plotFlag)
+%
+% Calibrates 2D elliptical data from sensors using the iterated least
+% squares matrix method outlines in "Iterative calibration method for 
+% inertial and magnetic sensors" by Eric Dorveaux
+%
+% Input data is the (noisy) x and y of the sensor.
+% k is the number of iterations for the process to take
+% plotFlag is 1 will show the points change as the iteration steps continue
+%
+Atilde = eye(2);
+Btilde = [0;0];
+
+xi = x;
+yi = y;
+
+M = zeros(length(xi)*2,6);
+Y = zeros(length(xi)*2,1);
+
+if plotFlag,
+    figure(1), clf
+    r = 1.0;
+    th = [0:2:360]';
+    plot(r*cos(th*pi/180),r*sin(th*pi/180),'k-',xi,yi,'.');
+    axis('equal');
+    hold on
+end
+
+% Iterate through estimation process
+% kstep should be somewhere between 2-20
+%
+for k = 1:kstep, 
+    for i = 1:length(xi)
+        M(i*2-1,:) = [xi(i) yi(i) 0 0 1 0];
+        M(i*2,:)   = [0 0 xi(i) yi(i) 0 1];
+        Y(i*2-1:i*2) = (1/sqrt(xi(i)^2+yi(i)^2))*[xi(i);yi(i)];
+    end
+    p = M\Y;    % do the least squares for A and B elements
+    Akplus = [p(1) p(2);p(3) p(4)];
+    Bkplus = [p(5); p(6)];
+    
+    xyplus = (Akplus*[xi';yi'])'; % update the xi,yi pairs
+    xi = xyplus(:,1)+Bkplus(1);
+    yi = xyplus(:,2)+Bkplus(2);
+    
+    Btilde = Akplus*Btilde + Bkplus;
+    Atilde = Akplus*Atilde;
+    
+    if plotFlag,
+        plot(xi,yi,'.');
+    end
+end
+
+if plotFlag,
+    figure(2), clf
+    plot([sqrt(x.^2+y.^2) sqrt(xi.^2+yi.^2)],'.');
+    legend('Pre-Calibration','Post-Calibration');
+    title('Norm of data pre- and post-Calibration');
+end
+
+
diff --git a/matlab/Lab3/CalibrateEllipsoidData3D.m b/matlab/Lab3/CalibrateEllipsoidData3D.m
new file mode 100644
index 0000000..4d09ecf
--- /dev/null
+++ b/matlab/Lab3/CalibrateEllipsoidData3D.m
@@ -0,0 +1,97 @@
+function [Atilde,Btilde] = CalibrateEllipsoidData3D(x,y,z,kstep,plotFlag)
+% function [Atilde,Btilde] = CalibrateEllipsoidData3D(x,y,z,kstep,plotFlag)
+%
+% Calibrates 3D elliptical data from sensors using the iterated least
+% squares matrix method outlines in "Iterative calibration method for 
+% inertial and magnetic sensors" by Eric Dorveaux
+%
+% Input data is the (noisy) x and y of the sensor.
+% k is the number of iterations for the process to take
+% plotFlag is 1 will show the points change as the iteration steps continue
+%
+Atilde = eye(3);
+Btilde = -[mean(x);mean(y);mean(z)];
+
+xi = x;
+yi = y;
+zi = z;
+
+xyzplus = (Atilde*[xi';yi';zi'])'; % update the xi,yi,zi tuples
+xi = xyzplus(:,1)+Btilde(1);
+yi = xyzplus(:,2)+Btilde(2);
+zi = xyzplus(:,3)+Btilde(3);
+
+
+
+M = zeros(length(xi)*3,12);
+Y = zeros(length(xi)*3,1);
+
+if plotFlag,
+    figure(1), clf
+    [xx,yy,zz] = sphere(30);
+    surf(xx,yy,zz,'FaceAlpha',0.1);
+    xlabel('x');
+    ylabel('y');
+    zlabel('z');
+    title('Visualization of Walk In for Each Step of Calibration')
+    axis('equal');
+    hold on
+    plot3(xi,yi,zi,'.');
+end
+
+Atracking = Atilde(:)';
+Btracking = Btilde(:)';
+
+% Iterate through estimation process
+% kstep should be somewhere between 2-20
+%
+for k = 1:kstep, 
+    for i = 1:length(xi)
+        M(i*3-2,:) = [xi(i) yi(i) zi(i) 0 0 0 0 0 0 1 0 0];
+        M(i*3-1,:) = [0 0 0 xi(i) yi(i) zi(i) 0 0 0 0 1 0];
+        M(i*3,:)   = [0 0 0 0 0 0 xi(i) yi(i) zi(i) 0 0 1];
+        Y(i*3-2:i*3) = (1/sqrt(xi(i)^2+yi(i)^2+zi(i)^2))*[xi(i);yi(i);zi(i)];
+    end
+
+    p = M\Y;    % do the least squares for A and B elements
+    Akplus = [p(1) p(2) p(3);p(4) p(5) p(6);p(7) p(8) p(9)];
+    Bkplus = [p(10); p(11); p(12)];
+    
+    xyzplus = (Akplus*[xi';yi';zi'])'; % update the xi,yi,zi tuples
+    xi = xyzplus(:,1)+Bkplus(1);
+    yi = xyzplus(:,2)+Bkplus(2);
+    zi = xyzplus(:,3)+Bkplus(3);
+    
+    Btilde = Akplus*Btilde + Bkplus;
+    Atilde = Akplus*Atilde;
+    
+    Atracking(k+1,:) = Atilde(:)';
+    Btracking(k+1,:) = Btilde(:)';
+    
+    if plotFlag,
+        plot3(xi,yi,zi,'.');
+    end
+end
+
+
+if plotFlag,
+    hold off
+    figure(2), clf
+    plot([sqrt(x.^2+y.^2+z.^2) sqrt(xi.^2+yi.^2+zi.^2)],'.');
+    legend('Pre-Calibration','Post-Calibration');
+    title('Norm of data pre- and post-Calibration');
+    
+    mmm = mean(sqrt(x.^2+y.^2+z.^2));
+    
+    figure(3), clf
+    plot([Atracking Btracking]/mmm)
+    xlabel('Step')
+    ylabel('Parameter Value')
+    title('Plot of Walk In of Parameters')
+    
+    figure(4), clf
+    histfit(sqrt(x.^2+y.^2+z.^2)), hold on
+    histfit(sqrt(xi.^2+yi.^2+zi.^2)), hold off
+end
+
+
diff --git a/matlab/Lab3/CorrectEllipseData2D.m b/matlab/Lab3/CorrectEllipseData2D.m
new file mode 100644
index 0000000..6222151
--- /dev/null
+++ b/matlab/Lab3/CorrectEllipseData2D.m
@@ -0,0 +1,17 @@
+function [Xcorr,Ycorr] = CorrectEllipseData2D(Xmeas,Ymeas,Atilde,Btilde)
+% function [Xcorr,Ycorr] = CorrectEllipseData2D(Xmeas,Ymeas,Atilde,Btilde)
+%
+% This function applies a correction to Ellipse 2D data given that you have
+% already calibrated the sensor/environment.
+%
+% Atilde and Btilde come from the CalibrateEllipseData2D function
+%
+Xcorr = [];
+Ycorr = [];
+
+for i = 1:length(Xmeas),
+    xy = Atilde*[Xmeas(i);Ymeas(i)] + Btilde;
+    Xcorr(i) = xy(1);
+    Ycorr(i) = xy(2);
+end
+
diff --git a/matlab/Lab3/CorrectEllipsoidData3D.m b/matlab/Lab3/CorrectEllipsoidData3D.m
new file mode 100644
index 0000000..7252a0f
--- /dev/null
+++ b/matlab/Lab3/CorrectEllipsoidData3D.m
@@ -0,0 +1,19 @@
+function [Xcorr,Ycorr,Zcorr] = CorrectEllipsoidData3D(Xmeas,Ymeas,Zmeas,Atilde,Btilde)
+% function [Xcorr,Ycorr,Zcorr] = CorrectEllipsoidData3D(Xmeas,Ymeas,Zmeas,Atilde,Btilde)
+%
+% This function applies a correction to Ellipse 3D data given that you have
+% already calibrated the sensor/environment.
+%
+% Atilde and Btilde come from the CalibrateEllipsoidData3D function
+%
+Xcorr = [];
+Ycorr = [];
+Zcorr = [];
+
+for i = 1:length(Xmeas),
+    xyz = Atilde*[Xmeas(i);Ymeas(i);Zmeas(i)] + Btilde;
+    Xcorr(i) = xyz(1);
+    Ycorr(i) = xyz(2);
+    Zcorr(i) = xyz(3);
+end
+
diff --git a/matlab/Lab3/CreateRandomAttitude.m b/matlab/Lab3/CreateRandomAttitude.m
new file mode 100644
index 0000000..82c9ec2
--- /dev/null
+++ b/matlab/Lab3/CreateRandomAttitude.m
@@ -0,0 +1,30 @@
+function R = CreateRandomAttitude()
+% function R = CreateRandomAttitude()
+% 
+% Function returns a randomly generated direction cosine matrix through the
+% use of a matrix exponential integration of a randomly generated rotation
+
+wdT = (rand(3,1)-0.5)*2*pi;
+R = Rexp(wdT);
+
+    function R_exp = Rexp(w)
+    % function R_exp = Rexp(w)
+    %
+    % returns the exponential Rodrigues parameter form of the integration that
+    % keeps R on SO(3). See Park and Chung paper.
+    %
+    wnorm = norm(w);
+    rx = rcross(w);
+    s = 2*sin(wnorm/2)/wnorm;
+    c = cos(wnorm/2);
+    R_exp = [1 0 0;0 1 0;0 0 1] + s*c*rx + s*s/2*rx*rx;
+    end
+
+    function rx = rcross(r)
+        % function rx = rcross(r)
+        % forms the skew symmetric x-product matrix of a 3x1 vector
+        rx=[0    -r(3)  r(2);
+            r(3)  0    -r(1);
+            -r(2)  r(1)  0];
+    end
+end
\ No newline at end of file
diff --git a/matlab/Lab3/CreateTumbleData.m b/matlab/Lab3/CreateTumbleData.m
new file mode 100644
index 0000000..74bba44
--- /dev/null
+++ b/matlab/Lab3/CreateTumbleData.m
@@ -0,0 +1,51 @@
+function [Anoise,Hnoise,Adist,Bdist] = CreateTumbleData(npts)
+% function [Anoise,Hnoise,Adist,Bdist] = CreateTumbleData(npts)
+% 
+% Function to create fake tumble data in the correct units so that students
+% can test their algorithms and confirm that everything is working
+%
+% This is based on the sensor output of 16-bits, where the sensors are set
+% to 2g for accel, and 16-bits on Mags. 
+
+DistScale = 0.2;                    % distortion scaling of sensor (in %)
+BiasScale = 0.5;                    % bias offset of sensor (in %)
+NoiseScale = 0.05;                  % noise scaling (in %)
+Xcouple = 1/5;                      % cross coupling distortion relative
+AscaleFactor = 0.5*(2^15-1);        % conversion of g's to bits
+HscaleFactor = 1/0.15;              % uT/bits
+
+He = [22770;5329;41510.2]/1000;     % Earth's magnetic field in uT (NED)
+Ge = [0;0;1];                       % Earth's gravitational field in g (NED)
+
+Adist = eye(3) + DistScale*diag(rand(3,1)-0.5) + ... 
+       DistScale*Xcouple*(rand(3,3)-0.5);       % distortion matrix
+Bdist = rand(3,1)-0.5;                          % bias vector
+
+NoiA = NoiseScale*norm(Ge)*randn(npts,3);  % noise for accelerometer
+NoiH = NoiseScale*norm(He)*randn(npts,3);  % noise for magnetometer
+
+A = zeros(npts,3);
+H = zeros(npts,3);
+
+for i = 1:npts,
+    R = CreateRandomAttitude();
+    A(i,:) = (R*Ge)';
+    H(i,:) = (R*He)';
+end
+
+Anoise = (Adist*A')' + norm(Ge)*ones(size(A))*Bdist + NoiA;
+Hnoise = (Adist*H')' + norm(He)*ones(size(A))*Bdist + NoiH;
+
+Anoise = floor(AscaleFactor*Anoise);
+Hnoise = floor(HscaleFactor*Hnoise);
+
+% figure(gcf), clf
+% sphere(50),hold on
+% colormap('gray');
+% plot3(He(1),He(2),He(3),'r.');
+% plot3(H(:,1),H(:,2),H(:,3),'g.');
+% plot3(Hnoise(:,1),Hnoise(:,2),Hnoise(:,3),'b.');
+% axis('equal');
+
+
+
diff --git a/matlab/Lab3/EllipseXYData.m b/matlab/Lab3/EllipseXYData.m
new file mode 100644
index 0000000..4d9bfba
--- /dev/null
+++ b/matlab/Lab3/EllipseXYData.m
@@ -0,0 +1,304 @@
+% 
+% Simulated Data for CMPE-167 Winter 2018
+%
+R = 1;
+Xmeas = [0.9347
+    0.9570
+   -0.6242
+    1.2415
+    1.0756
+   -0.0298
+    1.5189
+    0.4453
+   -0.5628
+   -0.0476
+   -0.7229
+    0.0139
+    1.3431
+    1.4811
+    1.0454
+    0.9979
+    1.2189
+    0.5232
+   -0.5799
+    1.3681
+    0.0681
+    0.2069
+   -0.6193
+   -0.2821
+    0.5394
+   -0.8139
+   -0.0148
+    1.2408
+   -0.5560
+   -0.1411
+   -0.7946
+   -0.6001
+    0.1714
+   -0.1677
+   -0.6358
+   -0.8255
+    1.0939
+    1.5181
+    1.6205
+    1.3748
+    0.6638
+    0.1329
+    0.1699
+    0.2000
+    0.8347
+    1.3524
+    1.4262
+    1.1855
+    1.3295
+   -0.5547
+    1.4096
+    0.7090
+   -0.6479
+    0.3324
+    0.6983
+    1.0901
+    1.4541
+    0.2907
+   -0.7798
+    0.1069
+    1.4057
+   -0.6421
+   -0.4982
+    1.0944
+    0.2416
+   -0.6635
+   -0.7096
+    0.3634
+    0.2665
+    1.5058
+    0.0225
+   -0.7228
+    1.5994
+   -0.5159
+    1.4125
+    0.2263
+    1.4188
+    1.4561
+    1.1533
+   -0.6606
+    0.4430
+    1.3402
+   -0.2161
+    1.2337
+   -0.5484
+    1.1496
+   -0.4635
+   -0.4918
+    0.7323
+   -0.6476
+   -0.4592
+    1.1225
+   -0.5976
+    0.2905
+    1.4232
+    1.1820
+    0.4304
+   -0.6829
+   -0.2182
+    0.4317
+    1.3932
+    1.4542
+    0.0273
+   -0.0796
+   -0.7569
+    0.6432
+    0.1065
+   -0.2673
+    0.4000
+    0.9374
+   -0.0138
+    1.2939
+   -0.6766
+   -0.0510
+   -0.1698
+    1.0430
+   -0.4285
+   -0.5253
+    0.0456
+    1.4314
+    1.1940
+    0.9400
+    1.1753
+    1.2538
+    0.6288
+    0.7427
+    0.7459
+   -0.7379
+   -0.4295
+    1.1015
+    0.3809
+   -0.7079
+    1.4174
+   -0.6474
+    1.3232
+    0.0209
+    0.4857
+   -0.1420
+    0.7069
+    0.1560
+    1.1866
+    0.7311
+   -0.3751
+   -0.1832
+    1.3090
+   -0.6317
+    0.9098
+    1.5072
+    0.2844
+    1.5444];
+Ymeas = [-2.2060
+   -2.3082
+   -1.4785
+    1.1654
+   -2.0800
+    1.6180
+    0.1472
+    1.9846
+   -1.7017
+   -2.2126
+   -0.9014
+    1.6839
+    0.5130
+   -0.6402
+    1.4768
+   -2.1048
+    1.0224
+    1.8766
+   -1.2218
+   -1.3108
+    1.6296
+    1.6884
+   -1.5972
+   -2.0123
+    1.6806
+   -0.3194
+   -2.2963
+    1.1597
+   -1.3952
+    1.3348
+   -0.5511
+   -0.5201
+    1.7365
+   -1.9184
+    0.1187
+    0.5192
+   -2.1046
+   -0.5885
+    0.2498
+   -1.4155
+   -2.3498
+    1.6581
+    1.5781
+    1.7392
+    1.5975
+   -1.4834
+   -1.3363
+   -1.8185
+    0.3529
+    0.7205
+    0.5420
+    1.5699
+   -0.4817
+    1.9010
+   -2.3546
+    1.4125
+   -1.2064
+    1.5143
+   -0.3000
+    2.0410
+    0.0781
+    0.7285
+   -1.6182
+   -2.1147
+   -2.3265
+   -0.2124
+   -0.6494
+    1.8190
+    1.7722
+   -0.7596
+    1.7966
+    0.1797
+   -0.6513
+    0.6279
+   -0.0503
+   -2.2842
+   -1.3540
+    0.4736
+    1.5601
+   -0.6563
+   -2.2978
+    0.9160
+   -1.9064
+   -1.7244
+   -1.3017
+    1.3345
+    1.2444
+    0.9226
+   -2.0024
+   -0.4243
+   -1.5977
+    1.1444
+   -1.3933
+   -2.4185
+   -0.8349
+    1.1440
+   -2.7658
+   -1.2570
+    1.4691
+    1.8137
+    0.0477
+   -1.0218
+   -2.3473
+    1.5403
+   -0.2810
+   -2.4749
+    1.7152
+   -2.1144
+    1.6246
+    1.6802
+   -2.3508
+    0.7765
+   -0.8349
+    1.6367
+   -2.1459
+    1.2547
+   -1.4310
+   -1.6016
+   -2.4803
+    0.2932
+    1.0310
+   -2.2012
+    1.0488
+    1.0106
+    1.6589
+    1.5855
+   -2.6320
+   -1.0656
+    0.9622
+    1.3617
+   -2.3449
+   -0.3527
+   -1.1779
+   -1.3335
+   -1.4093
+    1.5086
+    1.7755
+   -2.1095
+   -2.4443
+    1.6028
+    1.5606
+   -2.3079
+    0.8832
+   -2.0762
+   -1.3766
+    0.4100
+   -2.1250
+   -0.6457
+    1.7754
+   -0.3000];
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstDemo/ClosedLoopGyroIntegration.m b/matlab/Lab4/AttitudeEstDemo/ClosedLoopGyroIntegration.m
new file mode 100644
index 0000000..ae9ebaa
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstDemo/ClosedLoopGyroIntegration.m
@@ -0,0 +1,80 @@
+clear;
+clear clc;
+clf;
+
+dT = 1/50
+
+numSteps=200;
+
+p=deg2rad(0);
+q=deg2rad(0);
+r=deg2rad(0);
+gyroInput=[p;q;r];
+
+biasTerms=[.01;.01;.01];
+%biasTerms=[.0;.0;.0];
+accelInertial=[0;0;-1];
+accelReading=[0;0;-1];
+magInertial=[1;0;0];
+magReading=[1;0;0];
+
+Kp_a=.2;
+Ki_a=Kp_a/10;
+
+Kp_m=.2;
+Ki_m=Kp_m/10;
+
+biasEstimate=[0;0;0];
+nvector=[1;0;0];
+evector=[0;-1;0];
+dvector=[0;0;-1];
+
+
+
+Ro=eye(3);
+angleX = deg2rad(30);
+angleY = deg2rad(30);
+angleZ = deg2rad(30);
+rotX=[1 0 0; 0 cos(angleX) -sin(angleX); 0 sin(angleX) cos(angleX)];
+rotY=[cos(angleY) 0 sin(angleY); 0 1 0; -sin(angleY) 0 cos(angleY)];
+rotZ=[cos(angleZ) -sin(angleZ) 0; sin(angleZ) cos(angleZ) 0; 0 0 1];
+Ro=rotX*rotY*rotZ;
+
+initNVector=Ro*nvector;
+initEVector=Ro*evector;
+initDVector=Ro*dvector;
+
+R=Ro;
+
+
+
+[sX,sY,sZ]=sphere(30);
+surf(sX,sY,sZ,'FaceAlpha',.1,'EdgeColor','none');
+axis equal;
+xlabel('x')
+ylabel('y')
+zlabel('z')
+hold on
+
+quiver3([0,0,0],[0,0,0],[0,0,0],[initNVector(1),initEVector(1),initDVector(1)],[initNVector(2),initEVector(2),initDVector(2)],[initNVector(3),initEVector(3),initDVector(3)],0);
+pause
+
+for i=1:numSteps,              
+    gyroInputWithBias=gyroInput+biasTerms;
+    wmeas_a=rcross(accelReading)*(R*accelInertial);
+    wmeas_m=rcross(magReading)*(R*magInertial);
+    %wmeas_a = [0 0 0]';
+    
+    gyroInputWithFeedback = gyroInputWithBias - biasEstimate + Kp_a*wmeas_a + Kp_m*wmeas_m;
+    bdot=-Ki_a*wmeas_a - Ki_m*wmeas_m;
+    
+    R=Rexp(gyroInputWithFeedback, dT) * R
+    biasEstimate=biasEstimate+bdot*dT;
+    newNVector=R'*nvector;
+    newEVector=R'*evector;
+    newDVector=R'*dvector;
+    quiver3([0,0,0],[0,0,0],[0,0,0],[newNVector(1),newEVector(1),newDVector(1)],[newNVector(2),newEVector(2),newDVector(2)],[newNVector(3),newEVector(3),newDVector(3)],0);
+ pause;
+end
+
+hold off
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstDemo/ClosedLoopGyroIntegration_Accel.m b/matlab/Lab4/AttitudeEstDemo/ClosedLoopGyroIntegration_Accel.m
new file mode 100644
index 0000000..000add7
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstDemo/ClosedLoopGyroIntegration_Accel.m
@@ -0,0 +1,76 @@
+clear;
+clear clc;
+clf;
+
+numSteps=200;
+
+dT = 1/20;
+
+p=deg2rad(0);
+q=deg2rad(0);
+r=deg2rad(0);
+gyroInput=[p;q;r];
+
+%biasTerms=[.01;.01;.01];
+biasTerms=[.0;.0;.0];
+accelInertial=[0;0;-1];
+accelReading=[0;0;-1];
+
+
+Kp_a=.2;
+Ki_a=Kp_a/10;
+
+
+biasEstimate=[0;0;0];
+nvector=[1;0;0];
+evector=[0;-1;0];
+dvector=[0;0;-1];
+
+
+
+Ro=eye(3);
+angleX = deg2rad(30);
+angleY = deg2rad(30);
+angleZ = deg2rad(30);
+rotX=[1 0 0; 0 cos(angleX) -sin(angleX); 0 sin(angleX) cos(angleX)];
+rotY=[cos(angleY) 0 sin(angleY); 0 1 0; -sin(angleY) 0 cos(angleY)];
+rotZ=[cos(angleZ) -sin(angleZ) 0; sin(angleZ) cos(angleZ) 0; 0 0 1];
+Ro=rotX*rotY*rotZ;
+
+initNVector=Ro*nvector;
+initEVector=Ro*evector;
+initDVector=Ro*dvector;
+
+R=Ro;
+
+
+
+[sX,sY,sZ]=sphere(30);
+figure(1)
+surf(sX,sY,sZ,'FaceAlpha',.1,'EdgeColor','none');
+axis equal;
+xlabel('x')
+ylabel('y')
+zlabel('z')
+hold on
+
+quiver3([0,0,0],[0,0,0],[0,0,0],[initNVector(1),initEVector(1),initDVector(1)],[initNVector(2),initEVector(2),initDVector(2)],[initNVector(3),initEVector(3),initDVector(3)],0);
+pause
+
+for i=1:numSteps,              
+    gyroInputWithBias=gyroInput+biasTerms;
+    wmeas_a=rcross(accelReading)*(R*accelInertial);
+    
+    gyroInputWithFeedback = gyroInputWithBias - biasEstimate + Kp_a*wmeas_a;
+    bdot=-Ki_a*wmeas_a;
+    
+    R=Rexp(gyroInputWithFeedback, dT) * R
+    biasEstimate=biasEstimate + bdot*dT;
+    newNVector=R'*nvector;
+    newEVector=R'*evector;
+    newDVector=R'*dvector;
+    quiver3([0,0,0],[0,0,0],[0,0,0],[newNVector(1),newEVector(1),newDVector(1)],[newNVector(2),newEVector(2),newDVector(2)],[newNVector(3),newEVector(3),newDVector(3)],0);
+ pause;
+end
+
+hold off
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstDemo/OpenLoopIntegration_Bias.m b/matlab/Lab4/AttitudeEstDemo/OpenLoopIntegration_Bias.m
new file mode 100644
index 0000000..447ce3b
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstDemo/OpenLoopIntegration_Bias.m
@@ -0,0 +1,50 @@
+clear;
+clear clc;
+close all;
+
+dT = 1;
+
+numSteps=20;
+
+p=deg2rad(0);
+q=deg2rad(0);
+r=deg2rad(0);
+gyroInput=[p;q;r];
+
+
+
+nvector=[1;0;0];
+evector=[0;-1;0];
+dvector=[0;0;-1];
+
+
+
+Ro=eye(3);
+
+R=Ro;
+
+
+
+[sX,sY,sZ]=sphere(30);
+surf(sX,sY,sZ,'FaceAlpha',.1,'EdgeColor','none');
+axis equal;
+xlabel('x')
+ylabel('y')
+zlabel('z')
+hold on
+
+quiver3([0,0,0],[0,0,0],[0,0,0],[nvector(1),evector(1),dvector(1)],[nvector(2),evector(2),dvector(2)],[nvector(3),evector(3),dvector(3)]);
+pause
+
+for i=1:numSteps,
+    gyroInputWithBias=gyroInput+[deg2rad(rand);deg2rad(rand);deg2rad(rand)]
+    R= Rexp(gyroInputWithBias, dT) * R
+    newNVector=R'*nvector;
+    newEVector=R'*evector;
+    newDVector=R'*dvector;
+    quiver3([0,0,0],[0,0,0],[0,0,0],[newNVector(1),newEVector(1),newDVector(1)],[newNVector(2),newEVector(2),newDVector(2)],[newNVector(3),newEVector(3),newDVector(3)]);
+    pause;
+end
+
+hold off
+ 
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstDemo/OpenLoopIntegration_noBias.m b/matlab/Lab4/AttitudeEstDemo/OpenLoopIntegration_noBias.m
new file mode 100644
index 0000000..9876920
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstDemo/OpenLoopIntegration_noBias.m
@@ -0,0 +1,44 @@
+clear;
+clear clc;
+close all;
+
+dT = 1/20;
+
+p=deg2rad(20);
+q=deg2rad(0);
+r=deg2rad(0);
+gyroInput=[p;q;r];
+
+nvector=[1;0;0];
+evector=[0;-1;0];
+dvector=[0;0;-1];
+
+Ro=eye(3);
+
+R=Ro;
+
+
+
+[sX,sY,sZ]=sphere(30);
+surf(sX,sY,sZ,'FaceAlpha',.1,'EdgeColor','none');
+axis equal;
+xlabel('x')
+ylabel('y')
+zlabel('z')
+hold on
+
+quiver3([0,0,0],[0,0,0],[0,0,0],[nvector(1),evector(1),dvector(1)],[nvector(2),evector(2),dvector(2)],[nvector(3),evector(3),dvector(3)],0);
+pause
+
+for i=0:40,
+    i
+    R = Rexp(gyroInput, dT) * R
+    newNVector=R'*nvector;
+    newEVector=R'*evector;
+    newDVector=R'*dvector;
+    quiver3([0,0,0],[0,0,0],[0,0,0],[newNVector(1),newEVector(1),newDVector(1)],[newNVector(2),newEVector(2),newDVector(2)],[newNVector(3),newEVector(3),newDVector(3)],0);
+    pause;
+end
+
+hold off
+ 
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstDemo/Rexp.m b/matlab/Lab4/AttitudeEstDemo/Rexp.m
new file mode 100644
index 0000000..9f36a6e
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstDemo/Rexp.m
@@ -0,0 +1,17 @@
+function R_exp = Rexp(w, deltaT)
+% function R_exp = Rexp(w, deltaT)
+%
+% returns the exponential Rodrigues parameter form of the integration that
+% keeps R on SO(3). See Park and Chung paper. Requires a time step and the Rotation
+% rate (omega).
+%
+wnorm = norm(w);
+wx = rcross([w(1); w(2); w(3)]);
+if wnorm < 0.2, % just plucked this one out of the air, need a better number here
+   sincW = deltaT - (deltaT^3 * wnorm^2)/6.0 + (deltaT^5 * wnorm^4)/120.0;
+   oneMinusCosW = (deltaT^2)/2.0 - (deltaT^4 * wnorm^2)/24.0 + (deltaT^6 * wnorm^4)/720.0;
+else
+   sincW = sin(wnorm * deltaT)/ wnorm;
+   oneMinusCosW = (1.0 - cos(wnorm * deltaT)) / wnorm^2;
+end
+R_exp = [1 0 0;0 1 0;0 0 1] - sincW * wx + oneMinusCosW * wx * wx;
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstDemo/rcross.m b/matlab/Lab4/AttitudeEstDemo/rcross.m
new file mode 100644
index 0000000..f651153
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstDemo/rcross.m
@@ -0,0 +1,7 @@
+function rx = rcross(r)
+% function rx = rcross(r)
+% forms the skew symmetric x-product matrix of a 3x1 vector
+rx=[0    -r(3)  r(2);
+    r(3)  0    -r(1);
+   -r(2)  r(1)  0];
+end
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstLab/AnimateAttitude.m b/matlab/Lab4/AttitudeEstLab/AnimateAttitude.m
new file mode 100644
index 0000000..fd97073
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/AnimateAttitude.m
@@ -0,0 +1,75 @@
+function AnimateAttitude(dT, Eul)
+% function AnimateAttitude(dT, Eul)
+%
+% Animation for visulization of attitude from Euler angle data
+% dT is time step (in seconds)
+% Eul is [Yaw Pitch Roll] x n points (in degrees)
+%
+% Function sets up transparent sphere with cardinal X-Y-Z vectors and then
+% animates a very crude aircraft through the euler angles seen in the Eul
+% vector.
+
+D2R = pi/180;
+X = [1 0;-0.5 -0.5;-0.5 -0.5];
+Y = [0 0;0.5 0;-0.5 0];
+Z = [0 0;0 0;0 -0.75];
+XYZ_body = [X(:,1) Y(:,1) Z(:,1)];
+XYZ_tail = [X(:,2) Y(:,2) Z(:,2)];
+
+ned2plot = [1 0 0;0 -1 0;0 0 -1];
+
+XYZ_body = (ned2plot*XYZ_body')';
+XYZ_tail = (ned2plot*XYZ_tail')';
+
+figure(10), clf
+[xx,yy,zz] = sphere(50);
+h = surf(xx,yy,zz);
+set(h,'LineStyle','none');
+hold on
+colormap('gray');
+alpha(0.1);
+axis('equal');
+h = gca;
+set(h,'XTickLabel',[],'YTickLabel',[],'ZTickLabel',[]);
+quiver3(0,0,0,1.5,0,0,'r','filled','LineWidth',2)
+quiver3(0,0,0,0,-1.5,0,'g','filled','LineWidth',2)
+quiver3(0,0,0,0,0,-1.5,'b','filled','LineWidth',2)
+g = patch(XYZ_body(:,1),XYZ_body(:,2),XYZ_body(:,3),'red');
+h = patch(XYZ_tail(:,1),XYZ_tail(:,2),XYZ_tail(:,3),'blue');
+xlabel('North'), ylabel('East'), zlabel('Down')
+
+    for i=1:length(Eul),
+        R = eul2dcm(Eul(i,:)'*D2R);
+        XYZ_body = (ned2plot*R*[X(:,1) Y(:,1) Z(:,1)]')';
+        XYZ_tail = (ned2plot*R*[X(:,2) Y(:,2) Z(:,2)]')';
+        g.XData = XYZ_body(:,1);
+        g.YData = XYZ_body(:,2);
+        g.ZData = XYZ_body(:,3);
+        h.XData = XYZ_tail(:,1);
+        h.YData = XYZ_tail(:,2);
+        h.ZData = XYZ_tail(:,3);
+        drawnow limitrate
+        pause(dT);
+    end
+end
+    
+function C=eul2dcm(eul)
+%----------------------------------------------------------------
+% function C=eul2dcm(eul)
+%
+%   This functions determines the direction cosine matrix C
+%   that transforms a vector in a reference axis system at time k
+%   to one the same axis sytem at time k+1.  The input argument to
+%   this function is a vector of the Euler angles in the following
+%   order: eul = [yaw,pitch,roll]. (i.e., 3-2-1 rotation convention).  
+%
+%-----------------------------------------------------------------  
+
+ps=eul(1); th=eul(2); ph=eul(3);
+
+C1=[1 0 0; 0 cos(ph) sin(ph); 0 -sin(ph) cos(ph)];
+C2=[cos(th) 0 -sin(th); 0 1 0; sin(th) 0 cos(th)];
+C3=[cos(ps) sin(ps) 0; -sin(ps) cos(ps) 0; 0 0 1];
+
+C=C1*C2*C3;
+end
diff --git a/matlab/Lab4/AttitudeEstLab/CheckOrthonormality.m b/matlab/Lab4/AttitudeEstLab/CheckOrthonormality.m
new file mode 100644
index 0000000..f526a4f
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/CheckOrthonormality.m
@@ -0,0 +1,9 @@
+function [Error] = CheckOrthonormality(R)
+% function [Error] = CheckOrthonormality(R)
+%
+% Function checks the orthonormality of a matrix passed to it and returns a
+% value that is the Frobinius norm of the residual. Smaller numbers
+% indicate better orthonormality
+
+Check = R'*R - eye(3);
+Error = norm(Check,'fro');
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstLab/ClosedLoopGyroIntegration_func.m b/matlab/Lab4/AttitudeEstLab/ClosedLoopGyroIntegration_func.m
new file mode 100644
index 0000000..4cea674
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/ClosedLoopGyroIntegration_func.m
@@ -0,0 +1,70 @@
+clear;
+clear clc;
+clf;
+
+numSteps=200;
+
+p=deg2rad(0);
+q=deg2rad(0);
+r=deg2rad(0);
+gyroInput=[p;q;r];
+
+biasTerms=[.1;.1;.1];
+%biasTerms=[.0;.0;.0];
+accelInertial=[0;0;-1];
+accelReading=[0;0;-1];
+magInertial=[1;0;0];
+magReading=[1;0;0];
+
+Kp_a=.2;
+Ki_a=Kp_a/10;
+
+Kp_m=.2;
+Ki_m=Kp_m/10;
+
+biasEstimate=[0;0;0];
+nvector=[1;0;0];
+evector=[0;-1;0];
+dvector=[0;0;-1];
+
+
+
+Ro=eye(3);
+angleX = deg2rad(30);
+angleY = deg2rad(30);
+angleZ = deg2rad(30);
+rotX=[1 0 0; 0 cos(angleX) -sin(angleX); 0 sin(angleX) cos(angleX)];
+rotY=[cos(angleY) 0 sin(angleY); 0 1 0; -sin(angleY) 0 cos(angleY)];
+rotZ=[cos(angleZ) -sin(angleZ) 0; sin(angleZ) cos(angleZ) 0; 0 0 1];
+Ro=rotX*rotY*rotZ;
+
+initNVector=Ro*nvector;
+initEVector=Ro*evector;
+initDVector=Ro*dvector;
+
+R=Ro;
+
+
+
+[sX,sY,sZ]=sphere(30);
+surf(sX,sY,sZ,'FaceAlpha',.1,'EdgeColor','none');
+axis equal;
+xlabel('x')
+ylabel('y')
+zlabel('z')
+hold on
+
+quiver3([0,0,0],[0,0,0],[0,0,0],[initNVector(1),initEVector(1),initDVector(1)],[initNVector(2),initEVector(2),initDVector(2)],[initNVector(3),initEVector(3),initDVector(3)],0);
+pause
+
+for i=1:numSteps,              
+    gyroInputWithBias=gyroInput+biasTerms;
+    [R,biasEstimate] = IntegrateClosedLoop(R,biasEstimate,gyroInputWithBias,magReading,accelReading,magInertial,accelInertial,.1)
+    newNVector=R'*nvector;
+    newEVector=R'*evector;
+    newDVector=R'*dvector;
+    quiver3([0,0,0],[0,0,0],[0,0,0],[newNVector(1),newEVector(1),newDVector(1)],[newNVector(2),newEVector(2),newDVector(2)],[newNVector(3),newEVector(3),newDVector(3)],0);
+ pause;
+end
+
+hold off
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstLab/CreateTrajectoryData.m b/matlab/Lab4/AttitudeEstLab/CreateTrajectoryData.m
new file mode 100644
index 0000000..3549f0b
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/CreateTrajectoryData.m
@@ -0,0 +1,121 @@
+function [Acc,Mag,wGyro,Eul] = CreateTrajectoryData(dT,noiseFlag)
+% function [Acc,Mag,wGyro,Eul] = CreateTrajectoryData(dT,noiseFlag)
+%
+% m-file to create trajectory paths that can be used to verify that your
+% algorithms are working and that you are recreating good attitude data. Trajctory
+% will include noise, and bias on the gyros.
+%
+% Note that the magnetometer and accelerometer data come out as unit
+% vectors (e.g.: post-tumble calibration correction).
+%
+% Inputs: dT is the timestep of your sensor system (seconds)
+%         noiseFlag will add noise to sensors if set to 'true'
+%
+% Acc is the body fixed accelerometer readings in floats (unit norm)
+% Mag is the body fixed magnetometer readings in floats (unit norm)
+% wGyro is the body fixed gyro measurements in signed ints
+% Eul is the true euler angles (noise free) for each time step (yaw, pitch, roll) [deg]
+
+wdT = (rand(3,1)-0.5)*2*pi;
+Ro = Rexp(wdT, 1.0);                     % initial random attitude
+
+AscaleFactor = 0.5*(2^15-1);        % conversion of g's to bits
+HscaleFactor = 1/0.15;              % bits/uT
+GscaleFactor = (1/250)*(2^15-1);    % bits/(deg/s)
+
+gyrobias = 10*(rand(3,1)-0.5);      % gyrobias (deg/s)
+gyronoise = 0.1;                    % degrees/sec RMS
+accelnoise = 0.008;                 % accelerometer noise in g's
+magnoise = 0.01;                    % magnetomoeter noise in Earth field units
+
+He = [22770;5329;41510.2]/1000;     % Earth's magnetic field in uT (NED)
+Hu = He/norm(He);                   % magnetic field unit vector
+Ge = [0;0;1];                       % Earth's gravitational field in g (NED)
+
+Tp = 0.5;                           % time of flight for polynomial (sec)
+Tc = 3;                             % time of flight for constant (sec)
+TotAng = 180;                       % total angle to cover (deg)
+MaxRate = TotAng/(Tp+Tc);           % maximum rate in (deg/s)
+
+%
+% Generate time vector and body-rate for 180 degree rotation and back
+%
+
+TimeVec = [(dT:dT:Tp)'-dT;          % rise time polynomial
+           (Tp:dT:Tp+Tc-dT)';       % cruize at constant
+           (Tp+Tc:dT:Tp+Tc+Tp)'];   % fall time polynomial
+OneSecond = [0:dT:1]';              % 1 second from 0-1 in dT steps
+       
+xp = (1/Tp)*((dT:dT:Tp)'-dT);
+xc = (Tp:dT:Tp+Tc-dT)';
+       
+wVec = MaxRate*[3*xp.^2 - 2*xp.^3;      % rise time values (deg/s)
+                ones(size(xc));         % constant cruise time
+             1-(3*xp.^2 - 2*xp.^3);0];  % fall time polynomial
+             
+wRoundTrip = [zeros(size(OneSecond));   % High Low High rate return to 0
+              wVec;
+              zeros(size(OneSecond));
+             -wVec;
+              zeros(size(OneSecond))];
+          
+%
+% Create the trajectory path
+%
+
+npts = length(wRoundTrip);
+G = [zeros(npts,2) wRoundTrip;                  % r rotation in yaw
+     zeros(npts,1) wRoundTrip zeros(npts,1);    % q rotation in pitch
+     wRoundTrip zeros(npts,2);                  % p rotation in roll
+     wRoundTrip zeros(npts,1) -wRoundTrip;      % p and r together
+     zeros(npts,1) -wRoundTrip wRoundTrip;      % q and r together
+     -wRoundTrip wRoundTrip zeros(npts,1)];     % p and q together
+     
+          
+npts = length(G);
+A = zeros(npts,3);
+H = zeros(npts,3);
+Eul = zeros(npts,3);
+
+R = Ro;
+for i = 1:npts,
+    A(i,:) = (R*Ge)';                   % rotate unit norm gravity into body frame
+    H(i,:) = (R*Hu)';                   % rotate unit norm magnetic field
+    Eul(i,:) = [atan2(R(1,2),R(1,1)) ...
+               -asin(R(1,3)) ...
+                atan2(R(2,3),R(3,3))]*180/pi;  % yaw pitch roll (deg)
+    R = Rexp(G(i,:)*pi/180, dT) * R;       % update rotation matrix
+end
+
+%
+% Scale to integer units and add bias and noise
+%
+
+NoiA = accelnoise*randn(npts,3);    % noise for accelerometer
+NoiH = magnoise*randn(npts,3);      % noise for magnetometer
+NoiG = gyronoise*randn(npts,3);     % wideband noise on gyros (in deg/s)
+BiasG = (ones(3,npts).*gyrobias)';  % gyrobias (in deg/s)
+
+Gnoise = G + NoiG + BiasG;          % corrupted gyro measurements in deg/s
+Anoise = A + NoiA;                  % corrupted accelerometer measurements
+Hnoise = H + NoiH;                  % corrupted magnetometer measurements
+
+Gnoise = floor(GscaleFactor*Gnoise);% scaled to signed 16bit ints
+G = floor(GscaleFactor*G);          % scaled to signed 16bit ints
+
+if noiseFlag,
+    Acc = Anoise;
+    Mag = Hnoise;
+    wGyro = Gnoise;
+else,
+    Acc = A;
+    Mag = H;
+    wGyro = G;
+end
+    
+
+
+
+  
+
+              
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstLab/DCMfromTriad.m b/matlab/Lab4/AttitudeEstLab/DCMfromTriad.m
new file mode 100644
index 0000000..6305fde
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/DCMfromTriad.m
@@ -0,0 +1,29 @@
+function R = DCMfromTrial(mags, accels, magInertial, accelInertial)
+% function R = DCMfromTrial(mags, accels, magInertial, accelInertial)
+%
+% Implements a solution to Wahba's problem based in the TRIAD algorithm to
+% give you an estimate of the DCM from two non-collinear vector
+% measurements
+%
+% Inputs: magnetic field vector in body coordinates (mags)
+%         gravity vector in body coordinated (accels)
+%         Inertial magnetic reference vector (magInertial)
+%         Inertial gravity reference vector (accelInertial)
+%
+% Outputs: DCM estimate
+
+accels = accels/norm(accels);                       % set mags and accels to unit vectors
+mags = mags/norm(mags);
+
+magInertial = magInertial/norm(magInertial);        % set inertial reference vectors to unit vectors
+accelInertial = accelInertial/norm(accelInertial);
+
+m = rcross(mags)*accels;
+m = m/norm(m);
+
+M = rcross(magInertial) * accelInertial;
+M = M/norm(M);
+
+A = [magInertial M rcross(magInertial)*M]*[mags m rcross(mags)*m]';
+R = A';
+
diff --git a/matlab/Lab4/AttitudeEstLab/ExpWalk.m b/matlab/Lab4/AttitudeEstLab/ExpWalk.m
new file mode 100644
index 0000000..9b804ff
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/ExpWalk.m
@@ -0,0 +1,32 @@
+
+clear all;
+clc;
+
+
+R=eye(3);
+dt=.1;
+gyro=[0;0;0]
+numsteps=2000;
+
+RTracking = R(:)';
+Thetas= [0];
+RChangedTemp = (R'*R);
+RChanged = RChangedTemp(:)';
+for i=1:numsteps
+    R=IntegrateOpenLoop(R,gyro,dt)
+    Thetas(i+1)=asin(-R(1,3));
+    Rtracking(i+1,:) = R(:)';
+    RChangedTemp = (R'*R);
+    RChanged(i+1,:) = RChangedTemp(:)';
+    %plot(R)
+end
+figure(1);
+subplot(1,2,1)
+plot(Rtracking)
+title("R over Time")
+subplot(1,2,2)
+plot(RChanged)
+title("R'*R")
+figure(2);
+plot(Thetas, '.')
+title("Theta over Time")
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstLab/IntegrateClosedLoop.m b/matlab/Lab4/AttitudeEstLab/IntegrateClosedLoop.m
new file mode 100644
index 0000000..1da3a17
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/IntegrateClosedLoop.m
@@ -0,0 +1,47 @@
+function [Rplus, Bplus] = IntegrateClosedLoop(Rminus, Bminus, gyros, mags, accels, magInertial, accelInertial, deltaT)
+% function [Rplus, Bplus] = IntegrateClosedLoop(Rminus, Bminus, gyros, mags, accels, magInertial, accelInertial, deltaT)
+%
+% Function to implement the full complementary estimate and integration of
+% gyros for full attitude estimation using an accelerometer and
+% magnetometer feedback.
+%
+% Inputs: Previous attitute DCM (Rminus)
+%         Previous bias estimate (Bminus)
+%         Body Fixed Rotation rates ([p;q;r]) in rad/s (gyros)
+%         Magnetometer Readings in body coordinates (mags)
+%         Accelerometer Readings in body coordinates (accels)
+%         Inertial reference magnetic field (magInertial)
+%         Inertial reference gravity field (accelInertial)
+%         Time between samples (deltaT) in seconds
+%
+% Outputs: New DCM (Rplus)
+%          New Gyro Bias (Bplus)
+%
+% Note: This code implements a full complementary filter on the DCM using
+% the matrix exponential integration of the gyros. Units of the mags and
+% accels should match their respective reference inertial vectors. The
+% gains are constant and set internally, modify as needed.
+
+
+Kp_a=10;
+Ki_a=Kp_a/10;
+
+Kp_m=10;
+Ki_m=Kp_m/10;
+
+accels = accels/norm(accels);                       % set mags and accels to unit vectors
+mags = mags/norm(mags);
+
+magInertial = magInertial/norm(magInertial);        % set inertial reference vectors to unit vectors
+accelInertial = accelInertial/norm(accelInertial);
+
+gyroInputWithBias = gyros - Bminus;
+wmeas_a = rcross(accels)*(Rminus * accelInertial); % accelerometer correction in the body frame
+wmeas_m = rcross(mags) * (Rminus * magInertial);   % magnetometer correction in the body frame
+    
+gyroInputWithFeedback = gyroInputWithBias + Kp_a*wmeas_a + Kp_m*wmeas_m;
+bdot=-Ki_a*wmeas_a - Ki_m*wmeas_m;
+    
+Rplus = Rexp(gyroInputWithFeedback, deltaT) * Rminus;
+Bplus = Bminus + bdot*deltaT;
+
diff --git a/matlab/Lab4/AttitudeEstLab/IntegrateOpenLoop.m b/matlab/Lab4/AttitudeEstLab/IntegrateOpenLoop.m
new file mode 100644
index 0000000..a6d1eb3
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/IntegrateOpenLoop.m
@@ -0,0 +1,22 @@
+function [Rplus] = IntegrateOpenLoop(Rminus, gyros, deltaT)
+% function [Rplus] = IntegrateOpenLoop(Rminus, gyros, deltaT)
+%
+% Function to Integrate the gyros to the attitude DCM
+%
+% Inputs: Previous attitute DCM (Rminus)
+%         Body Fixed Rotation rates ([p;q;r]) in rad/s
+%         Time between samples (deltaT) in seconds
+%
+% Outputs: New DCM (Rplus)
+%
+% Note: This code implements both a forward integration as well as the
+% matrix exponential version of the integration, change the flag in the
+% code below to pick between them.
+
+UseMatrixExponential = 1;   % set to zero for forward integration
+
+if (UseMatrixExponential),
+    Rplus = Rexp(gyros, deltaT) * Rminus;
+else
+    Rplus = Rminus - rcross(gyros) * Rminus * deltaT ;
+end
diff --git a/matlab/Lab4/AttitudeEstLab/OpenLoopIntegration_func.m b/matlab/Lab4/AttitudeEstLab/OpenLoopIntegration_func.m
new file mode 100644
index 0000000..6e6b24e
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/OpenLoopIntegration_func.m
@@ -0,0 +1,49 @@
+clear;
+clear clc;
+close all;
+
+numSteps=20;
+
+p=deg2rad(0);
+q=deg2rad(0);
+r=deg2rad(0);
+gyroInput=[p;q;r];
+
+
+
+nvector=[1;0;0];
+evector=[0;-1;0];
+dvector=[0;0;-1];
+
+
+
+Ro=eye(3);
+
+R=Ro;
+
+
+
+[sX,sY,sZ]=sphere(30);
+surf(sX,sY,sZ,'FaceAlpha',.1,'EdgeColor','none');
+axis equal;
+xlabel('x')
+ylabel('y')
+zlabel('z')
+hold on
+
+quiver3([0,0,0],[0,0,0],[0,0,0],[nvector(1),evector(1),dvector(1)],[nvector(2),evector(2),dvector(2)],[nvector(3),evector(3),dvector(3)],1);
+pause
+
+for i=1:numSteps,
+    gyroInputWithBias=gyroInput+[.05;.04;.03];
+    %R=R*Rexp(gyroInputWithBias)
+    R=IntegrateOpenLoop(R,gyroInputWithBias,1)
+    newNVector=R'*nvector;
+    newEVector=R'*evector;
+    newDVector=R'*dvector;
+    quiver3([0,0,0],[0,0,0],[0,0,0],[newNVector(1),newEVector(1),newDVector(1)],[newNVector(2),newEVector(2),newDVector(2)],[newNVector(3),newEVector(3),newDVector(3)],1);
+    pause;
+end
+
+hold off
+ 
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstLab/PrettyPlotAttitudeData.m b/matlab/Lab4/AttitudeEstLab/PrettyPlotAttitudeData.m
new file mode 100644
index 0000000..38d22fe
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/PrettyPlotAttitudeData.m
@@ -0,0 +1,64 @@
+function PrettyPlotAttitudeData(dT,Acc,Mag,wGyro,Eul)
+% function PrettyPlotAttitudeData(dT,Acc,Mag,wGyro,Eul)
+%
+% This is a plotting function that goes through the data and reconstructs
+% the data and plots out graphs of relevant data
+
+He = [22770;5329;41510.2]/1000;     % Earth's magnetic field in uT (NED)
+Hu = He/norm(He);                   % magnetic field unit vector
+Ge = [0;0;1];                       % Earth's gravitational field in g (NED)
+
+npts = length(Eul);
+H = zeros(npts,3);
+A = zeros(npts,3);
+
+for i = 1:npts,
+    R = eul2dcm(Eul(i,:)*pi/180);   % generate a rotation matrix from Euler
+    H(i,:) = (R'*Hu)';
+    A(i,:) = (R'*Ge)';
+end
+
+Tvec = dT*[0:npts-1]';
+figure(5), clf;
+plot(Tvec,Eul);
+legend('yaw, \psi (^\circ)','pitch, \theta (^\circ)','roll, \phi (^\circ)');
+xlabel('Time, sec'), ylabel('Angle (^\circ)')
+title('Euler angles vs Time for synthetic data (noise free)');
+
+figure(6), clf;
+sphere(50),hold on
+colormap('gray');
+plot3(H(:,1),H(:,2),H(:,3),'r.');
+plot3(Mag(:,1),Mag(:,2),Mag(:,3),'m.');
+plot3(A(:,1),A(:,2),A(:,3),'b.');
+plot3(Acc(:,1),Acc(:,2),Acc(:,3),'c.');
+axis('equal'); legend('','Mags (perfect)','Mags + noise','Accels (perfect)','Accels + noise');
+title('Noise free projection of body-fixed mags and accels');  
+
+figure(7), clf
+plot(Tvec,wGyro);
+xlabel('Time, sec'), ylabel('angular rate (counts)')
+legend('p (counts)','q (counts)','r (counts)');
+title('Raw angular rates (in Counts)');
+end
+
+function C=eul2dcm(eul)
+%----------------------------------------------------------------
+% function C=eul2dcm(eul)
+%
+%   This functions determines the direction cosine matrix C
+%   that transforms a vector in a reference axis system at time k
+%   to one the same axis sytem at time k+1.  The input argument to
+%   this function is a vector of the Euler angles in the following
+%   order: eul = [yaw,pitch,roll]. (i.e., 3-2-1 rotation convention).  
+%
+%-----------------------------------------------------------------  
+
+ps=eul(1); th=eul(2); ph=eul(3);
+
+C1=[1 0 0; 0 cos(ph) sin(ph); 0 -sin(ph) cos(ph)];
+C2=[cos(th) 0 -sin(th); 0 1 0; sin(th) 0 cos(th)];
+C3=[cos(ps) sin(ps) 0; -sin(ps) cos(ps) 0; 0 0 1];
+
+C=C1*C2*C3;
+end
diff --git a/matlab/Lab4/AttitudeEstLab/Rexp.m b/matlab/Lab4/AttitudeEstLab/Rexp.m
new file mode 100644
index 0000000..9f36a6e
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/Rexp.m
@@ -0,0 +1,17 @@
+function R_exp = Rexp(w, deltaT)
+% function R_exp = Rexp(w, deltaT)
+%
+% returns the exponential Rodrigues parameter form of the integration that
+% keeps R on SO(3). See Park and Chung paper. Requires a time step and the Rotation
+% rate (omega).
+%
+wnorm = norm(w);
+wx = rcross([w(1); w(2); w(3)]);
+if wnorm < 0.2, % just plucked this one out of the air, need a better number here
+   sincW = deltaT - (deltaT^3 * wnorm^2)/6.0 + (deltaT^5 * wnorm^4)/120.0;
+   oneMinusCosW = (deltaT^2)/2.0 - (deltaT^4 * wnorm^2)/24.0 + (deltaT^6 * wnorm^4)/720.0;
+else
+   sincW = sin(wnorm * deltaT)/ wnorm;
+   oneMinusCosW = (1.0 - cos(wnorm * deltaT)) / wnorm^2;
+end
+R_exp = [1 0 0;0 1 0;0 0 1] - sincW * wx + oneMinusCosW * wx * wx;
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstLab/TestAttitudeEstimation.m b/matlab/Lab4/AttitudeEstLab/TestAttitudeEstimation.m
new file mode 100644
index 0000000..93d1992
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/TestAttitudeEstimation.m
@@ -0,0 +1,124 @@
+% m-file to estimate attitude (full closed loop) given synthetic data.
+%
+%
+dT = (1/50);                        % 50Hz update rate
+
+
+% Kp_a=1;
+% Ki_a=Kp_a/5;
+% 
+% Kp_m=1;
+% Ki_m=Kp_m/5;
+
+[Acc,Mag,wGyro,Eul] = CreateTrajectoryData(dT,true);
+
+npts = length(Eul);
+Tvec = dT*[0:npts-1]';
+
+He = [22770;5329;41510.2]/1000;     % Earth's magnetic field in uT (NED)
+Hu = He/norm(He);                   % magnetic field unit vector
+Ge = [0;0;1];                       % Earth's gravitational field in g (NED)
+
+D2R = pi/180;
+Ro = eul2dcm(Eul(1,:)*D2R);         % initial attitude from Euler
+Ro = eye(3);                        % set to pointing north, wings level
+Bhat = zeros(3,1);                  % gyro biases
+
+GscaleFactor = (1/250)*(2^15-1);    % conversion from deg/s to counts
+Eul_hat = zeros(npts,3);
+Bhat_vec = zeros(npts,3);
+R = Ro;
+
+for i=1:npts,
+    [Rplus,Bplus] = IntegrateClosedLoop(R,Bhat, (1/GscaleFactor)*wGyro(i,:)'*D2R, Mag(i,:)', Acc(i,:)', He, Ge, dT);
+    Eul_hat(i,:) = [atan2(R(1,2),R(1,1)) ...
+                   -asin(R(1,3)) ...
+                    atan2(R(2,3),R(3,3))]*180/pi;   % yaw pitch roll (deg)
+    Bhat_vec(i,:) = Bhat';
+    R = Rplus;
+    Bhat = Bplus;
+end
+
+
+
+figure(1), clf
+plot(Tvec,Eul,'-',Tvec,Eul_hat,'--')
+xlabel('Time [s]'), ylabel('Euler Angles [deg]')
+legend('\psi_{true}','\theta_{true}','\phi_{true}','\psi_{est}','\theta_{est}','\phi_{est}');
+title('Euler Angles (true) and Estimated in [deg]');
+
+cvg = find(Tvec > 15);
+Yaw_error = Eul(cvg,1)-Eul_hat(cvg,1);
+idx = find(abs(Yaw_error) < 340);
+Yaw_error = Yaw_error(idx);
+Tyaw = Tvec(cvg);
+Tyaw = Tyaw(idx);
+Pitch_error = Eul(cvg,2)-Eul_hat(cvg,2);
+idx = find(abs(Pitch_error) < 340);
+Pitch_error = Pitch_error(idx);
+Tpitch = Tvec(cvg);
+Tpitch = Tpitch(idx);
+Roll_error = Eul(cvg,3)-Eul_hat(cvg,3);
+idx = find(abs(Roll_error) < 340);
+Roll_error = Roll_error(idx);
+Troll = Tvec(cvg);
+Troll = Troll(idx);
+    figure(2), clf
+    subplot(311), plot(Tyaw,Yaw_error,'b');
+    ax=axis; hold on
+    plot(Tvec(1:cvg-1),Eul(1:cvg-1,1)-Eul_hat(1:cvg-1,1),'r');
+    axis([0 ax(2:4)]);
+    ylabel('\psi error ^\circ')
+    title('Errors between Estimated and True Euler Angles');
+    
+    subplot(312), plot(Tpitch,Pitch_error,'b');
+    ax=axis; hold on
+    plot(Tvec(1:cvg-1),Eul(1:cvg-1,2)-Eul_hat(1:cvg-1,2),'r');
+    axis([0 ax(2:4)]);
+    ylabel('\theta error ^\circ')
+    
+    subplot(313), plot(Troll,Roll_error);
+    ax=axis; hold on
+    plot(Tvec(1:cvg-1),Eul(1:cvg-1,3)-Eul_hat(1:cvg-1,3),'r');
+    axis([0 ax(2:4)]);
+    ylabel('\phi error ^\circ'), xlabel('Time [sec]')
+
+figure(3), clf
+subplot(221), histfit(Pitch_error);
+ylabel('Frequency'), title(['Yaw: \mu = ',num2str(mean(Yaw_error)),' \sigma =',num2str(std(Yaw_error)),' [deg]']);
+subplot(222), histfit(Pitch_error);
+title(['Pitch: \mu = ',num2str(mean(Pitch_error)),' \sigma =',num2str(std(Pitch_error)),' [deg]']);
+subplot(223), histfit(Roll_error);
+ylabel('Frequency'), xlabel('Error [deg]'), title(['Roll: \mu = ',num2str(mean(Roll_error)),' \sigma =',num2str(std(Roll_error)),' [deg]']);
+subplot(224), histfit(Yaw_error); hold on
+histfit(Pitch_error);
+xlabel('Error [deg]');
+histfit(Roll_error);
+
+figure(4), clf
+plot(Tvec,Bhat_vec*180/pi);
+ylabel('Gyro biases [deg/s]'), xlabel('Time [sec]');
+title('Gyro bias estimates vs time');
+
+PrettyPlotAttitudeData(dT,Acc,Mag,wGyro,Eul);
+
+function C=eul2dcm(eul)
+%----------------------------------------------------------------
+% function C=eul2dcm(eul)
+%
+%   This functions determines the direction cosine matrix C
+%   that transforms a vector in a reference axis system at time k
+%   to one the same axis sytem at time k+1.  The input argument to
+%   this function is a vector of the Euler angles in the following
+%   order: eul = [yaw,pitch,roll]. (i.e., 3-2-1 rotation convention).  
+%
+%-----------------------------------------------------------------  
+
+ps=eul(1); th=eul(2); ph=eul(3);
+
+C1=[1 0 0; 0 cos(ph) sin(ph); 0 -sin(ph) cos(ph)];
+C2=[cos(th) 0 -sin(th); 0 1 0; sin(th) 0 cos(th)];
+C3=[cos(ps) sin(ps) 0; -sin(ps) cos(ps) 0; 0 0 1];
+
+C=C1*C2*C3;
+end
diff --git a/matlab/Lab4/AttitudeEstLab/TestTriad.m b/matlab/Lab4/AttitudeEstLab/TestTriad.m
new file mode 100644
index 0000000..4df81c7
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/TestTriad.m
@@ -0,0 +1,17 @@
+Ro=eye(3);
+angleX = deg2rad(randn(1));
+angleY = deg2rad(randn(1));
+angleZ = deg2rad(randn(1));
+rotX=[1 0 0; 0 cos(angleX) -sin(angleX); 0 sin(angleX) cos(angleX)];
+rotY=[cos(angleY) 0 sin(angleY); 0 1 0; -sin(angleY) 0 cos(angleY)];
+rotZ=[cos(angleZ) -sin(angleZ) 0; sin(angleZ) cos(angleZ) 0; 0 0 1];
+Ro=rotX*rotY*rotZ;
+
+accelInertial=[0;0;-1];
+accelReading=Ro*[0;0;-1];
+magInertial=[1;0;0];
+magReading=Ro*[1;0;0];
+
+R = DCMfromTriad(magReading,accelReading,magInertial,accelInertial);
+
+R-Ro
\ No newline at end of file
diff --git a/matlab/Lab4/AttitudeEstLab/rcross.m b/matlab/Lab4/AttitudeEstLab/rcross.m
new file mode 100644
index 0000000..f651153
--- /dev/null
+++ b/matlab/Lab4/AttitudeEstLab/rcross.m
@@ -0,0 +1,7 @@
+function rx = rcross(r)
+% function rx = rcross(r)
+% forms the skew symmetric x-product matrix of a 3x1 vector
+rx=[0    -r(3)  r(2);
+    r(3)  0    -r(1);
+   -r(2)  r(1)  0];
+end
\ No newline at end of file
diff --git a/matlab/Lab4/BatchMisalignment/AlignMasterSlave.m b/matlab/Lab4/BatchMisalignment/AlignMasterSlave.m
new file mode 100644
index 0000000..453a44f
--- /dev/null
+++ b/matlab/Lab4/BatchMisalignment/AlignMasterSlave.m
@@ -0,0 +1,99 @@
+function [Rmis, Pbody] = AlignMasterSlave(Mb,Sbmeas,mi,si,Rmishat_0,i);
+% function [Rmis, Pbody] = AlignMasterSlave(Mb,Sbmeas,mi,si,Rmishat_0,i);
+%
+% function generates the misalignment matrix to bring the slave sensor
+% triad into perfect alignment with the the master triad. Solution based on
+% Markley's SVD solution to Whaba's problem.
+%
+% Inputs:
+%         Mb - 3xn matrix of body master measurements
+%         Sbmeas - 3xn matrix of body slave measurements
+%         mi - master unit vector in inertial coordinates
+%         si - slave unit vector in inertial coordinates
+%         i - optional number of iterations
+%
+% Outputs:
+%         Rmis - misalignment DCM such that Rmis'*Sbmeas = Sb
+%
+tol = 1e-15;
+createPlot = 0;
+animatePlot = 0;
+verbose = 1;
+Delta = [];
+
+mi = mi/norm(mi);
+si = si/norm(si);
+Mb = colnorm(Mb);
+Sbmeas = colnorm(Sbmeas);
+
+Rmishat_old = zeros(3,3);
+
+if (nargin < 5),
+    Rmishat = eye(3);
+else
+    Rmishat = Rmishat_0;
+end
+%Rmishat = eye(3);
+%Rmishat = [0 1 0;-1 0 0;0 0 1];
+%Rmishat = [0 0 1;1 0 0;0 1 0];
+if (nargin ==6), num2iter = i;
+else num2iter = 1000;
+end
+
+for iter = 1:num2iter,
+    if verbose,
+        fprintf('(%g)',iter);
+    end
+    Sbhat = Rmishat' * Sbmeas;
+    Sihat = [];
+    [m,n]=size(Mb);
+    for i = 1:n,
+        Ri = whabaSVD([mi si],[Mb(:,i) Sbhat(:,i)]);
+        Sihat(:,i) = Ri*si;
+    end
+    Rmishat_old = Rmishat;
+    Rmishat = whabaSVD(Sihat,Sbmeas);
+    if (animatePlot && ((iter < 200)||(rem(iter,5)==0))),
+        Sbmis = Rmishat' * Sbmeas;
+        v = extractAxis(Rmishat');      
+        figure(1);
+        plot3(Sbmis(1,:),Sbmis(2,:),Sbmis(3,:),'b.');
+        quiver3(0,0,0,-v(1),-v(2),-v(3),0,'c','filled');
+    end
+
+    Delta(iter) = norm(Rmishat - Rmishat_old,'fro');
+    if (norm(Rmishat - Rmishat_old,'fro') < tol), 
+        break; 
+    end
+    if verbose && (rem(iter,5)==0),
+        fprintf(' Delta: %g\n',norm(Rmishat - Rmishat_old,'fro'));
+        fprintf('\n\n');
+        disp(Rmishat);
+    end;
+end
+
+Rmis = Rmishat;
+
+if (createPlot),
+    figure(2);
+    semilogy([1:length(Delta)]',Delta','k+');
+    grid on
+    title('Frobenius norm of $$\hat{\mathcal{R}^k}_{mis} - \hat{\mathcal{R}^{k-1}}_{mis}$$',...
+          'interpreter','latex')
+    xlabel('Iterations'), ylabel('log(Norm)');
+end
+
+if (nargout == 2),
+    [Rmis,Pbody] = whabaSVD(Sihat,Sbmeas);
+end
+end
+
+
+function An = colnorm(A);
+% function An = colnorm(A)
+%
+% makes every column in A have a unit norm
+[n,m]=size(A);
+den = ones(n,1)*sqrt(sum(A.*A,1));
+An = A./den;
+end
\ No newline at end of file
diff --git a/matlab/Lab4/BatchMisalignment/MisalignmentTestCode.m b/matlab/Lab4/BatchMisalignment/MisalignmentTestCode.m
new file mode 100644
index 0000000..10928f5
--- /dev/null
+++ b/matlab/Lab4/BatchMisalignment/MisalignmentTestCode.m
@@ -0,0 +1,78 @@
+%%
+% m-file to simulate multivector alignment algorithm
+%
+% Gabriel H Elkaim - July 2012
+%
+clc
+close all
+clear
+
+addnoise = 1;   % change to a one to add noise to measurements
+sigman = 0.01;  % sigma relative to unit length vector measurement
+plotflag = 1;
+verbose = 1;
+
+%% m-file to generate points for misaligned data
+n = 4;                            % number of points to generate
+rotvec = 2*pi*0.03*(randn(3,1));    % small misalignment (change 0.05 to 1 for large misalignment
+Rmis = expm(skew(rotvec));         % misalignment DCM
+mi = rand(3,1)-0.5;
+mi = mi/norm(mi);
+si = rand(3,1)-0.5;
+si = si/norm(si);
+%si = mi;          % uncomment this line to test mutliple of the same sensors
+
+Mb = [];
+Sb = [];
+
+for i = 1:n,
+    Ri = expm(skew((randn(3,1))*2*pi));
+    Mb(:,i) = Ri*mi;
+    Sb(:,i) = Ri*si;
+end
+Mbn = sigman*randn(size(Mb));
+Sbn = sigman*randn(size(Sb));
+Sbmeas = Rmis*Sb;
+
+%% Plot out points
+if plotflag,
+    figure(1); clf;
+    quiver3(0*Mb(1,:),0*Mb(2,:),0*Mb(3,:),Mb(1,:),Mb(2,:),Mb(3,:),0,'k'); hold on
+    axis([-1 1 -1 1 -1 1]);
+    quiver3(0*Sb(1,:),0*Sb(2,:),0*Sb(3,:),Sb(1,:),Sb(2,:),Sb(3,:),0,'b');
+    quiver3(0*Sbmeas(1,:),0*Sbmeas(2,:),0*Sbmeas(3,:),Sbmeas(1,:),Sbmeas(2,:),Sbmeas(3,:),0,'g--');
+    quiver3([0 0],[0 0],[0 0],[mi(1) si(1)],[mi(2) si(2)],[mi(3) si(3)],0,'r');
+    v = extractAxis(Rmis);
+    quiver3(0,0,0,v(1),v(2),v(3),0,'r:','filled');
+
+    if addnoise,
+        Mbb = (Mb+Mbn)';
+        Sbb = (Sbmeas + Sbn)';
+        plot3(Mbb(:,1),Mbb(:,2),Mbb(:,3),'kv');
+        plot3(Sbb(:,1),Sbb(:,2),Sbb(:,3),'gv');
+    end
+        
+    nsteps = 300;
+    for alfa = [1/nsteps:1/nsteps:(1-1/nsteps)],
+        Sbmis = expm(skew(alfa*rotvec))*Sb;
+        plot3(Sbmis(1,:),Sbmis(2,:),Sbmis(3,:),'g.');
+    end
+   
+    axis('equal');
+end
+%% Call Elkaim Code
+[Rge,Pge] = AlignMasterSlave(Mb+addnoise*Mbn,Sbmeas+addnoise*Sbn,mi,si,eye(3));
+if verbose,
+    fprintf('\nMisalignment Results:');
+    Rmis-Rge
+    norm(Rmis(:)-Rge(:))
+    Pbody = (0.01)^2*Pge
+end
+
+if(plotflag),
+    figure(1)
+    v = extractAxis(Rmis);
+    quiver3(0,0,0,v(1),v(2),v(3),0,'r','LineWidth',2);
+end
+
+
diff --git a/matlab/Lab4/BatchMisalignment/extractAxis.m b/matlab/Lab4/BatchMisalignment/extractAxis.m
new file mode 100644
index 0000000..393f534
--- /dev/null
+++ b/matlab/Lab4/BatchMisalignment/extractAxis.m
@@ -0,0 +1,12 @@
+function [lambda,phi] = extractAxis(R)
+% function lambda = extractAxis(R)
+%
+% this function extracts the axis and angle from a rotation matrix
+% uses the property that lambda-x = (R - R')
+%                                   --------
+%                                   2 sin Phi
+phi = acos((trace(R)-1)/2);
+lx = (R-R')/(2*sin(phi));
+lambda = [lx(3,2);
+          lx(1,3);
+          lx(2,1)];
\ No newline at end of file
diff --git a/matlab/Lab4/BatchMisalignment/skew.m b/matlab/Lab4/BatchMisalignment/skew.m
new file mode 100644
index 0000000..f38fd50
--- /dev/null
+++ b/matlab/Lab4/BatchMisalignment/skew.m
@@ -0,0 +1,13 @@
+function v_x = skew (v)
+%v_x = skew (v)
+%
+%Obtem a matriz skew-simmetric correspondente ao produto
+%externo a partir de v
+%Recebe: v - vector (3x1)
+%Devolve: v_x=[0     -v(3)     v(2);
+%              v(3)    0      -v(1);
+%             -v(2)   v(1)       0];
+
+v_x=[0     -v(3)     v(2);
+     v(3)    0      -v(1);
+    -v(2)   v(1)       0];
\ No newline at end of file
diff --git a/matlab/Lab4/BatchMisalignment/whabaSVD.m b/matlab/Lab4/BatchMisalignment/whabaSVD.m
new file mode 100644
index 0000000..b329707
--- /dev/null
+++ b/matlab/Lab4/BatchMisalignment/whabaSVD.m
@@ -0,0 +1,40 @@
+function [R_est, Pbody] = whabaSVD(B_v,E_v,w)
+% function R_est = whabaSVD(B_v,E_v,w)
+%
+% computes the optimal rotation matrix to minimize the cost function of
+% J = 1/2 * Sum (w_i * |E_v - R*B_v|^2)
+% using the SVD decomposition
+%
+% w is the 1xn weight vector.
+% B_v and E_v are 3xn matrices that pack the vector readings
+% B_v and E_v must be normalized
+%
+% if the function is called with only two arguments, w is equally weighted
+% such that sum(w) = 1.
+%
+if (nargin < 3),
+    [n,m] = size(B_v);
+    w = ones(m,1)/m;
+end
+
+[m,n]=size(B_v);
+if (m ~=3), error('B_v needs to be 3xn matrix of vector measurements'); end
+[j,k]=size(E_v);
+if (j ~=3), error('E_v needs to be 3xn matrix of vector measurements'); end
+if (n ~= k), error('B_v and E_v need to have the same number of columns'); end
+
+W = [w';w';w'];
+B = (B_v.*W)*E_v';
+[U,S,V]=svd(B);
+R_est = (U*diag([1 1 det(U)*det(V)])*V')';
+
+if (nargout == 2),
+    d = det(U)*det(V);
+    s1 = S(1,1);
+    s2 = S(2,2);
+    s3 = S(3,3);
+    Pz = diag([(1-s1)/(s2-d*s3)^2 (1-s2)/(s1+d*s3)^2 (1-s3)/(s1+s2)^2]);
+    Pbody = V*Pz*V';
+end
+
+
