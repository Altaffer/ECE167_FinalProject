diff --git a/bootloader320.ld b/bootloader320.ld
new file mode 100644
index 0000000000000000000000000000000000000000..41b10ea2c7e1eed3332a22a5bb75e1b189d9659f
--- /dev/null
+++ b/bootloader320.ld
@@ -0,0 +1,740 @@
+/* Default linker script, for normal executables */
+OUTPUT_FORMAT("elf32-tradlittlemips")
+OUTPUT_ARCH(pic32mx)
+ENTRY(_reset)
+/*
+ * Provide for a minimum stack and heap size
+ * - _min_stack_size - represents the minimum space that must be made
+ *                     available for the stack.  Can be overridden from
+ *                     the command line using the linker's --defsym option.
+ * - _min_heap_size  - represents the minimum space that must be made
+ *                     available for the heap.  Can be overridden from
+ *                     the command line using the linker's --defsym option.
+ */
+EXTERN (_min_stack_size _min_heap_size)
+PROVIDE(_min_stack_size = 0x400) ;
+/* PROVIDE(_min_heap_size = 0) ; Defined on the command line */
+/*************************************************************************
+ * Processor-specific object file.  Contains SFR definitions.
+ *************************************************************************/
+INPUT("processor.o")
+
+/*************************************************************************
+ * Processor-specific peripheral libraries are optional
+ *************************************************************************/
+OPTIONAL("libmchp_peripheral.a")
+OPTIONAL("libmchp_peripheral_32MX320F128H.a")
+
+/*************************************************************************
+ * For interrupt vector handling
+ *************************************************************************/
+PROVIDE(_vector_spacing = 0x00000001);
+_ebase_address = 0x9D001000;
+
+/*************************************************************************
+ * Memory Address Equates
+ * _RESET_ADDR      -- Reset Vector
+ * _BEV_EXCPT_ADDR  -- Boot exception Vector
+ * _DBG_EXCPT_ADDR  -- In-circuit Debugging Exception Vector
+ * _DBG_CODE_ADDR   -- In-circuit Debug Executive address
+ * _DBG_CODE_SIZE   -- In-circuit Debug Executive size
+ * _GEN_EXCPT_ADDR  -- General Exception Vector
+ *************************************************************************/
+_RESET_ADDR              = 0xBD000000;
+_BEV_EXCPT_ADDR          = 0xBD000380;
+_DBG_EXCPT_ADDR          = 0xBD000480;
+_DBG_CODE_ADDR           = 0xBFC02000;
+_DBG_CODE_SIZE           = 0xFF0     ;
+_GEN_EXCPT_ADDR          = _ebase_address + 0x180;
+
+/*************************************************************************
+ * Memory Regions
+ *
+ * Memory regions without attributes cannot be used for orphaned sections.
+ * Only sections specifically assigned to these regions can be allocated
+ * into these regions.
+ *************************************************************************/
+MEMORY
+{
+  kseg0_program_mem    (rx)  : ORIGIN = 0x9D002000, LENGTH = 0x1d000
+  kseg0_boot_mem             : ORIGIN = 0x9D000490, LENGTH = 0x970
+  exception_mem              : ORIGIN = 0x9D001000, LENGTH = 0x1000
+  kseg1_boot_mem             : ORIGIN = 0xBD000000, LENGTH = 0x490
+  debug_exec_mem             : ORIGIN = 0xBFC02000, LENGTH = 0xFF0
+  config3                    : ORIGIN = 0xBFC02FF0, LENGTH = 0x4
+  config2                    : ORIGIN = 0xBFC02FF4, LENGTH = 0x4
+  config1                    : ORIGIN = 0xBFC02FF8, LENGTH = 0x4
+  config0                    : ORIGIN = 0xBFC02FFC, LENGTH = 0x4
+  kseg1_data_mem       (w!x) : ORIGIN = 0xA0000000, LENGTH = 0x4000
+  sfrs                       : ORIGIN = 0xBF800000, LENGTH = 0x100000
+  configsfrs                 : ORIGIN = 0xBFC02FF0, LENGTH = 0x10
+}
+
+/*************************************************************************
+ * Configuration-word sections
+ *************************************************************************/
+SECTIONS
+{
+  .config_BFC02FF0 : {
+    KEEP(*(.config_BFC02FF0))
+  } > config3
+  .config_BFC02FF4 : {
+    KEEP(*(.config_BFC02FF4))
+  } > config2
+  .config_BFC02FF8 : {
+    KEEP(*(.config_BFC02FF8))
+  } > config1
+  .config_BFC02FFC : {
+    KEEP(*(.config_BFC02FFC))
+  } > config0
+}
+PROVIDE(_DBG_CODE_ADDR = 0xBFC02000) ;
+PROVIDE(_DBG_CODE_SIZE = 0xFF0) ;
+SECTIONS
+{
+  /* Boot Sections */
+  .reset _RESET_ADDR :
+  {
+    KEEP(*(.reset))
+    KEEP(*(.reset.startup))
+  } > kseg1_boot_mem
+  .bev_excpt _BEV_EXCPT_ADDR :
+  {
+    KEEP(*(.bev_handler))
+  } > kseg1_boot_mem
+  .dbg_excpt _DBG_EXCPT_ADDR (NOLOAD) :
+  {
+    . += (DEFINED (_DEBUGGER) ? 0x8 : 0x0);
+  } > kseg1_boot_mem
+  .dbg_code _DBG_CODE_ADDR (NOLOAD) :
+  {
+    . += (DEFINED (_DEBUGGER) ? _DBG_CODE_SIZE : 0x0);
+  } > debug_exec_mem
+  .app_excpt _GEN_EXCPT_ADDR :
+  {
+    KEEP(*(.gen_handler))
+  } > exception_mem
+  .vector_0 _ebase_address + 0x200 :
+  {
+    KEEP(*(.vector_0))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_0) <= (_vector_spacing << 5), "function at exception vector 0 too large")
+  .vector_1 _ebase_address + 0x200 + (_vector_spacing << 5) * 1 :
+  {
+    KEEP(*(.vector_1))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_1) <= (_vector_spacing << 5), "function at exception vector 1 too large")
+  .vector_2 _ebase_address + 0x200 + (_vector_spacing << 5) * 2 :
+  {
+    KEEP(*(.vector_2))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_2) <= (_vector_spacing << 5), "function at exception vector 2 too large")
+  .vector_3 _ebase_address + 0x200 + (_vector_spacing << 5) * 3 :
+  {
+    KEEP(*(.vector_3))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_3) <= (_vector_spacing << 5), "function at exception vector 3 too large")
+  .vector_4 _ebase_address + 0x200 + (_vector_spacing << 5) * 4 :
+  {
+    KEEP(*(.vector_4))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_4) <= (_vector_spacing << 5), "function at exception vector 4 too large")
+  .vector_5 _ebase_address + 0x200 + (_vector_spacing << 5) * 5 :
+  {
+    KEEP(*(.vector_5))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_5) <= (_vector_spacing << 5), "function at exception vector 5 too large")
+  .vector_6 _ebase_address + 0x200 + (_vector_spacing << 5) * 6 :
+  {
+    KEEP(*(.vector_6))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_6) <= (_vector_spacing << 5), "function at exception vector 6 too large")
+  .vector_7 _ebase_address + 0x200 + (_vector_spacing << 5) * 7 :
+  {
+    KEEP(*(.vector_7))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_7) <= (_vector_spacing << 5), "function at exception vector 7 too large")
+  .vector_8 _ebase_address + 0x200 + (_vector_spacing << 5) * 8 :
+  {
+    KEEP(*(.vector_8))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_8) <= (_vector_spacing << 5), "function at exception vector 8 too large")
+  .vector_9 _ebase_address + 0x200 + (_vector_spacing << 5) * 9 :
+  {
+    KEEP(*(.vector_9))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_9) <= (_vector_spacing << 5), "function at exception vector 9 too large")
+  .vector_10 _ebase_address + 0x200 + (_vector_spacing << 5) * 10 :
+  {
+    KEEP(*(.vector_10))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_10) <= (_vector_spacing << 5), "function at exception vector 10 too large")
+  .vector_11 _ebase_address + 0x200 + (_vector_spacing << 5) * 11 :
+  {
+    KEEP(*(.vector_11))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_11) <= (_vector_spacing << 5), "function at exception vector 11 too large")
+  .vector_12 _ebase_address + 0x200 + (_vector_spacing << 5) * 12 :
+  {
+    KEEP(*(.vector_12))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_12) <= (_vector_spacing << 5), "function at exception vector 12 too large")
+  .vector_13 _ebase_address + 0x200 + (_vector_spacing << 5) * 13 :
+  {
+    KEEP(*(.vector_13))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_13) <= (_vector_spacing << 5), "function at exception vector 13 too large")
+  .vector_14 _ebase_address + 0x200 + (_vector_spacing << 5) * 14 :
+  {
+    KEEP(*(.vector_14))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_14) <= (_vector_spacing << 5), "function at exception vector 14 too large")
+  .vector_15 _ebase_address + 0x200 + (_vector_spacing << 5) * 15 :
+  {
+    KEEP(*(.vector_15))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_15) <= (_vector_spacing << 5), "function at exception vector 15 too large")
+  .vector_16 _ebase_address + 0x200 + (_vector_spacing << 5) * 16 :
+  {
+    KEEP(*(.vector_16))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_16) <= (_vector_spacing << 5), "function at exception vector 16 too large")
+  .vector_17 _ebase_address + 0x200 + (_vector_spacing << 5) * 17 :
+  {
+    KEEP(*(.vector_17))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_17) <= (_vector_spacing << 5), "function at exception vector 17 too large")
+  .vector_18 _ebase_address + 0x200 + (_vector_spacing << 5) * 18 :
+  {
+    KEEP(*(.vector_18))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_18) <= (_vector_spacing << 5), "function at exception vector 18 too large")
+  .vector_19 _ebase_address + 0x200 + (_vector_spacing << 5) * 19 :
+  {
+    KEEP(*(.vector_19))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_19) <= (_vector_spacing << 5), "function at exception vector 19 too large")
+  .vector_20 _ebase_address + 0x200 + (_vector_spacing << 5) * 20 :
+  {
+    KEEP(*(.vector_20))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_20) <= (_vector_spacing << 5), "function at exception vector 20 too large")
+  .vector_21 _ebase_address + 0x200 + (_vector_spacing << 5) * 21 :
+  {
+    KEEP(*(.vector_21))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_21) <= (_vector_spacing << 5), "function at exception vector 21 too large")
+  .vector_22 _ebase_address + 0x200 + (_vector_spacing << 5) * 22 :
+  {
+    KEEP(*(.vector_22))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_22) <= (_vector_spacing << 5), "function at exception vector 22 too large")
+  .vector_23 _ebase_address + 0x200 + (_vector_spacing << 5) * 23 :
+  {
+    KEEP(*(.vector_23))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_23) <= (_vector_spacing << 5), "function at exception vector 23 too large")
+  .vector_24 _ebase_address + 0x200 + (_vector_spacing << 5) * 24 :
+  {
+    KEEP(*(.vector_24))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_24) <= (_vector_spacing << 5), "function at exception vector 24 too large")
+  .vector_25 _ebase_address + 0x200 + (_vector_spacing << 5) * 25 :
+  {
+    KEEP(*(.vector_25))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_25) <= (_vector_spacing << 5), "function at exception vector 25 too large")
+  .vector_26 _ebase_address + 0x200 + (_vector_spacing << 5) * 26 :
+  {
+    KEEP(*(.vector_26))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_26) <= (_vector_spacing << 5), "function at exception vector 26 too large")
+  .vector_27 _ebase_address + 0x200 + (_vector_spacing << 5) * 27 :
+  {
+    KEEP(*(.vector_27))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_27) <= (_vector_spacing << 5), "function at exception vector 27 too large")
+  .vector_28 _ebase_address + 0x200 + (_vector_spacing << 5) * 28 :
+  {
+    KEEP(*(.vector_28))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_28) <= (_vector_spacing << 5), "function at exception vector 28 too large")
+  .vector_29 _ebase_address + 0x200 + (_vector_spacing << 5) * 29 :
+  {
+    KEEP(*(.vector_29))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_29) <= (_vector_spacing << 5), "function at exception vector 29 too large")
+  .vector_30 _ebase_address + 0x200 + (_vector_spacing << 5) * 30 :
+  {
+    KEEP(*(.vector_30))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_30) <= (_vector_spacing << 5), "function at exception vector 30 too large")
+  .vector_31 _ebase_address + 0x200 + (_vector_spacing << 5) * 31 :
+  {
+    KEEP(*(.vector_31))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_31) <= (_vector_spacing << 5), "function at exception vector 31 too large")
+  .vector_32 _ebase_address + 0x200 + (_vector_spacing << 5) * 32 :
+  {
+    KEEP(*(.vector_32))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_32) <= (_vector_spacing << 5), "function at exception vector 32 too large")
+  .vector_33 _ebase_address + 0x200 + (_vector_spacing << 5) * 33 :
+  {
+    KEEP(*(.vector_33))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_33) <= (_vector_spacing << 5), "function at exception vector 33 too large")
+  .vector_34 _ebase_address + 0x200 + (_vector_spacing << 5) * 34 :
+  {
+    KEEP(*(.vector_34))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_34) <= (_vector_spacing << 5), "function at exception vector 34 too large")
+  .vector_35 _ebase_address + 0x200 + (_vector_spacing << 5) * 35 :
+  {
+    KEEP(*(.vector_35))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_35) <= (_vector_spacing << 5), "function at exception vector 35 too large")
+  .vector_36 _ebase_address + 0x200 + (_vector_spacing << 5) * 36 :
+  {
+    KEEP(*(.vector_36))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_36) <= (_vector_spacing << 5), "function at exception vector 36 too large")
+  .vector_37 _ebase_address + 0x200 + (_vector_spacing << 5) * 37 :
+  {
+    KEEP(*(.vector_37))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_37) <= (_vector_spacing << 5), "function at exception vector 37 too large")
+  .vector_38 _ebase_address + 0x200 + (_vector_spacing << 5) * 38 :
+  {
+    KEEP(*(.vector_38))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_38) <= (_vector_spacing << 5), "function at exception vector 38 too large")
+  .vector_39 _ebase_address + 0x200 + (_vector_spacing << 5) * 39 :
+  {
+    KEEP(*(.vector_39))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_39) <= (_vector_spacing << 5), "function at exception vector 39 too large")
+  .vector_40 _ebase_address + 0x200 + (_vector_spacing << 5) * 40 :
+  {
+    KEEP(*(.vector_40))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_40) <= (_vector_spacing << 5), "function at exception vector 40 too large")
+  .vector_41 _ebase_address + 0x200 + (_vector_spacing << 5) * 41 :
+  {
+    KEEP(*(.vector_41))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_41) <= (_vector_spacing << 5), "function at exception vector 41 too large")
+  .vector_42 _ebase_address + 0x200 + (_vector_spacing << 5) * 42 :
+  {
+    KEEP(*(.vector_42))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_42) <= (_vector_spacing << 5), "function at exception vector 42 too large")
+  .vector_43 _ebase_address + 0x200 + (_vector_spacing << 5) * 43 :
+  {
+    KEEP(*(.vector_43))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_43) <= (_vector_spacing << 5), "function at exception vector 43 too large")
+  .vector_44 _ebase_address + 0x200 + (_vector_spacing << 5) * 44 :
+  {
+    KEEP(*(.vector_44))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_44) <= (_vector_spacing << 5), "function at exception vector 44 too large")
+  .vector_45 _ebase_address + 0x200 + (_vector_spacing << 5) * 45 :
+  {
+    KEEP(*(.vector_45))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_45) <= (_vector_spacing << 5), "function at exception vector 45 too large")
+  .vector_46 _ebase_address + 0x200 + (_vector_spacing << 5) * 46 :
+  {
+    KEEP(*(.vector_46))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_46) <= (_vector_spacing << 5), "function at exception vector 46 too large")
+  .vector_47 _ebase_address + 0x200 + (_vector_spacing << 5) * 47 :
+  {
+    KEEP(*(.vector_47))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_47) <= (_vector_spacing << 5), "function at exception vector 47 too large")
+  .vector_48 _ebase_address + 0x200 + (_vector_spacing << 5) * 48 :
+  {
+    KEEP(*(.vector_48))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_48) <= (_vector_spacing << 5), "function at exception vector 48 too large")
+  .vector_49 _ebase_address + 0x200 + (_vector_spacing << 5) * 49 :
+  {
+    KEEP(*(.vector_49))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_49) <= (_vector_spacing << 5), "function at exception vector 49 too large")
+  .vector_50 _ebase_address + 0x200 + (_vector_spacing << 5) * 50 :
+  {
+    KEEP(*(.vector_50))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_50) <= (_vector_spacing << 5), "function at exception vector 50 too large")
+  .vector_51 _ebase_address + 0x200 + (_vector_spacing << 5) * 51 :
+  {
+    KEEP(*(.vector_51))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_51) <= (_vector_spacing << 5), "function at exception vector 51 too large")
+  .vector_52 _ebase_address + 0x200 + (_vector_spacing << 5) * 52 :
+  {
+    KEEP(*(.vector_52))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_52) <= (_vector_spacing << 5), "function at exception vector 52 too large")
+  .vector_53 _ebase_address + 0x200 + (_vector_spacing << 5) * 53 :
+  {
+    KEEP(*(.vector_53))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_53) <= (_vector_spacing << 5), "function at exception vector 53 too large")
+  .vector_54 _ebase_address + 0x200 + (_vector_spacing << 5) * 54 :
+  {
+    KEEP(*(.vector_54))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_54) <= (_vector_spacing << 5), "function at exception vector 54 too large")
+  .vector_55 _ebase_address + 0x200 + (_vector_spacing << 5) * 55 :
+  {
+    KEEP(*(.vector_55))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_55) <= (_vector_spacing << 5), "function at exception vector 55 too large")
+  .vector_56 _ebase_address + 0x200 + (_vector_spacing << 5) * 56 :
+  {
+    KEEP(*(.vector_56))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_56) <= (_vector_spacing << 5), "function at exception vector 56 too large")
+  .vector_57 _ebase_address + 0x200 + (_vector_spacing << 5) * 57 :
+  {
+    KEEP(*(.vector_57))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_57) <= (_vector_spacing << 5), "function at exception vector 57 too large")
+  .vector_58 _ebase_address + 0x200 + (_vector_spacing << 5) * 58 :
+  {
+    KEEP(*(.vector_58))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_58) <= (_vector_spacing << 5), "function at exception vector 58 too large")
+  .vector_59 _ebase_address + 0x200 + (_vector_spacing << 5) * 59 :
+  {
+    KEEP(*(.vector_59))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_59) <= (_vector_spacing << 5), "function at exception vector 59 too large")
+  .vector_60 _ebase_address + 0x200 + (_vector_spacing << 5) * 60 :
+  {
+    KEEP(*(.vector_60))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_60) <= (_vector_spacing << 5), "function at exception vector 60 too large")
+  .vector_61 _ebase_address + 0x200 + (_vector_spacing << 5) * 61 :
+  {
+    KEEP(*(.vector_61))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_61) <= (_vector_spacing << 5), "function at exception vector 61 too large")
+  .vector_62 _ebase_address + 0x200 + (_vector_spacing << 5) * 62 :
+  {
+    KEEP(*(.vector_62))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_62) <= (_vector_spacing << 5), "function at exception vector 62 too large")
+  .vector_63 _ebase_address + 0x200 + (_vector_spacing << 5) * 63 :
+  {
+    KEEP(*(.vector_63))
+  } > exception_mem
+  ASSERT (_vector_spacing == 0 || SIZEOF(.vector_63) <= (_vector_spacing << 5), "function at exception vector 63 too large")
+  /*  Starting with C32 v2.00, the startup code is in the .reset.startup section.
+   *  Keep this here for backwards compatibility.
+   */
+  .startup ORIGIN(kseg0_boot_mem) :
+  {
+    KEEP(*(.startup))
+  } > kseg0_boot_mem
+  /* Code Sections - Note that input sections *(.text) and *(.text.*)
+  ** are not mapped here. Starting in C32 v2.00, the best-fit allocator
+  ** locates them, so that .text may flow around absolute sections
+  ** as needed.
+  */
+  .text :
+  {
+    *(.stub .gnu.linkonce.t.*)
+    KEEP (*(.text.*personality*))
+    *(.mips16.fn.*)
+    *(.mips16.call.*)
+    *(.gnu.warning)
+    . = ALIGN(4) ;
+  } >kseg0_program_mem
+  /* Global-namespace object initialization */
+  .init   :
+  {
+    KEEP (*crti.o(.init))
+    KEEP (*crtbegin.o(.init))
+    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o *crtn.o ).init))
+    KEEP (*crtend.o(.init))
+    KEEP (*crtn.o(.init))
+    . = ALIGN(4) ;
+  } >kseg0_program_mem
+  .fini   :
+  {
+    KEEP (*(.fini))
+    . = ALIGN(4) ;
+  } >kseg0_program_mem
+  .preinit_array   :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    KEEP (*(.preinit_array))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+    . = ALIGN(4) ;
+  } >kseg0_program_mem
+  .init_array   :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    KEEP (*(SORT(.init_array.*)))
+    KEEP (*(.init_array))
+    PROVIDE_HIDDEN (__init_array_end = .);
+    . = ALIGN(4) ;
+  } >kseg0_program_mem
+  .fini_array   :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    KEEP (*(SORT(.fini_array.*)))
+    KEEP (*(.fini_array))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+    . = ALIGN(4) ;
+  } >kseg0_program_mem
+  .ctors   :
+  {
+    /* XC32 uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+    KEEP (*crtbegin.o(.ctors))
+    KEEP (*crtbegin?.o(.ctors))
+    /* We don't want to include the .ctor section from
+       the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    . = ALIGN(4) ;
+  } >kseg0_program_mem
+  .dtors   :
+  {
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*crtbegin?.o(.dtors))
+    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    . = ALIGN(4) ;
+  } >kseg0_program_mem
+  /* Read-only sections */
+  .rodata   :
+  {
+    *( .gnu.linkonce.r.*)
+    *(.rodata1)
+    . = ALIGN(4) ;
+  } >kseg0_program_mem
+  /*
+   * Small initialized constant global and static data can be placed in the
+   * .sdata2 section.  This is different from .sdata, which contains small
+   * initialized non-constant global and static data.
+   */
+  .sdata2 ALIGN(4) :
+  {
+    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)
+    . = ALIGN(4) ;
+  } >kseg0_program_mem
+  /*
+   * Uninitialized constant global and static data (i.e., variables which will
+   * always be zero).  Again, this is different from .sbss, which contains
+   * small non-initialized, non-constant global and static data.
+   */
+  .sbss2 ALIGN(4) :
+  {
+    *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)
+    . = ALIGN(4) ;
+  } >kseg0_program_mem
+  .eh_frame_hdr   :
+  {
+    *(.eh_frame_hdr)
+  } >kseg0_program_mem
+    . = ALIGN(4) ;
+  .eh_frame   : ONLY_IF_RO
+  {
+    KEEP (*(.eh_frame))
+  } >kseg0_program_mem
+    . = ALIGN(4) ;
+  .gcc_except_table   : ONLY_IF_RO
+  {
+    *(.gcc_except_table .gcc_except_table.*)
+  } >kseg0_program_mem
+    . = ALIGN(4) ;
+  .dbg_data (NOLOAD) :
+  {
+    . += (DEFINED (_DEBUGGER) ? 0x200 : 0x0);
+  } >kseg1_data_mem
+  .jcr   :
+  {
+    KEEP (*(.jcr))
+    . = ALIGN(4) ;
+  } >kseg1_data_mem
+  .eh_frame    : ONLY_IF_RW
+  {
+    KEEP (*(.eh_frame))
+  } >kseg1_data_mem
+    . = ALIGN(4) ;
+  .gcc_except_table    : ONLY_IF_RW
+  {
+    *(.gcc_except_table .gcc_except_table.*)
+  } >kseg1_data_mem
+    . = ALIGN(4) ;
+  /* Persistent data - Use the new C 'persistent' attribute instead. */
+  .persist   :
+  {
+    _persist_begin = .;
+    *(.persist .persist.*)
+    *(.pbss .pbss.*)
+    . = ALIGN(4) ;
+    _persist_end = .;
+  } >kseg1_data_mem
+  /*
+   * Note that input sections named .data* are no longer mapped here.
+   * Starting in C32 v2.00, the best-fit allocator locates them, so
+   * that they may flow around absolute sections as needed.
+   */
+  .data   :
+  {
+    *( .gnu.linkonce.d.*)
+    SORT(CONSTRUCTORS)
+    *(.data1)
+    . = ALIGN(4) ;
+  } >kseg1_data_mem
+  . = .;
+  _gp = ALIGN(16) + 0x7ff0;
+  .got ALIGN(4) :
+  {
+    *(.got.plt) *(.got)
+    . = ALIGN(4) ;
+  } >kseg1_data_mem /* AT>kseg0_program_mem */
+  /*
+   * Note that "small" data sections are still mapped in the linker
+   * script. This ensures that they are grouped together for
+   * gp-relative addressing. Absolute sections are allocated after
+   * the "small" data sections so small data cannot flow around them.
+   */
+  /*
+   * We want the small data sections together, so single-instruction offsets
+   * can access them all, and initialized data all before uninitialized, so
+   * we can shorten the on-disk segment size.
+   */
+  .sdata ALIGN(4) :
+  {
+    _sdata_begin = . ;
+    *(.sdata .sdata.* .gnu.linkonce.s.*)
+    . = ALIGN(4) ;
+    _sdata_end = . ;
+  } >kseg1_data_mem
+  .lit8           :
+  {
+    *(.lit8)
+  } >kseg1_data_mem
+  .lit4           :
+  {
+    *(.lit4)
+  } >kseg1_data_mem
+  . = ALIGN (4) ;
+  _data_end = . ;
+  _bss_begin = . ;
+  .sbss ALIGN(4) :
+  {
+    _sbss_begin = . ;
+    *(.dynsbss)
+    *(.sbss .sbss.* .gnu.linkonce.sb.*)
+    *(.scommon)
+    _sbss_end = . ;
+    . = ALIGN(4) ;
+  } >kseg1_data_mem
+  /*
+   * Align here to ensure that the .bss section occupies space up to
+   * _end.  Align after .bss to ensure correct alignment even if the
+   * .bss section disappears because there are no input sections.
+   *
+   * Note that input sections named .bss* are no longer mapped here.
+   * Starting in C32 v2.00, the best-fit allocator locates them, so
+   * that they may flow around absolute sections as needed.
+   *
+   */
+  .bss     :
+  {
+    *(.dynbss)
+    *(COMMON)
+   /* Align here to ensure that the .bss section occupies space up to
+      _end.  Align after .bss to ensure correct alignment even if the
+      .bss section disappears because there are no input sections. */
+   . = ALIGN(. != 0 ? 4 : 1);
+  } >kseg1_data_mem
+  . = ALIGN(4) ;
+  _end = . ;
+  _bss_end = . ;
+  /* Starting with C32 v2.00, the heap and stack are dynamically
+   * allocated by the linker.
+   */
+  /*
+   * RAM functions go at the end of our stack and heap allocation.
+   * Alignment of 2K required by the boundary register (BMXDKPBA).
+   *
+   * RAM functions are now allocated by the linker. The linker generates
+   * _ramfunc_begin and _bmxdkpba_address symbols depending on the
+   * location of RAM functions.
+   */
+  _bmxdudba_address = LENGTH(kseg1_data_mem) ;
+  _bmxdupba_address = LENGTH(kseg1_data_mem) ;
+    /* The .pdr section belongs in the absolute section */
+    /DISCARD/ : { *(.pdr) }
+  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }
+  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }
+  .mdebug.abi32 : { KEEP(*(.mdebug.abi32)) }
+  .mdebug.abiN32 : { KEEP(*(.mdebug.abiN32)) }
+  .mdebug.abi64 : { KEEP(*(.mdebug.abi64)) }
+  .mdebug.abiO64 : { KEEP(*(.mdebug.abiO64)) }
+  .mdebug.eabi32 : { KEEP(*(.mdebug.eabi32)) }
+  .mdebug.eabi64 : { KEEP(*(.mdebug.eabi64)) }
+  .gcc_compiled_long32 : { KEEP(*(.gcc_compiled_long32)) }
+  .gcc_compiled_long64 : { KEEP(*(.gcc_compiled_long64)) }
+  /* Stabs debugging sections.  */
+  .stab          0 : { *(.stab) }
+  .stabstr       0 : { *(.stabstr) }
+  .stab.excl     0 : { *(.stab.excl) }
+  .stab.exclstr  0 : { *(.stab.exclstr) }
+  .stab.index    0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment       0 : { *(.comment) }
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+  /* SGI/MIPS DWARF 2 extensions */
+  .debug_weaknames 0 : { *(.debug_weaknames) }
+  .debug_funcnames 0 : { *(.debug_funcnames) }
+  .debug_typenames 0 : { *(.debug_typenames) }
+  .debug_varnames  0 : { *(.debug_varnames) }
+  .debug_pubtypes 0 : { *(.debug_pubtypes) }
+  .debug_ranges   0 : { *(.debug_ranges) }
+  /DISCARD/ : { *(.rel.dyn) }
+  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }
+  /DISCARD/ : { *(.note.GNU-stack) }
+  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) *(.discard) }
+}
diff --git a/include/AD.h b/include/AD.h
new file mode 100644
index 0000000000000000000000000000000000000000..cff27cad7021926e6f26293af637d64c72943cec
--- /dev/null
+++ b/include/AD.h
@@ -0,0 +1,96 @@
+/*
+ * File:   AD.h
+ * Author: mdunne
+ *
+ * Software module to enable the Analog to Digital converter of the Uno32 boards.
+ * NOTE: Analog pins automatically take over digital I/O regardless of which TRIS
+ *       state it is in. There remains an error in the ADC code such that if all 12
+ *       pins are enabled, one of them does not respond.
+ *
+ * AD_TEST (in the .c file) conditionally compiles the test harness for the code. 
+ * Make sure it is commented out for module useage.
+ *
+ * Created on November 22, 2011, 8:57 AM
+ */
+
+#ifndef AD_H
+#define AD_H
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+
+
+#define AD_A0 (1<<0) // NOte that this is also the pot on board
+#define AD_A1 (1<<1)
+#define AD_A2 (1<<2)
+#define AD_A3 (1<<3)
+#define AD_A4 (1<<4)
+#define AD_A5 (1<<5)
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @function AD_Init(void)
+ * @param None
+ * @return SUCCESS or ERROR
+ * @brief Initializes the A/D subsystem and enable battery voltage monitoring
+ * @author Max Dunne, 2013.08.10 */
+char AD_Init(void);
+
+/**
+ * @function AD_AddPins(unsigned int AddPins)
+ * @param AddPins - Use #defined AD_XX OR'd together for each A/D Pin you wish to add
+ * @return SUCCESS OR ERROR
+ * @brief Remove pins from the A/D system.  If any pin is not active it returns an error
+ * @author Max Dunne, 2013.08.15 */
+char AD_AddPins(unsigned int AddPins);
+
+/**
+ * @function AD_RemovePins(unsigned int RemovePins)
+ * @param RemovePins - Use #defined AD_XX OR'd together for each A/D Pin you wish to remove
+ * @return SUCCESS OR ERROR
+ * @brief Remove pins from the A/D system. If any pin is not active it returns an error
+ * @author Max Dunne, 2013.08.15 */
+char AD_RemovePins(unsigned int RemovePins);
+
+/**
+ * @function AD_ActivePins(void)
+ * @param None
+ * @return Listing of all A/D pins that are active
+ * @brief Returns a variable of all active A/D pins. An individual pin can be determined if
+ *        active by "anding" with the AD_XX Macros.
+ * @note This will not reflect changes made with AD_AddPins or AD_RemovePins until the next A/D
+ *       interrupt cycle.
+ * @author Max Dunne, 2013.08.15 */
+unsigned int AD_ActivePins(void);
+
+/**
+ * @function AD_IsNewDataReady(void)
+ * @param None
+ * @return TRUE or FALSE
+ * @brief This function returns a flag indicating that the A/D has new values since the last
+ *        read of a value
+ * @author Max Dunne, 2013.08.15 */
+char AD_IsNewDataReady(void);
+
+/**
+ * @function AD_ReadADPin(unsigned int Pin)
+ * @param Pin - Used #defined AD_XX to select pin
+ * @return 10-bit AD Value or ERROR
+ * @brief Reads current value from buffer for given pin
+ * @author Max Dunne, 2011.12.10 */
+unsigned int AD_ReadADPin(unsigned int Pin);
+
+/**
+ * @function AD_End(void)
+ * @param None
+ * @return None
+ * @brief Disables the A/D subsystem and release the pins used
+ * @author Max Dunne, 2013.09.20 */
+void AD_End(void);
+
+#endif
diff --git a/include/Ascii.h b/include/Ascii.h
new file mode 100644
index 0000000000000000000000000000000000000000..884e512b199535e24d9422db3bd0f20098c4ea8b
--- /dev/null
+++ b/include/Ascii.h
@@ -0,0 +1,26 @@
+#ifndef ASCII_H
+#define ASCII_H
+
+#include <stdint.h>
+
+// Specify the height and width of the characters defined in this library.
+#define ASCII_FONT_HEIGHT 8
+#define ASCII_FONT_WIDTH  6
+
+/**
+ * Pack a font for most of the standard ASCII characters into a byte array. Each character is stored
+ * as ASCII_FONT_WIDTH number of bytes which each byte corresponding to a vertical line of 8 pixels
+ * on the display.
+ *
+ * Some extended ASCII characters are supported:
+ *  0xF8: Degree symbol
+ *
+ * Some custom characters have also been implemented in lieu of some non-printing characters:
+ *  0x01: Top of oven, on
+ *  0x02: Top of oven, off
+ *  0x03: Bottom of oven, on
+ *  0x04: Bottom of oven, off
+ */
+extern const uint8_t ascii[256][ASCII_FONT_WIDTH];
+
+#endif // ASCII_H
\ No newline at end of file
diff --git a/include/BOARD.h b/include/BOARD.h
new file mode 100644
index 0000000000000000000000000000000000000000..660a0a4706b270efbc2a630c52a14cd7cfbdc8d2
--- /dev/null
+++ b/include/BOARD.h
@@ -0,0 +1,96 @@
+/* 
+ * File:   BOARD.h
+ * Author: Max Dunne
+ *
+ * Created on December 19, 2012, 2:08 PM
+ */
+
+#ifndef BOARD_H
+#define	BOARD_H
+
+#include <stdint.h>
+#include <GenericTypeDefs.h>
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+
+//suppresses various warnings that we don't need to worry about for CMPE13
+#ifndef _SUPPRESS_PLIB_WARNING
+#define _SUPPRESS_PLIB_WARNING
+#endif
+
+#ifndef _DISABLE_OPENADC10_CONFIGPORT_WARNING
+#define _DISABLE_OPENADC10_CONFIGPORT_WARNING
+#endif
+
+/*****************************************************************************/
+// Boolean defines for TRUE, FALSE, SUCCESS and ERROR
+#ifndef FALSE
+//#define FALSE ((int8_t) 0)
+//#define TRUE ((int8_t) 1)
+#endif
+#define ERROR ((int8_t) -1)
+#define SUCCESS ((int8_t) 1)
+
+
+// Define macros for referring to the single-bit values of the switches.
+#define SW1 PORTDbits.RD8
+#define SW2 PORTDbits.RD9
+#define SW3 PORTDbits.RD10
+#define SW4 PORTDbits.RD11
+
+/**
+ * Provides a way to quickly get the status of all 4 switches as a nibble, where a bit is 1 if
+ * the button is being pressed and 0 if it's not. The buttons are ordered such that bit 3 is switch
+ * 4 and bit 0 is switch 1.
+ * @see enum ButtonStateFlags
+ */
+#define SWITCH_STATES() ((PORTD >> 8) & 0x0F)
+
+// Define macros for referring to the single-bit values of the buttons.
+#define BTN1 PORTFbits.RF1
+#define BTN2 PORTDbits.RD5
+#define BTN3 PORTDbits.RD6
+#define BTN4 PORTDbits.RD7
+
+/**
+ * Provides a way to quickly get the status of all 4 pushbuttons in to 4-bits, where a bit is 1 if
+ * the button is being pressed and 0 if it's not. The buttons are ordered such that bit 3 is button
+ * 4 and bit 0 is button 1.
+ * @see enum ButtonStateFlags
+ */
+#define BUTTON_STATES() (((PORTD >> 4) & 0x0E) | ((PORTF >> 1) & 0x01))
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @function BOARD_Init(void)
+ * @param None
+ * @return None
+ * @brief Set the clocks up for the board, initializes the serial port, and turns on the A/D
+ *        subsystem for battery monitoring
+ * @author Max Dunne, 2013.09.15  */
+void BOARD_Init();
+
+
+/**
+ * @function BOARD_End(void)
+ * @param None
+ * @return None
+ * @brief Shuts down all peripherals except for serial and A/D. Turns all pins into input
+ * @author Max Dunne, 2013.09.20  */
+void BOARD_End();
+
+/**
+ * @function BOARD_GetPBClock(void)
+ * @param None
+ * @return PB_CLOCK - Speed the peripheral clock is running in hertz
+ * @brief Returns the speed of the peripheral clock.  Nominally at 40Mhz
+ * @author Max Dunne, 2013.09.01  */
+unsigned int BOARD_GetPBClock();
+
+
+#endif	/* BOARD_H */
+
diff --git a/include/CAPTOUCH.h b/include/CAPTOUCH.h
new file mode 100644
index 0000000000000000000000000000000000000000..aed390e76ef7205bb648b09409772093af4c25ef
--- /dev/null
+++ b/include/CAPTOUCH.h
@@ -0,0 +1,81 @@
+/**
+ * @file    CAPTOUCH.h
+ * @brief   Capacitive touch sensing module
+ * @author  CMPE167 Staff
+ * @date    1/15/2019
+ * @detail  This module uses the input capture peripheral to detect touch inputs.
+ *          If you are unfamiliar with input capture please read the lab appendix before beginning.
+ *          The peripheral is configured to generate an interrupt every rising edge which means
+ *          that the difference of two interrupts gives you the period of the signal.
+ *          NOTE: Given the limited number of timers on board this module is incompatible with PWM
+ * 
+ *          To alleviate setup headaches the code for setting up the peripheral and the interrupt is below.
+ *          The library is using IC4 or pin 35 for the input capture. The timer is configured with a 1:8 
+ *          prescaler to to have the timer period be reasonable and useful.
+ * 
+ *          char CAPTOUCH_Init(void)
+ *          {
+ // following block inits the timer
+ *             T2CON = 0;
+ *             T2CONbits.TCKPS = 0b011;
+ *             PR2 = 0xFFFF;
+ *             T2CONbits.ON = 1;
+    
+ *             //this block inits input capture
+ *             IC4CON = 0;
+ *             IC4CONbits.ICTMR = 1;
+ *             IC4CONbits.ICM = 0b010;
+    
+ *             IFS0bits.IC4IF = 0;
+ *             IPC4bits.IC4IP = 7;
+ *             IEC0bits.IC4IE = 1;
+ *             IC4CONbits.ON = 1;
+ *             // whatever else you need to do to initialize your module
+ *          }
+ * 
+ *          void __ISR(_INPUT_CAPTURE_4_VECTOR) InputCapture_Handler(void)
+ *          {
+ *              IFS0bits.IC4IF = 0;
+ *              // IC4BUF contains the timer value when the rising edge occurred.
+ *          }
+ *          
+ */
+
+#ifndef CAPTOUCH_H
+#define CAPTOUCH_H
+
+/*******************************************************************************
+ * INCLUDES                                                                    *
+ ******************************************************************************/
+#include "BOARD.h"
+#include <xc.h>
+#include <sys/attribs.h>
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @function    CAPTOUCH_Init(void)
+ * @brief       This function initializes the module for use. Initialization is 
+ *              done by opening and configuring timer 2, opening and configuring the input capture
+ *              peripheral, and setting up the interrupt.
+ * @return      SUCCESS or ERROR (as defined in BOARD.h)
+ */
+char CAPTOUCH_Init(void);
+
+/**
+ * @function    CAPTOUCH_IsTouched(void)
+ * @brief       Returns TRUE if finger is detected. Averaging of previous measurements 
+ *              may occur within this function, however you are NOT allowed to do any I/O
+ *              inside this function.
+ * @return      TRUE or FALSE
+ */
+char CAPTOUCH_IsTouched(void);
+
+#endif  /* CAPTOUCH_H */
\ No newline at end of file
diff --git a/include/I2C.h b/include/I2C.h
new file mode 100644
index 0000000000000000000000000000000000000000..12cdde3747dbb25e34283b81ec6d90abb65f6521
--- /dev/null
+++ b/include/I2C.h
@@ -0,0 +1,57 @@
+/* 
+ * File:   I2C.h
+ * Author: Max
+ *
+ * Created on February 22, 2018, 1:17 PM
+ */
+
+#ifndef I2C_H
+#define	I2C_H
+
+
+#define I2C_DEFUALT_RATE 100000
+
+/**
+ * @Function I2C_Init(Rate)
+ * @param Rate - Clock rate for the I2C system
+ * @return The clock rate set for the I2C system, 0 if already inited
+ * @brief  Initializes the I2C System for use with the IMU
+ * @author Max Dunne */
+unsigned int I2C_Init(unsigned int Rate);
+
+
+
+/**
+ * @Function I2C_ReadRegister(unsigned char I2CAddress,unsigned char deviceRegisterAddress)
+ * @param I2CAddresss - 7-bit address of I2C device wished to interact with
+ * @param deviceRegisterAddress - 8-bit address of register on device
+ * @return Value at Register or 0
+ * @brief  Reads one device register on chosen I2C device
+ * @author Max Dunne*/
+unsigned char I2C_ReadRegister(unsigned char I2CAddress,unsigned char deviceRegisterAddress);
+
+
+/**
+ * @Function I2C_WriteReg(unsigned char I2CAddress, unsigned char deviceRegisterAddress, char data)
+ * @param I2CAddresss - 7-bit address of I2C device wished to interact with
+ * @param deviceRegisterAddress - 8-bit address of register on device
+ * @param data - data wished to be written to register
+ * @return 0 if error and 1 if success
+ * @brief  Writes one device register on chosen I2C device
+ * @author Max Dunne*/
+unsigned char I2C_WriteReg(unsigned char I2CAddress, unsigned char deviceRegisterAddress, char data);
+
+
+/**
+ * @Function I2C_ReadInt(char I2CAddress, char deviceRegisterAddress, char isBigEndian)
+ * @param I2CAddresss - 7-bit address of I2C device wished to interact with
+ * @param deviceRegisterAddress - 8-bit lower address of register on device
+ * @param isBigEndian - Boolean determining if device is big or little endian
+ * @return 0 if error and 1 if success
+ * @brief  Reads two sequential registers to build a 16-bit value. isBigEndian
+ * whether the first bits are either the high or low bits of the value
+ * @author Max Dunne*/
+int I2C_ReadInt(char I2CAddress, char deviceRegisterAddress, char isBigEndian);
+
+#endif	/* I2C_H */
+
diff --git a/include/MPU9250.h b/include/MPU9250.h
new file mode 100644
index 0000000000000000000000000000000000000000..52a22fe8f119f07f30eadf8e077cdc25ff9b92d7
--- /dev/null
+++ b/include/MPU9250.h
@@ -0,0 +1,98 @@
+/* 
+ * File:   MPU9250.h
+ * Author: Max
+ *
+ * Created on February 27, 2018, 8:14 AM
+ */
+
+#ifndef MPU9250_H
+#define	MPU9250_H
+
+
+
+/**
+ * @Function MPU9250_Init(Rate)
+
+ * @return 0 if error, 1 if succeeded
+ * @brief  Initializes the MPU 9250 for usage. This will set all sensors to approximately 100HZ
+ * and Accel: 2g,Gyro:  250dps and Mag: 16-bit for the sensors
+ * @author Max Dunne */
+char MPU9250_Init(void);
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadAccelX(void);
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadAccelY(void);
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadAccelZ(void);
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadGyroX(void);
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadGyroY(void);
+
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadGyroZ(void);
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadMagX(void);
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadMagY(void);
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadMagZ(void);
+
+
+
+#endif	/* MPU9250_H */
+
diff --git a/include/Oled.h b/include/Oled.h
new file mode 100644
index 0000000000000000000000000000000000000000..bc0aedbdbecf30597707910f9ce5943639769b5d
--- /dev/null
+++ b/include/Oled.h
@@ -0,0 +1,148 @@
+#ifndef OLED_H
+#define OLED_H
+
+/**
+ * This file provides a complete interface for interacting with the OLED on Digilent's I/O Shield.
+ * It works by storing a backend array of pixel data for storing modifications and then flushing
+ * that to the screen to update it when OledUpdate() is called. Since OledUpdate() is very slow,
+ * this allows for batching together a lot of drawing operations before finally updating the screen
+ * at the end in one go.
+ *
+ * This OLED is a monochrome display, offering black and white as your color options. These can be
+ * specified as arguments to OledDrawChar() and OledClear(). Note that this coloring can be inverted
+ * on the display itself by calling OledSetDisplayInverted(). This doesn't actually modify the data
+ * stored in the pixels, but merely switches what colors each bit value represents.
+ *
+ * The OLED offers both a pixel interface and a text interface for drawing. Individual pixels can be
+ * read and changed with the Oled*Pixel() functions.
+ *
+ * Higher-level text operations can be done through OledDrawChar() and OledDrawString, with the
+ * latter function being the easier one to use. It allows for writing text across all OLED_NUM_LINES
+ * lines on the display where each line can hold up to OLED_CHARS_PER_LINE complete characters.
+ *
+ * The font (defined in Ascii.h) used for drawing characters is a custom monospaced font. It
+ * provides glyphs for most of the basic ASCII character set, but is incomplete. Additionally some
+ * non-printing characters have been repurposed for custom characters for specific uses
+ * (@see Ascii.h).
+ */
+
+
+#include "Ascii.h"
+#include "OledDriver.h"
+#include "BOARD.h"
+
+/**
+ * Define constants for available colors for the OLED: either white or black.
+ */
+typedef enum {
+    OLED_COLOR_BLACK = 0,
+    OLED_COLOR_WHITE = 1
+} OledColor;
+
+// Define how many lines of text the display can show.
+#define OLED_NUM_LINES         (OLED_DRIVER_PIXEL_ROWS / ASCII_FONT_HEIGHT)
+
+// Define how many complete characters can be displayed on a row of text.
+#define OLED_CHARS_PER_LINE  (OLED_DRIVER_PIXEL_COLUMNS / ASCII_FONT_WIDTH)
+
+/**
+ * Initializes the OLED, turns it on, and clears the screen.
+ */
+void OledInit(void);
+
+/**
+ * Sets a specific pixel in the frame buffer, available colors are black or white.
+ * @note OledUpdate() must be called before the OLED will actually display these changes.
+ * @param x The X position (left is zero)
+ * @param y The Y position (top is zero)
+ * @param color OLED_COLOR_WHITE or OLED_COLOR_BLACK
+ */
+void OledSetPixel(int x, int y, OledColor color);
+
+/**
+ * Reads a pixel from the frame buffer.
+ * @param x The X position (left is zero)
+ * @param y The Y position (top is zero)
+ * @return OLED_COLOR_WHITE or OLED_COLOR_BLACK
+ */
+int OledGetPixel(int x, int y);
+
+/**
+ * Draws the specified character at the specified position, using Ascii.h as the font.
+ * @note OledUpdate() must be called before the OLED will actually display these changes.
+ * @param x The x-position to use as the left-most value for the character.
+ * @param y The y-position to use as the top-most value for the character
+ * @param c The character to write. Uses the character array defined in Ascii.h
+ * @return True if the write succeeded. Fails on invalid inputs.
+ */
+uint8_t OledDrawChar(int x, int y, char c);
+
+/**
+ * Draws a string to the screen buffer, starting on the top line. OLED_CHARS_PER_LINE characters fit
+ * on each of the OLED_NUM_LINES lines on the screen. A newline in the string will start the
+ * subsequent characters on the next line, otherwise once a line has run out of room no more
+ * characters will display on the screen. There is no other special processing of the input string
+ * besides this newline functionality, for example backspace characters just render as blank
+ * characters.
+ *
+ * For example, the following code example shows Hello World I'm Working! on the OLED with each word
+ * on its own line:
+ *   OledInit();
+ *   OledDrawString("Hello\nWorldI'm\nWorking!\n");
+ *   OledUpdate();
+ *
+ * @note OledUpdate() must be called before the OLED will actually display these changes.
+ * @param string A null-terminated string to print.
+ */
+void OledDrawString(const char *string);
+
+/**
+ * Writes the specified color pixels to the entire frame buffer.
+ * @note OledUpdate() must be called before the OLED will actually display these changes.
+ * @param p The color to write all pixels in the OLED to.
+ */
+void OledClear(OledColor p);
+
+/**
+ * Sets the display to display pixels the opposite color than what was intended. This does not
+ * change the stored value for any pixel.
+ * @see OledSetDisplayNormal
+ */
+void OledSetDisplayInverted(void);
+
+/**
+ * Displays all pixels as they are stored, where a 0 indicates black and a 1 indicates white. This
+ * is the default setting for the OLED on startup. This undoes `OledSetDisplayInverted()`.
+ * @see OledSetDisplayInverted
+ */
+void OledSetDisplayNormal(void);
+
+/**
+ * Turns on the OLED display.
+ * @note This is not required as part of initialization, as `OledInit()` already does this.
+ */
+void OledOn(void);
+
+/**
+ * Turns off the OLED display.
+ * @note This is not required as part of initialization, as `OledInit()` already does this.
+ */
+void OledOff(void);
+
+/**
+ * Refreshes the OLED display to reflect any changes. Should be called after any operation that
+ * changes the display: OledSetPixel(), OledDrawChar(), OledDrawString(), and OledClear().
+ *
+ * This function is very slow and so shouldn't be called too often or the OLED might look dim or
+ * even show no data at all. This is because it uses a blocking SPI interface to push out the entire
+ * screen of pixel data every time it's called. Like I said, very slow function!
+ *
+ * For example, the following code example shows Hello World I'm Workin! on the OLED with each word
+ * on its own line:
+ *   OledInit();
+ *   OledDrawString("Hello\nWorldI'm\nWorking!\n");
+ *   OledUpdate();
+ */
+void OledUpdate(void);
+
+#endif
\ No newline at end of file
diff --git a/include/OledDriver.h b/include/OledDriver.h
new file mode 100644
index 0000000000000000000000000000000000000000..75c9fed20f33aa8d1dc55a8fa87f7fc75602861c
--- /dev/null
+++ b/include/OledDriver.h
@@ -0,0 +1,87 @@
+#ifndef OLED_DRIVER_H
+#define OLED_DRIVER_H
+
+// Include standard C libraries.
+#include <stdint.h>
+
+// Include Microchip C libraries.
+#include <xc.h>
+
+/**
+ * Configure the port and pins for each of the 4 control signals used with the OLED:
+ *   * F6: Controls the power to the controller logic. Active-low, so a 0 powers it on.
+ *   * F5: Controls the power to the OLED display. Active-low, so a 0 powers it on.
+ *   * F4: Sets the input mode of the controller logic. High indicates incoming data is display
+ *         data, while low indicates they're commands.
+ *   * G9: Reset pin connected to the display controller. Active-low, so a 0 holds the logic in
+ *         reset.
+ */
+
+#define OLED_DRIVER_CONTROLLER_POWER_PORT PORTFbits.RF6
+#define OLED_DRIVER_CONTROLLER_POWER_TRIS TRISFbits.TRISF6
+
+#define OLED_DRIVER_OLED_POWER_PORT PORTFbits.RF5
+#define OLED_DRIVER_OLED_POWER_TRIS TRISFbits.TRISF5
+
+#define OLED_DRIVER_MODE_PORT PORTFbits.RF4
+#define OLED_DRIVER_MODE_TRIS TRISFbits.TRISF4
+
+#define OLED_DRIVER_RESET_PORT PORTGbits.RG9
+#define OLED_DRIVER_RESET_TRIS TRISGbits.TRISG9
+
+
+// The number of pixel columns in the OLED display.
+#define OLED_DRIVER_PIXEL_COLUMNS                                                          128
+
+// The number of pixel rows in the OLED display.
+#define OLED_DRIVER_PIXEL_ROWS                                                              32
+
+// Store how high each column is for the OLED in bits in terms of data structure storage.
+#define OLED_DRIVER_BUFFER_LINE_HEIGHT                                                       8
+
+// The number of bytes required to store all the data for the whole display. 1 bit / pixel.
+#define OLED_DRIVER_BUFFER_SIZE     ((OLED_DRIVER_PIXEL_COLUMNS * OLED_DRIVER_PIXEL_ROWS) / 8)
+
+/**
+ * This array is the off-screen frame buffer used for rendering. It isn't possible to read back from
+ * the OLED display device, so display data is rendered into this off-screen buffer and then copied
+ * to the display. The high-order bits equate to the lower pixel rows.
+ * @note Any time this is updated, An `OledDriverUpdateDisplay()` call must be performed.
+ */
+extern uint8_t rgbOledBmp[OLED_DRIVER_BUFFER_SIZE];
+
+/**
+ * Initialize the PIC32MX to communicate with the UG-23832HSWEG04 OLED display through the SSD1306
+ * display controller.
+ */
+void OledHostInit(void);
+
+/**
+ * Initialize the OLED display and driver circuitry.
+ */
+void OledDriverInitDisplay(void);
+
+/**
+ * Disable the Oled display before power-off. This means powering it up, sending the display off
+ * command, and finally disabling Vbat.
+ */
+void OledDriverDisableDisplay(void);
+
+/**
+ * Update the display with the contents of rgb0ledBmp.
+ */
+void OledDriverUpdateDisplay(void);
+
+/**
+ * Set the LCD to display pixel values as the opposite of how they are actually stored in NVRAM. So
+ * pixels set to black (0) will display as white, and pixels set to white (1) will display as black.
+ */
+void OledDriverSetDisplayInverted(void);
+
+/**
+ * Set the LCD to display pixel values normally, where a 1 indicates white and a 0 indicates black.
+ * This is the default operating mode of the LCD and the mode it starts up in.
+ */
+void OledDriverSetDisplayNormal(void);
+
+#endif // OLED_DRIVER_H
\ No newline at end of file
diff --git a/include/PING.h b/include/PING.h
new file mode 100644
index 0000000000000000000000000000000000000000..c6b96c5e344a34184565ffb5ed4d4cd5887443ea
--- /dev/null
+++ b/include/PING.h
@@ -0,0 +1,101 @@
+/**
+ * @file    PING.h
+ * @brief   Ultrasonic Ping Sensor sensing module
+ * @author  CMPE167 Staff
+ * @date    1/15/2019
+ * @detail  This module uses the timer and the change notify peripheral to interface to an
+ *          ultrasonic ranging sensor. 
+ *          If you are unfamiliar with change notify or timers, please read the lab appendix before beginning.
+ *          The timer peripheral is used to create the required trigger pulses. To do so you will need to modify when
+ *          the next interrupt occurs by modifying the PR4 register to create the periodic pulse.
+ *          The timer has already been set up with a 64:1 prescaler. The trigger pin has not been set and is up to you.
+ *
+ *          The change notify is configured to operate on CN14 or pin 34 on the I/O shield.  
+ *          Instead of using a hardware timer we will use the TIMERS library to calculate the duration of the pulse
+ *          in microseconds.
+ *          To alleviate setup headaches the code for setting up the peripherals and interrupts is below.
+ *
+ *          char PING_Init(void) {
+ *            // following block inits the timer
+ *            T4CON = 0;
+ *            T4CONbits.TCKPS = 0b110;
+ *            PR4 = 0xFFFF;  // this is not the timer value wanted
+ *            T4CONbits.ON = 1;
+ *            IFS0bits.T4IF = 0;
+ *            IPC4bits.T4IP = 3;
+ *            IEC0bits.T4IE = 1;
+ * 
+ *            // following block inits change notify
+ *            CNCONbits.ON = 1; // Change Notify On
+ *            CNENbits.CNEN14 = 1;
+ *            int temp = PORTD; // this is intentional to ensure a interrupt occur immediately upon enabling
+ *            IFS1bits.CNIF = 0; // clear interrupt flag
+ *            IPC6bits.CNIP = 1; //set priority
+ *            IPC6bits.CNIS = 3; // and sub priority
+ *            IEC1bits.CNIE = 1; // enable change notify
+ *              //Anything else that needs to occur goes here
+ *          }
+ * 
+ *          void __ISR(_CHANGE_NOTICE_VECTOR) ChangeNotice_Handler(void) {
+ *              static char readPort = 0;
+ *              readPort = PORTD; // this read is required to make the interrupt work
+ *              IFS1bits.CNIF = 0; 
+ *              //Anything else that needs to occur goes here
+ *          }
+ * 
+ *          void __ISR(_TIMER_4_VECTOR) Timer4IntHandler(void) {
+ *              IFS0bits.T4IF = 0;
+ *              //Anything else that needs to occur goes here
+ *          }
+ *          
+ */
+
+#ifndef PING_H
+#define PING_H
+
+/*******************************************************************************
+ * INCLUDES                                                                    *
+ ******************************************************************************/
+#include "BOARD.h"
+#include <xc.h>
+#include <sys/attribs.h>
+
+
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @function    PING_Init(void)
+ * @brief       Sets up both the timer and Change notify peripherals along with their
+ *              respective interrupts.  Also handles any other tasks needed such as pin 
+ *              I/O directions, and any other things you need to initialize the sensor.
+ *              TIMERS library must be inited before this library.
+ * @return      SUCCESS or ERROR (as defined in BOARD.h)
+ */
+char PING_Init(void);
+
+/**
+ * @function    PING_GetDistance(void)
+ * @brief       Returns the calculated distance in mm using the sensor model determined
+ *              experimentally. 
+ *              No I/O should be done in this function
+ * @return      distance in mm
+ */
+unsigned int PING_GetDistance(void);
+
+/**
+ * @function    PING_GetTimeofFlight(void)
+ * @brief       Returns the raw microsecond duration of the echo from the sensor.
+ *              NO I/O should be done in this function.
+ * @return      time of flight in uSec
+ */
+unsigned int PING_GetTimeofFlight(void);
+
+#endif
\ No newline at end of file
diff --git a/include/QEI.h b/include/QEI.h
new file mode 100644
index 0000000000000000000000000000000000000000..06000694f39fda748cde2adb6295c1b556b616e2
--- /dev/null
+++ b/include/QEI.h
@@ -0,0 +1,84 @@
+/* 
+ * @file    QEI.h
+ * @brief   Quadrature Encoder sensing module
+ * @author  CMPE167 Staff
+ * @date    1/15/2019
+ * @detail  This module uses the change notify peripheral to interface to a quadrature encoder. 
+ *          If you are unfamiliar with change notify please read the lab appendix before beginning.
+ *          The peripheral is configured to generate an interrupt on any change in input of pins RD6
+ *          or RD7 (pins 36 and 37 on the Uno32). The interrupt will not tell you which pin changed
+ *          states so you will need to implement a simple state machine to handle the transitions and
+ *          keep track of the encoder count.
+ *          NOTE: Encoder A and B must be input to pins 36 and 37
+ *
+ *          To alleviate setup headaches the code for setting up the peripheral and the interrupt is below.
+ *
+ *          char QEI_Init(void) {
+ *               // INIT Change notify
+ *               CNCONbits.ON = 1; // Change Notify On
+ *               CNENbits.CNEN15 = 1; //enable one phase
+ *               CNENbits.CNEN16 = 1; //enable other phase
+ *               int temp = PORTD; // this is intentional to ensure a interrupt occur immediately upon enabling
+ *               IFS1bits.CNIF = 0; // clear interrupt flag
+ *               IPC6bits.CNIP = 1; //set priority
+ *               IPC6bits.CNIS = 3; // and sub priority
+ *               IEC1bits.CNIE = 1; // enable change notify
+ * 
+ *                // the rest of the function goes here
+ *          }
+ *
+ *          void __ISR(_CHANGE_NOTICE_VECTOR) ChangeNotice_Handler(void) {
+ *               static char readPort = 0;
+ *               readPort = PORTD; // this read is required to make the interrupt work
+ *               IFS1bits.CNIF = 0;
+ *               //anything else that needs to happen goes here
+ *          }
+ */
+
+#ifndef QEI_H
+#define	QEI_H
+
+/*******************************************************************************
+ * INCLUDES                                                                    *
+ ******************************************************************************/
+#include "BOARD.h"
+#include <xc.h>
+#include <sys/attribs.h>
+
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+ 
+ 
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/ 
+
+ 
+/**
+ * @function QEI_Init(void)
+ * @param none
+ * @brief  Enables the Change Notify peripheral and sets up the interrupt, anything
+ *         else that needs to be done to initialize the module. 
+ * @return SUCCESS or ERROR (as defined in BOARD.h)
+*/
+char QEI_Init(void);
+
+/**
+ * @function QEI_GetPosition(void) 
+ * @param none
+ * @brief This function returns the current count of the Quadrature Encoder in ticks.      
+*/
+int QEI_GetPosition(void);
+
+/**
+ * @Function QEI_ResetPosition(void) 
+ * @param  none
+ * @return none
+ * @brief  Resets the encoder such that it starts counting from 0.
+*/
+void QEI_ResetPosition(); 
+
+#endif	/* QEI_H */
+
diff --git a/include/ToneGeneration.h b/include/ToneGeneration.h
new file mode 100644
index 0000000000000000000000000000000000000000..043702b42ae7a46497b59f499df14eb1865aa88f
--- /dev/null
+++ b/include/ToneGeneration.h
@@ -0,0 +1,79 @@
+/*
+ * File:   ToneGeneration.h
+ * Author: mdunne
+ *
+ * Software module to run one PWM module for tone generation. 
+ * PIN3 on the Uno32 is used for tone generation
+ * 
+ *
+
+ */
+
+#ifndef TONEGENERATION_H
+#define TONEGENERATION_H
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+#define MIN_TONE 1
+
+
+#define TONE_196 196
+#define TONE_293 293
+#define TONE_440 440
+#define TONE_659 659
+
+
+#define DEFAULT_TONE TONE_440
+
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+
+/**
+ * @Function ToneGeneration_Init(void)
+ * @param None
+ * @return SUCCESS or ERROR
+ * @brief  Initializes the timer and PWM for the tone system
+ * @note  None.
+ * @author Max Dunne */
+char ToneGeneration_Init(void);
+
+/**
+ * @Function ToneGeneration_SetFrequency(unsigned int NewFrequency)
+ * @param NewFrequency - new frequency to set. 
+ * @return SUCCESS OR ERROR
+ * @brief  Changes the frequency of the ToneGeneration system.
+ * @note  Behavior of ToneGeneration during Frequency change is undocumented
+ * @author Max Dunne */
+char ToneGeneration_SetFrequency(unsigned int NewFrequency);
+
+
+/**
+ * @Function ToneGeneration_GetFrequency(void)
+ * @return Frequency of system in Hertz
+ * @brief  gets the frequency of the ToneGeneration system.
+ * @author Max Dunne */
+unsigned int ToneGeneration_GetFrequency(void);
+
+
+/**
+ * @Function ToneGeneration_ToneOff(void)
+ * @return Turns Tone Off
+ * @author Max Dunne */
+void ToneGeneration_ToneOff(void);
+
+
+/**
+ * @Function ToneGeneration_ToneOn(void)
+ * @return Turns Tone On
+ * @author Max Dunne */
+
+void ToneGeneration_ToneOn(void);
+
+
+
+#endif
diff --git a/include/pwm.h b/include/pwm.h
new file mode 100644
index 0000000000000000000000000000000000000000..2c09d85cf57b4a6c999afaae647c686956becb96
--- /dev/null
+++ b/include/pwm.h
@@ -0,0 +1,133 @@
+/*
+ * File:   pwm.h
+ * Author: mdunne
+ *
+ * Software module to run the PWM module of the Uno32. The available pins for
+ * which the PWM works are #defined below (PortZ-6, PortY-4,10,12, and PortX-11),
+ * and are set by the hardware (cannot be modified).
+ *
+ * NOTE: Module uses TIMER2 for its interrupts.
+ *
+ * PWM_TEST (in the .c file) conditionally compiles the test harness for the code. 
+ * 
+ *
+ * Created on November 12, 2011, 9:27 AM
+ */
+
+#ifndef pwm_H
+#define pwm_H
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+#define MIN_PWM_FREQ 100
+#define PWM_500HZ 500
+#define PWM_1KHZ 1000
+#define PWM_2KHZ 2000
+#define PWM_5KHZ 5000
+#define PWM_10KHZ 10000
+#define PWM_20KHZ 20000
+#define PWM_30KHZ 30000
+#define PWM_40KHZ 40000
+#define MAX_PWM_FREQ 100000
+#define PWM_DEFAULT_FREQUENCY PWM_1KHZ
+
+#define PWM_PORTZ06 (1<<0)
+#define PWM_PORTY12 (1<<1)
+#define PWM_PORTY10 (1<<2)
+#define PWM_PORTY04 (1<<3)
+#define PWM_PORTX11 (1<<4)
+
+#define MIN_PWM 0
+#define MAX_PWM 1000
+
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @Function PWM_Init(void)
+ * @param None
+ * @return SUCCESS or ERROR
+ * @brief  Initializes the timer for the PWM system and set is to the default frequency
+ * @note  None.
+ * @author Max Dunne, 2013.08.25 */
+char PWM_Init(void);
+
+/**
+ * @Function PWM_SetFrequency(unsigned int NewFrequency)
+ * @param NewFrequency - new frequency to set. best to use #defined from header
+ * @return SUCCESS OR ERROR
+ * @brief  Changes the frequency of the PWM system.
+ * @note  Behavior of PWM channels during Frequency change is undocumented
+ * @author Max Dunne, 2013.08.19 */
+char PWM_SetFrequency(unsigned int NewFrequency);
+
+/**
+ * @Function PWM_GetFrequency(void)
+ * @return Frequency of system in Hertz
+ * @brief  gets the frequency of the PWM system.
+ * @author Max Dunne, 2013.08.19 */
+unsigned int PWM_GetFrequency(void);
+
+/**
+ * @Function PWM_AddPins(unsigned short int AddPins)
+ * @param AddPins - use #defined PWM_PORTxxx OR'd together for each A/D Pin you wish to add
+ * @return SUCCESS OR ERROR
+ * @brief  Adds new pins to the PWM system.  If any pin is already active it errors
+ * out
+ * @author Max Dunne, 2013.08.15 */
+char PWM_AddPins(unsigned short int PWMpins);
+
+/**
+ * @Function PWM_RemovePins(unsigned int PWMPins)
+ * @param RemovePins - use #defined AD_PORTxxx OR'd together for each A/D Pin you wish to remove
+ * @return SUCCESS OR ERROR
+ * @brief  Remove pins from the PWM system.  If any pin is not active it errors out
+ * @author Max Dunne, 2013.08.15 */
+char PWM_RemovePins(unsigned int PWMPins);
+
+/**
+ * @Function PWM_ListPins(void)
+ * @param None
+ * @return Listing of all PWM pins that are active.
+ * @brief  Returns a variable of all active pwm pins. An individual pin can be determined
+ * if active by "anding" with the pwm_PORTXX Macros
+ * @author Max Dunne, 2013.08.19 */
+unsigned int PWM_ListPins(void);
+
+/**
+ * Function  PWM_SetDutyCycle
+ * @param Channels, use #defined PWM_PORTxxx
+ * @param Duty, duty cycle for the channel (0-1000)
+ * @return SUCCESS or ERROR
+ * @remark Sets the Duty Cycle for a Single Channel and returns error if that channel is not enabled
+ * @author Max Dunne
+ * @date 2011.11.12  */
+char PWM_SetDutyCycle(unsigned char Channel, unsigned int Duty);
+
+/**
+ * Function  PWM_GetDutyCycle
+ * @param Channels, use #defined PWM_PORTxxx
+ * 
+ * @return Duty cycle
+ * @remark Gets the Duty Cycle for a Single Channel and returns error if that channel is not enabled
+ * @author Max Dunne
+ * @date 2011.11.12  */
+unsigned int PWM_GetDutyCycle(char Channel);
+
+/**
+ * Function: PWM_End
+ * @param None
+ * @return SUCCESS or ERROR
+ * @remark Disables the PWM sub-system and releases all pins.
+ * @author Max Dunne
+ * @date 2011.11.12  */
+char PWM_End(void);
+
+
+
+
+#endif
diff --git a/include/serial.h b/include/serial.h
new file mode 100644
index 0000000000000000000000000000000000000000..83d6216e15f5bbac542c38fb85a43d28d0c10463
--- /dev/null
+++ b/include/serial.h
@@ -0,0 +1,63 @@
+/*
+   File:   serial.h
+   Author: mdunne
+
+   Created on November 10, 2011, 8:43 AM
+ */
+
+#ifndef SERIAL_H
+#define SERIAL_H
+
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+
+/**
+ * @Function SERIAL_Init(void)
+ * @param none
+ * @return none
+ * @brief  Initializes the UART subsystem to 115200 and sets up the circular buffer
+ * @author Max Dunne, 2011.11.10 */
+void SERIAL_Init(void);
+
+/**
+ * @Function PutChar(char ch)
+ * @param ch - the char to be sent out the serial port
+ * @return None.
+ * @brief  adds char to the end of the circular buffer and forces the interrupt flag
+ * high if nothing is currently transmitting
+ * @author Max Dunne, 2011.11.10 */
+void PutChar(char ch);
+
+/**
+ * @Function GetChar(void)
+ * @param None.
+ * @return ch - char from the serial port
+ * @brief  reads first character from buffer or returns 0 if no chars available
+ * @author Max Dunne, 2011.11.10 */
+char GetChar(void);
+
+/**
+ * @Function IsTransmitEmpty(void)
+ * @param None.
+ * @return TRUE or FALSE
+ * @brief  returns the state of the receive buffer
+ * @author Max Dunne, 2011.12.15 */
+char IsTransmitEmpty(void);
+
+/**
+ * @Function IsReceiveEmpty(void)
+ * @param None.
+ * @return TRUE or FALSE
+ * @brief  returns the state of the receive buffer
+ * @author Max Dunne, 2011.12.15 */
+char IsReceiveEmpty(void);
+
+#endif // serial_h
diff --git a/include/timers.h b/include/timers.h
new file mode 100644
index 0000000000000000000000000000000000000000..fecbe7a175c783c7f7710e88e948a1187fea3711
--- /dev/null
+++ b/include/timers.h
@@ -0,0 +1,56 @@
+/*
+ * File:   timers.h
+ * Author: mdunne
+ *
+ * Software module to enable a bank of software timers with a resolution time of
+ * one msecond for each. The timers can be individually started, stopped, expired, etc.
+ *
+ * NOTE: Module uses TIMER5 for its interrupts.
+ *
+ * TIMERS_TEST (in the .c file) conditionally compiles the test harness for the code. 
+ * Make sure it is commented out for module useage.
+ *
+ * Created on November 15, 2011, 9:54 AM
+ */
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+#ifndef timers_H
+#define timers_H
+
+
+
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @Function TIMERS_Init(void)
+ * @param none
+ * @return None.
+ * @brief  Initializes the timer module
+ * @author Max Dunne, 2011.11.15 */
+void TIMERS_Init(void);
+
+/**
+ * Function: TIMERS_GetMilliSeconds
+ * @param None
+ * @return the current MilliSecond Count
+ * @author Max Dunne
+   */
+unsigned int TIMERS_GetMilliSeconds(void);
+
+/**
+ * Function: TIMERS_GetMicroSeconds
+ * @param None
+ * @return the current MicroSecond Count, it will roll over in 1.9 hours
+ * @author Max Dunne
+   */
+unsigned int TIMERS_GetMicroSeconds(void);
+
+
+
+#endif
diff --git a/scripts/BootStrap_Student.py b/scripts/BootStrap_Student.py
new file mode 100644
index 0000000000000000000000000000000000000000..5fef8ffee0f7a2da3db993636ed33b5f3b26c8f6
--- /dev/null
+++ b/scripts/BootStrap_Student.py
@@ -0,0 +1,21 @@
+import subprocess
+import sys
+import os
+
+PackagesNeeded=['requests']
+
+# we first check to see if we are not windows
+if os.name != 'nt':
+	print('This script only supports Windows, packages needed are listed before for manual installation')
+	print(', '.join(PackagesNeeded))
+	sys.exit(1)
+
+# we programmatically find the python path
+pythonPath = sys.executable
+pythonDir = os.path.split(pythonPath)[0]
+# and then find the pip path
+pipPath = os.path.join(pythonDir,'Scripts','pip3')
+
+for package in PackagesNeeded:
+	print('Installing '+package)
+	subprocess.run([pipPath, 'install','--upgrade',package])
\ No newline at end of file
diff --git a/scripts/update_code.py b/scripts/update_code.py
new file mode 100644
index 0000000000000000000000000000000000000000..4e807dbb3b0b282f7c37254ff4d422ed0f2f8946
--- /dev/null
+++ b/scripts/update_code.py
@@ -0,0 +1,70 @@
+import os
+import sys
+import zipfile
+import requests
+import shutil
+import zlib
+
+toDir='C:\\'
+className = 'ECE167'
+sourceURL='http://soe.ucsc.edu/~mdunne/ClassZips/'+className+'.zip'
+
+rawZip=requests.get(sourceURL,stream=True)
+zipPath=os.path.join(os.environ['TMP'],'ECE167.zip')
+
+#we currently write this to a file and read it back in, we should be able to do it directly in memory instead
+with open(zipPath,'wb') as f:
+	rawZip.raw.decode_content = True
+	shutil.copyfileobj(rawZip.raw,f)
+print(zipPath)
+
+zip=zipfile.ZipFile(zipPath)
+
+#iterate all the files to completely mirror the structure
+
+filesInZip=[]
+for fileInfo in zip.infolist():
+	localFilePath='\\'.join(os.path.join(toDir,fileInfo.filename).split('/')) # some fiddly bits because of file formats between windows and unix
+	filesInZip.append(localFilePath)
+	#print(localFilePath)
+	[localDir,localFileName]=os.path.split(localFilePath)
+	#print(localDir)
+	if not os.path.exists(localDir):
+		try:
+			os.makedirs(localDir)
+		except:
+			print('Can not build directory structure, exiting')
+			input()
+			sys.exit(1)
+		print('creating '+localDir)
+	try:
+		curCRC=zlib.crc32(open(localFilePath,'rb').read())
+		if curCRC != fileInfo.CRC:
+			print('replacing '+localFilePath)
+			zip.extract(fileInfo, toDir)
+	except FileNotFoundError: # if we don't have a file we can move the file
+		zip.extract(fileInfo,toDir)
+zip.close()
+for root,dir,files in os.walk(toDir+className):
+	for file in files:
+		curFilePath=os.path.join(root,file)
+		if not curFilePath in filesInZip: # compare against zip
+			if toDir+className in curFilePath: # confirm that still in base directory for massive error prevention
+				print('file not found: '+curFilePath)
+				try:
+					os.remove(curFilePath)
+					print('trying to remove'+curFilePath)
+				except:
+					print('Unable to remove: '+curFilePath)
+					sys.exit(1)
+for root,dir,files in os.walk(toDir+className,topdown=False):
+	for name in dir:
+		try:
+			os.rmdir(os.path.join(root, name))
+		except OSError :
+			pass
+		except Exception as e:
+			print("Unknown error in folder deletion")
+			print(e)
+			sys.exit(1)
+sys.exit(0)
diff --git a/src/AD.c b/src/AD.c
new file mode 100644
index 0000000000000000000000000000000000000000..a03120b0de1428fe0a9518b691bc8bb8c82907fb
--- /dev/null
+++ b/src/AD.c
@@ -0,0 +1,527 @@
+/*
+ * File:   AD.c
+ * Author: mdunne
+ *
+ * Created on November 22, 2011, 8:57 AM
+ */
+
+#include <xc.h>
+#include <BOARD.h>
+#include <AD.h>
+
+#include <sys/attribs.h>
+
+#include <serial.h>
+
+#include <stdio.h>
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+//#define AD_DEBUG_VERBOSE
+
+
+#define NUM_AD_PINS 6
+#define NUM_AD_PINS_UNO 16
+
+
+//#define AD_DEBUG_VERBOSE
+#ifdef AD_DEBUG_VERBOSE
+#include "serial.h"
+#define dbprintf(...) while(!IsTransmitEmpty()); printf(__VA_ARGS__)
+#else
+#define dbprintf(...)
+#endif
+
+
+
+#define ALLADPINS (AD_A0|AD_A1|AD_A2|AD_A3|AD_A4|AD_A5)
+
+
+
+
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                            *
+ ******************************************************************************/
+static unsigned int AD1PCFG_MASKS[NUM_AD_PINS] = {_AD1PCFG_PCFG2_MASK, _AD1PCFG_PCFG4_MASK,
+    _AD1PCFG_PCFG8_MASK, _AD1PCFG_PCFG10_MASK, _AD1PCFG_PCFG12_MASK, _AD1PCFG_PCFG14_MASK};
+
+static unsigned int AD1CSSL_MASKS[NUM_AD_PINS] = {_AD1CSSL_CSSL2_MASK, _AD1CSSL_CSSL4_MASK, 
+    _AD1CSSL_CSSL8_MASK, _AD1CSSL_CSSL10_MASK, _AD1CSSL_CSSL12_MASK, _AD1CSSL_CSSL14_MASK};
+
+static unsigned int AD1PCFG_POS[NUM_AD_PINS] = {_AD1PCFG_PCFG2_POSITION, _AD1PCFG_PCFG4_POSITION,
+    _AD1PCFG_PCFG8_POSITION, _AD1PCFG_PCFG10_POSITION, _AD1PCFG_PCFG12_POSITION, _AD1PCFG_PCFG14_POSITION};
+
+
+static unsigned int ActivePins;
+static unsigned int PinsToAdd;
+static unsigned int PinsToRemove;
+static unsigned int PinCount;
+static unsigned int ADValues[NUM_AD_PINS];
+static int PortMapping[NUM_AD_PINS];
+
+static char ADActive;
+static char ADNewData = FALSE;
+
+
+
+/*******************************************************************************
+ * PRIVATE FUNCTION PROTOTYPES                                                            *
+ ******************************************************************************/
+char AD_SetPins(void);
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @function AD_Init(void)
+ * @param None
+ * @return SUCCESS or ERROR
+ * @brief Initializes the A/D subsystem and enable battery voltage monitoring
+ * @author Max Dunne, 2013.08.10 */
+char AD_Init(void)
+{
+
+    if (ADActive) {
+        return ERROR;
+    }
+    int pin = 0;
+	ADActive = TRUE;
+    AD_SetPins();
+    for (pin = 0; pin < NUM_AD_PINS; pin++) {
+        ADValues[pin] = -1;
+    }
+    IEC1bits.AD1IE = 0;
+    IFS1bits.AD1IF = 0;
+    IPC6bits.AD1IP = 1;
+    IPC6bits.AD1IS = 3;
+    IEC1bits.AD1IE = 1;
+    AD1CON1bits.ON = 1;
+    ADNewData = FALSE;
+    //wait for first reading to ensure  battery monitor starts in the right spot
+    while (!AD_IsNewDataReady()) {
+#ifdef AD_DEBUG_VERBOSE
+        PutChar('.');
+#endif
+    }
+    //set the first values for the battery monitor filter
+
+    return SUCCESS;
+}
+
+/**
+ * @function AD_AddPins(unsigned int AddPins)
+ * @param AddPins - Use #defined AD_XX OR'd together for each A/D Pin you wish to add
+ * @return SUCCESS OR ERROR
+ * @brief Remove pins from the A/D system.  If any pin is not active it returns an error
+ * @author Max Dunne, 2013.08.15 */
+char AD_AddPins(unsigned int AddPins)
+{
+    if (!ADActive) {
+        dbprintf("%s called before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((AddPins == 0) || (AddPins > ALLADPINS)) {
+        dbprintf("%s returning ERROR with pins outside range: %X\r\n", __FUNCTION__, AddPins);
+        return ERROR;
+    }
+    if (ActivePins & AddPins) {
+        dbprintf("%s Returning ERROR for pins already in state: %X \r\n", __FUNCTION__, AddPins);
+        return ERROR;
+    }
+    //setting the pins to be added during the next interrupt cycle
+    PinsToAdd |= AddPins;
+    return SUCCESS;
+}
+
+/**
+ * @function AD_RemovePins(unsigned int RemovePins)
+ * @param RemovePins - Use #defined AD_XX OR'd together for each A/D Pin you wish to remove
+ * @return SUCCESS OR ERROR
+ * @brief Remove pins from the A/D system. If any pin is not active it returns an error
+ * @author Max Dunne, 2013.08.15 */
+char AD_RemovePins(unsigned int RemovePins)
+{
+    if (!ADActive) {
+        dbprintf("%s called before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((RemovePins == 0) || (RemovePins > ALLADPINS)) {
+        dbprintf("%s returning ERROR with pins outside range: %X\r\n", __FUNCTION__, RemovePins);
+        return ERROR;
+    }
+    if (!(ActivePins & RemovePins)) {
+        dbprintf("%s Returning ERROR for pins already in state: %X \r\n", __FUNCTION__, RemovePins);
+        return ERROR;
+    }
+
+    //setting the pins to be added during the next interrupt cycle
+    PinsToRemove |= RemovePins;
+    return SUCCESS;
+}
+
+/**
+ * @function AD_ActivePins(void)
+ * @param None
+ * @return Listing of all A/D pins that are active
+ * @brief Returns a variable of all active A/D pins. An individual pin can be determined if
+ *        active by "anding" with the AD_PORTXX Macros.
+ * @note This will not reflect changes made with AD_AddPins or AD_RemovePins until the next A/D
+ *       interrupt cycle.
+ * @author Max Dunne, 2013.08.15 */
+unsigned int AD_ActivePins(void)
+{
+    return ActivePins;
+}
+
+/**
+ * @function AD_IsNewDataReady(void)
+ * @param None
+ * @return TRUE or FALSE
+ * @brief This function returns a flag indicating that the A/D has new values since the last
+ *        read of a value
+ * @author Max Dunne, 2013.08.15 */
+char AD_IsNewDataReady(void)
+{
+    if (ADNewData) {
+        ADNewData = FALSE;
+        return TRUE;
+    }
+    return FALSE;
+}
+
+/**
+ * @function AD_ReadADPin(unsigned int Pin)
+ * @param Pin - Used #defined AD_XX to select pin
+ * @return 10-bit AD Value or ERROR
+ * @brief Reads current value from buffer for given pin
+ * @author Max Dunne, 2011.12.10 */
+unsigned int AD_ReadADPin(unsigned int Pin)
+{
+    if (!ADActive) {
+        dbprintf("%s returning ERROR before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if (!(ActivePins & Pin)) {
+        dbprintf("%s returning error with unactivated pin: %X %X\r\n", __FUNCTION__, Pin);
+        return ERROR;
+    }
+    unsigned char TranslatedPin = 0;
+    while (Pin > 1) {
+
+        Pin >>= 1;
+        TranslatedPin++;
+    }
+    return ADValues[PortMapping[TranslatedPin]];
+}
+
+/**
+ * @function AD_End(void)
+ * @param None
+ * @return None
+ * @brief Disables the A/D subsystem and release the pins used
+ * @author Max Dunne, 2013.09.20 */
+void AD_End(void)
+{
+    int pin;
+    if (!ADActive) {
+        return;
+    }
+    IEC1bits.AD1IE = 0;
+    AD1CON1CLR = _AD1CON1_ON_MASK;
+    PinsToRemove = ALLADPINS;
+    AD_SetPins();
+    for (pin = 0; pin < NUM_AD_PINS; pin++) {
+        ADValues[pin] = -1;
+    }
+    ActivePins = 0;
+    PinCount = 0;   
+    AD1PCFG = 0xFF;
+}
+
+/*******************************************************************************
+ * PRIVATE FUNCTIONS                                                       *
+ ******************************************************************************/
+
+/**
+ * @function AD_SetPins(void)
+ * @param None
+ * @return SUCCESS OR ERROR
+ * @brief Connects pins in PinstoAdd to the A/D system and removes the pins in PinsToRemove
+ * @note Private Function. DO NOT USE.
+ * @author Max Dunne, 2013.08.15 */
+char AD_SetPins(void)
+{
+    if (!ADActive) {
+        return ERROR;
+    }
+    unsigned int cssl = 0;
+    unsigned int pcfg = 0;
+    unsigned int rempcfg = 0;
+    unsigned char CurPin = 0;
+    unsigned int CurPinOrder = 0x00;
+    int ADMapping[NUM_AD_PINS_UNO];
+    AD1CON1CLR = _AD1CON1_ON_MASK; //disable A/D system and interrupt
+    IEC1bits.AD1IE = 0;
+    PinCount = 0;
+
+    //determine the new set of active pins
+    ActivePins |= PinsToAdd;
+    ActivePins &= ~PinsToRemove;
+    //initialize the mapping array to -1
+    for (CurPin = 0; CurPin < NUM_AD_PINS_UNO; CurPin++) {
+        ADMapping[CurPin] = -1;
+    }
+    for (CurPin = 0; CurPin < NUM_AD_PINS; CurPin++) {
+        PortMapping[CurPin] = -1; //reset all ports to unmapped
+        if ((ActivePins & (1 << CurPin)) != 0) { //if one of the pins is active
+            //build masks and remap pins
+            cssl |= AD1CSSL_MASKS[CurPin];
+            pcfg |= AD1PCFG_MASKS[CurPin];
+            ADMapping[AD1PCFG_POS[CurPin]] = CurPin;
+            PinCount++;
+        }
+        if ((PinsToRemove & (1 << CurPin)) != 0) {//generate removal masks
+            rempcfg |= AD1PCFG_MASKS[CurPin];
+        }
+    }
+    for (CurPin = 0; CurPin < NUM_AD_PINS_UNO; CurPin++) {//translate AD Mapping to Port Mapping
+        if (ADMapping[CurPin] != -1) {
+            PortMapping[ADMapping[CurPin]] = CurPinOrder;
+            CurPinOrder++;
+        }
+    }
+    
+    // this realistically does not need to be done every time we add a pin but it makes sure it works
+    // future revisions many of these settings should be handled in the init
+    AD1CON1bits.FORM = 0; // output is unsigned integer
+    AD1CON1bits.SSRC = 0b111; // internal counter handles timing of sampling an conversion
+    AD1CON1bits.ASAM = 1; // start sampling again after conversion is complete
+
+    AD1CON2bits.VCFG = 0; // use AVdd and AVss for + and -
+    AD1CON2bits.CSCNA = 1; // mux inputs together
+    AD1CON2bits.SMPI = PinCount - 1; // set the number to scan for 1 less than wanted as zero is 1 to scan
+    AD1CON2bits.BUFM = 0; // configure bugger as one large buffer
+
+    AD1CON3bits.ADRC = 0; // use Peripheral clock for timing
+    AD1CON3bits.SAMC = 29; // set the sample time, completely arbitrary, nearly the slowest possible
+    AD1CON3bits.ADCS = 0x32; // set the conversion time, again arbitrary 
+
+    AD1PCFGCLR = pcfg;
+    TRISBSET = pcfg;
+    AD1CSSL = cssl;
+    AD1PCFGSET = rempcfg;
+    AD1CON1SET = _AD1CON1_ON_MASK;
+    PinsToAdd = 0;
+    PinsToRemove = 0;
+    IEC1bits.AD1IE = 1;
+    return SUCCESS;
+}
+
+/**
+ * @function ADCIntHandler
+ * @param None
+ * @return None
+ * @brief Interrupt Handler for A/D. Reads all used pins into buffer.
+ * @note This function is not to be called by the user
+ * @author Max Dunne, 2013.08.25 */
+void __ISR(_ADC_VECTOR, ipl1auto) ADCIntHandler(void)
+{
+    unsigned char CurPin = 0;
+    IFS1bits.AD1IF = 0;
+    for (CurPin = 0; CurPin <= PinCount; CurPin++) {
+        ADValues[CurPin] = (*(&ADC1BUF0+((CurPin) * 4))); //read in new set of values, pointer math from microchip
+    }
+    //calculate new filtered battery voltage
+
+    //if pins are changed add pins
+    if (PinsToAdd | PinsToRemove) {
+        AD_SetPins();
+    }
+    ADNewData = TRUE;
+}
+
+
+
+
+
+//#define AD_TEST
+#ifdef AD_TEST
+
+
+
+#include <xc.h>
+#include "serial.h"
+#include "AD.h"
+#include <stdio.h>
+
+#define DELAY(x)    {int wait; for (wait = 0; wait <= x; wait++) {asm("nop");}}
+#define A_BIT       18300
+#define A_LOT       183000
+//#define DISABLE_ADINIT
+#define TIMES_TO_READ 4000
+
+#define ODD_ACTIVE (AD_A1|AD_A3|AD_A5)
+#define EVEN_ACTIVE (AD_A0|AD_A2|AD_A4)
+
+#define ALLADMINUSBATT ALLADPINS 
+
+//#define ADPinHasChanged(PinsAdded)
+
+int main(void)
+{
+    unsigned int wait = 0;
+    int readcount = 0;
+    unsigned int CurPin = 0;
+    unsigned int PinListing = 0;
+    char FunctionResponse = 0;
+    char TestFailed = FALSE;
+    BOARD_Init();
+    AD_Init();
+    AD_AddPins(AD_A0);
+    while(1){
+        if(AD_IsNewDataReady())
+        {
+            printf("\r\nReading: %d", AD_ReadADPin(AD_A0));
+            DELAY(A_BIT);
+        }
+    }
+//    //END MAXL
+//    printf("\r\nUno A/D Test Harness\r\nThis will initialize all A/D pins and read them %d times\r\n", TIMES_TO_READ);
+//    //printf("Value of pcfg before test: %X\r\n", AD1PCFG);
+//    // while(!IsTransmitEmpty());
+//    //AD_Init(BAT_VOLTAGE);
+//    //AD_Init();
+//    printf("Testing functionality before initialization\r\n");
+//
+//    /*adding pins individually */
+//    printf("AD_AddPins on each pin indvidually which results in failure: ");
+//    for (CurPin = 1; CurPin < ALLADPINS; CurPin <<= 1) {
+//        FunctionResponse = AD_AddPins(CurPin);
+//        if (FunctionResponse != ERROR) {
+//            TestFailed = TRUE;
+//            break;
+//        }
+//    }
+//    if (TestFailed) {
+//        printf("FAIL\r\n");
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    TestFailed = FALSE;
+//    /*removing pins individually*/
+//    printf("AD_RemovePins on each pin indvidually which results in failure: ");
+//    for (CurPin = 1; CurPin < ALLADPINS; CurPin <<= 1) {
+//        FunctionResponse = AD_RemovePins(CurPin);
+//        if (FunctionResponse != ERROR) {
+//            TestFailed = TRUE;
+//            break;
+//        }
+//    }
+//    if (TestFailed) {
+//        printf("FAIL\r\n");
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    TestFailed = FALSE;
+//    /*listing pins while inactive*/
+//    printf("AD_ActivePins which should return 0: ");
+//    PinListing = AD_ActivePins();
+//    if (PinListing != 0x0) {
+//        printf("FAILED\r\n");
+//
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    //    /*calling ned when inactive*/
+//    //        printf("AD_End which should fail: ");
+//    //        FunctionResponse = AD_End();
+//    //        if (FunctionResponse != ERROR) {
+//    //            printf("FAILED\r\n");
+//    //        } else {
+//    //            printf("PASSED\r\n");
+//    //        }
+//    /*activating module*/
+//    printf("initializing using AD_Init: ");
+//    FunctionResponse = AD_Init();
+//    if (FunctionResponse != SUCCESS) {
+//        printf("FAILED\r\n");
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    /*attempting to reactivate*/
+//    printf("initializing using AD_Init again returns error: ");
+//    FunctionResponse = AD_Init();
+//    if (FunctionResponse != ERROR) {
+//        printf("FAILED\r\n");
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    /*each pin added should succeed*/
+//    printf("Adding each pin using AD_AddPins indivdually: ");
+//    for (CurPin = 1; CurPin < ALLADMINUSBATT; CurPin <<= 1) {
+//        PinListing = AD_ActivePins();
+//        FunctionResponse = AD_AddPins(CurPin);
+//        if (FunctionResponse != SUCCESS) {
+//            TestFailed = TRUE;
+//            break;
+//        }
+//        while (AD_ActivePins() != (PinListing | CurPin));
+//    }
+//    if (TestFailed) {
+//        printf("FAIL\r\n");
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    /*removing each pin should succeed */
+//    printf("Removing each pin using AD_RemovePins indivdually: ");
+//    for (CurPin = 1; CurPin < ALLADMINUSBATT; CurPin <<= 1) {
+//        PinListing = AD_ActivePins();
+//        FunctionResponse = AD_AddPins(CurPin);
+//        if (FunctionResponse != SUCCESS) {
+//            TestFailed = TRUE;
+//            break;
+//        }
+//        while (AD_ActivePins() != (PinListing | CurPin));
+//    }
+//    if (TestFailed) {
+//        printf("FAIL: %X\r\n", 0xFEED);
+//    } else {
+//        printf("PASSED\r\n");
+//    }
+//    while (1);
+//    printf("We will now add the odd pins and wait for them to be activated");
+//    AD_AddPins(ODD_ACTIVE);
+//    while (!(AD_ActivePins() & ODD_ACTIVE)) {
+//        if (IsTransmitEmpty()) {
+//            printf("%X\r\n", AD_ActivePins());
+//        }
+//    }
+//    printf("The Odd pins are now active as shown by Active pins: %X\r\n", AD_ActivePins());
+//    printf("We will now enable the even pins and wait for them to be activated");
+//    AD_AddPins(EVEN_ACTIVE);
+//    while (!(AD_ActivePins() & EVEN_ACTIVE));
+//    printf("The Even pins are now active as shown by Active pins: %X\r\n", AD_ActivePins());
+//
+//
+//    char numtoread = NUM_AD_PINS;
+//    unsigned char cur = 0;
+//    DELAY(400000)
+//    while (readcount <= TIMES_TO_READ) {
+//        DELAY(100000);
+//        printf("\r\n");
+//        for (cur = 0; cur < numtoread; cur++) {
+//            printf("%d\t", AD_ReadADPin(1 << cur));
+//        }
+//        printf("\r\n");
+//        readcount++;
+//    }
+//    printf("Done Reading Them\r\n");
+//    AD_End();
+//    printf("Value of pcfg after test: %X", AD1PCFG);
+//
+//    return 0;
+}
+#endif
\ No newline at end of file
diff --git a/src/Ascii.c b/src/Ascii.c
new file mode 100644
index 0000000000000000000000000000000000000000..43f54b6d7f7c10cefc5897286c3d0c42cffbe9bd
--- /dev/null
+++ b/src/Ascii.c
@@ -0,0 +1,857 @@
+#include "Ascii.h"
+
+/*
+ * This file defines a bitmap font corresponding to the standard ASCII character set (0-7F).
+ */
+const unsigned char ascii[256][6] =
+{
+    // Non-printing characters 0x00 - 0x1F
+    {0,0,0,0,0,0},
+	{ // top of oven, on (0x01)
+        0b00000101,
+        0b11110011,
+        0b00000101,
+        0b11110011,
+        0b00000101,
+        0b11110011
+    },
+	{ // top of oven, off (0x02)
+        0b00000101,
+        0b00000011,
+        0b00000101,
+        0b00000011,
+        0b00000101,
+        0b00000011
+    },
+	{ // bottom of oven, on (0x03)
+        0b10100000,
+        0b11001111,
+        0b10100000,
+        0b11001111,
+        0b10100000,
+        0b11001111
+    },
+	{ // bottom of oven, off (0x04)
+        0b10100000,
+        0b11000000,
+        0b10100000,
+        0b11000000,
+        0b10100000,
+        0b11000000
+    },{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},
+
+    { // (space) 0x20
+        0b00000000,
+        0b00000000,
+        0b00000000,
+        0b00000000,
+        0b00000000,
+        0b00000000
+    },
+    { // ! 0x21
+        0b00000000,
+        0b00000000,
+        0b01011110,
+        0b00000000,
+        0b00000000,
+        0b00000000
+    },
+    { // " 0x22
+        0b00001100,
+        0b00000010,
+        0b00000000,
+        0b00001100,
+        0b00000010,
+        0b00000000
+    },
+    { // # 0x23
+        0b00010100,
+        0b01111111,
+        0b00010100,
+        0b01111111,
+        0b00010100,
+        0b00000000
+    },
+    { // $ 0x24
+        0b00100100,
+        0b00101010,
+        0b01111111,
+        0b00101010,
+        0b00010010,
+        0b00000000
+    },
+    { // % 0x25
+        0b00100011,
+        0b00010011,
+        0b00001000,
+        0b01100100,
+        0b01100010,
+        0b00000000
+    },
+    { // & 0x26
+        0b00110110,
+        0b01001001,
+        0b01010001,
+        0b00100010,
+        0b01010000,
+        0b00000000
+    },
+    { // ' 0x27
+        0b00000000,
+        0b00000000,
+        0b00001100,
+        0b00000010,
+        0b00000000,
+        0b00000000
+    },
+    { // ( 0x28
+        0b00000000,
+        0b00000000,
+        0b00111110,
+        0b01000001,
+        0b00000000,
+        0b00000000
+    },
+    { // ) 0x29
+        0b00000000,
+        0b01000001,
+        0b00111110,
+        0b00000000,
+        0b00000000,
+        0b00000000
+    },
+    { // * 0x2A
+        0b00001010,
+        0b00000100,
+        0b00011111,
+        0b00000100,
+        0b00001010,
+        0b00000000
+    },
+    { // + 0x2B
+        0b00001000,
+        0b00001000,
+        0b00111110,
+        0b00001000,
+        0b00001000,
+        0b00000000
+    },
+    { // , 0x2C
+        0b00000000,
+        0b00000000,
+        0b01010000,
+        0b00110000,
+        0b00000000,
+        0b00000000
+    },
+    { // - 0x2D
+        0b00001000,
+        0b00001000,
+        0b00001000,
+        0b00001000,
+        0b00001000,
+        0b00000000
+    },
+    { // . 0x2E
+        0b00000000,
+        0b01100000,
+        0b01100000,
+        0b00000000,
+        0b00000000,
+        0b00000000
+    },
+    { // / 0x2F
+        0b01000000,
+        0b00110000,
+        0b00001000,
+        0b00000110,
+        0b00000001,
+        0b00000000
+    },
+    { // 0 0x30
+        0b00111110,
+        0b01010001,
+        0b01001001,
+        0b01000101,
+        0b00111110,
+        0b00000000
+    },
+    { // 1 0x31
+        0b01000010,
+        0b01000010,
+        0b01111111,
+        0b01000000,
+        0b01000000,
+        0b00000000
+    },
+    { // 2 0x32
+        0b01000110,
+        0b01100001,
+        0b01010001,
+        0b01001001,
+        0b01000110,
+        0b00000000
+    },
+    { // 3 0x33
+        0b00100010,
+        0b01000001,
+        0b01001001,
+        0b01001001,
+        0b00110110,
+        0b00000000
+    },
+    { // 4 0x34
+        0b00011000,
+        0b00010100,
+        0b00010010,
+        0b01111111,
+        0b00010000,
+        0b00000000
+    },
+    { // 5 0x35
+        0b01001111,
+        0b01001001,
+        0b01001001,
+        0b01001001,
+        0b00110001,
+        0b00000000
+    },
+    { // 6 0x36
+        0b00111100,
+        0b01001010,
+        0b01001001,
+        0b01001001,
+        0b00110000,
+        0b00000000
+    },
+    { // 7 0x37
+        0b00000001,
+        0b01110001,
+        0b00001001,
+        0b00000101,
+        0b00000011,
+        0b00000000
+    },
+    { // 8 0x38
+        0b00110110,
+        0b01001001,
+        0b01001001,
+        0b01001001,
+        0b00110110,
+        0b00000000
+    },
+    { // 9 0x39
+        0b00000110,
+        0b01001001,
+        0b01001001,
+        0b00101001,
+        0b00011110,
+        0b00000000
+    },
+    { // : 0x3A
+        0b00000000,
+        0b00000000,
+        0b00110110,
+        0b00110110,
+        0b00000000,
+        0b00000000
+    },
+    { // ; 0x3B
+        0b00000000,
+        0b00000000,
+        0b01010110,
+        0b00110110,
+        0b00000000,
+        0b00000000
+    },
+    { // < 0x3C
+        0b00001000,
+        0b00010100,
+        0b00100010,
+        0b01000001,
+        0b00000000,
+        0b00000000
+    },
+    { // = 0x3D
+        0b00010100,
+        0b00010100,
+        0b00010100,
+        0b00010100,
+        0b00010100,
+        0b00000000
+    },
+    { // > 0x3E
+        0b00000000,
+        0b01000001,
+        0b00100010,
+        0b00010100,
+        0b00001000,
+        0b00000000
+    },
+    { // ? 0x3F
+        0b00000110,
+        0b00000001,
+        0b01010001,
+        0b00001001,
+        0b00000110,
+        0b00000000
+    },
+    { // @ 0x40
+        0b00111110,
+        0b01000001,
+        0b01011101,
+        0b01010101,
+        0b00111110,
+        0b00000000
+    },
+    { // A 0x41
+        0b01111110,
+        0b00001001,
+        0b00001001,
+        0b00001001,
+        0b01111110,
+        0b00000000
+    },
+    { // B 0x42
+        0b01111111,
+        0b01001001,
+        0b01001001,
+        0b01001001,
+        0b00110110,
+        0b00000000
+    },
+    { // C 0x43
+        0b00111110,
+        0b01000001,
+        0b01000001,
+        0b01000001,
+        0b01000001,
+        0b00000000
+    },
+    { // D 0x44
+        0b01111111,
+        0b01000001,
+        0b01000001,
+        0b01000001,
+        0b00111110,
+        0b00000000
+    },
+    { // E 0x45
+        0b01111111,
+        0b01001001,
+        0b01001001,
+        0b01001001,
+        0b01000001,
+        0b00000000
+    },
+    { // F 0x46
+        0b01111111,
+        0b00001001,
+        0b00001001,
+        0b00001001,
+        0b00000001,
+        0b00000000
+    },
+    { // G 0x47
+        0b00111110,
+        0b01000001,
+        0b01000001,
+        0b01001001,
+        0b00111001,
+        0b00000000
+    },
+    { // H 0x48
+        0b01111111,
+        0b00001000,
+        0b00001000,
+        0b00001000,
+        0b01111111,
+        0b00000000
+    },
+    { // I 0x49
+        0b01000001,
+        0b01000001,
+        0b01111111,
+        0b01000001,
+        0b01000001,
+        0b00000000
+    },
+    { // J 0x4A
+        0b00110001,
+        0b01000001,
+        0b01000001,
+        0b00111111,
+        0b00000001,
+        0b00000000
+    },
+    { // K 0x4B
+        0b01111111,
+        0b00001000,
+        0b00001000,
+        0b00010100,
+        0b01100011,
+        0b00000000
+    },
+    { // L 0x4C
+        0b01111111,
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b00000000
+    },
+    { // M 0x4D
+        0b01111111,
+        0b00000010,
+        0b00001100,
+        0b00000010,
+        0b01111111,
+        0b00000000
+    },
+    { // N 0x4E
+        0b01111111,
+        0b00000100,
+        0b00001000,
+        0b00010000,
+        0b01111111,
+        0b00000000
+    },
+    { // O 0x4F
+        0b00111110,
+        0b01000001,
+        0b01000001,
+        0b01000001,
+        0b00111110,
+        0b00000000
+    },
+    { // P 0x50
+        0b01111111,
+        0b00001001,
+        0b00001001,
+        0b00001001,
+        0b00000110,
+        0b00000000
+    },
+    { // Q 0x51
+        0b00111110,
+        0b01000001,
+        0b01010001,
+        0b00100001,
+        0b01011110,
+        0b00000000
+    },
+    { // R 0x52
+        0b01111111,
+        0b00001001,
+        0b00001001,
+        0b00001001,
+        0b01110110,
+        0b00000000
+    },
+    { // S 0x53
+        0b01000110,
+        0b01001001,
+        0b01001001,
+        0b01001001,
+        0b00110001,
+        0b00000000
+    },
+    { // T 0x54
+        0b00000001,
+        0b00000001,
+        0b01111111,
+        0b00000001,
+        0b00000001,
+        0b00000000
+    },
+    { // U 0x55
+        0b00111111,
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b00111111,
+        0b00000000
+    },
+    { // V 0x56
+        0b00011111,
+        0b00100000,
+        0b01000000,
+        0b00100000,
+        0b00011111,
+        0b00000000
+    },
+    { // W 0x57
+        0b00111111,
+        0b01000000,
+        0b00110000,
+        0b01000000,
+        0b00111111,
+        0b00000000
+    },
+    { // X 0x58
+        0b01100011,
+        0b00010100,
+        0b00001000,
+        0b00010100,
+        0b01100011,
+        0b00000000
+    },
+    { // Y 0x59
+        0b00000111,
+        0b00001000,
+        0b01110000,
+        0b00001000,
+        0b00000111,
+        0b00000000
+    },
+    { // Z 0x5A
+        0b01100001,
+        0b01010001,
+        0b01001001,
+        0b01000101,
+        0b01000011,
+        0b00000000
+    },
+    { // [ 0x5B
+        0b00000000,
+        0b01111111,
+        0b01000001,
+        0b01000001,
+        0b00000000,
+        0b00000000
+    },
+    { // \ 0x5C
+        0b00000001,
+        0b00000110,
+        0b00001000,
+        0b00110000,
+        0b01000000,
+        0b00000000
+    },
+    { // ] 0x5D
+        0b00000000,
+        0b01000001,
+        0b01000001,
+        0b01111111,
+        0b00000000,
+        0b00000000
+    },
+    { // ^ 0x5E
+        0b00000100,
+        0b00000010,
+        0b00000001,
+        0b00000010,
+        0b00000100,
+        0b00000000
+    },
+    { // _ 0x5F
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b00000000
+    },
+    { // ` 0x60
+        0b00000000,
+        0b00000001,
+        0b00000010,
+        0b00000100,
+        0b00000000,
+        0b00000000
+    },
+    { // a 0x61
+        0b00100000,
+        0b01010100,
+        0b01010100,
+        0b01010100,
+        0b01111000,
+        0b00000000
+    },
+    { // b 0x62
+        0b01111111,
+        0b01000100,
+        0b01000100,
+        0b01000100,
+        0b00111000,
+        0b00000000
+    },
+    { // c 0x63
+        0b00111000,
+        0b01000100,
+        0b01000100,
+        0b01000100,
+        0b01000100,
+        0b00000000
+    },
+    { // d 0x64
+        0b00111000,
+        0b01000100,
+        0b01000100,
+        0b01000100,
+        0b01111111,
+        0b00000000
+    },
+    { // e 0x65
+        0b00111000,
+        0b01010100,
+        0b01010100,
+        0b01010100,
+        0b01011000,
+        0b00000000
+    },
+    { // f 0x66
+        0b00001000,
+        0b01111110,
+        0b00001001,
+        0b00001001,
+        0b00000010,
+        0b00000000
+    },
+    { // g 0x67
+        0b00001000,
+        0b01010100,
+        0b01010100,
+        0b01010100,
+        0b00111000,
+        0b00000000
+    },
+    { // h 0x68
+        0b01111111,
+        0b00000100,
+        0b00000100,
+        0b00000100,
+        0b01111000,
+        0b00000000
+    },
+    { // i 0x69
+        0b00000000,
+        0b01001000,
+        0b01111010,
+        0b01000000,
+        0b00000000,
+        0b00000000
+    },
+    { // j 0x6A
+        0b00100000,
+        0b01000000,
+        0b01000000,
+        0b00111010,
+        0b00000000,
+        0b00000000,
+    },
+    { // k 0x6B
+        0b01111111,
+        0b00010000,
+        0b00010000,
+        0b00101000,
+        0b01000100,
+        0b00000000
+    },
+    { // l 0x6C
+        0b00000000,
+        0b00000001,
+        0b01111111,
+        0b01000000,
+        0b00000000,
+        0b00000000
+    },
+    { // m 0x6D
+        0b01111100,
+        0b00000100,
+        0b01111000,
+        0b00000100,
+        0b01111100,
+        0b00000000
+    },
+    { // n 0x6E
+        0b01111100,
+        0b00001000,
+        0b00000100,
+        0b00000100,
+        0b01111000,
+        0b00000000
+    },
+    { // o 0x6F
+        0b00111000,
+        0b01000100,
+        0b01000100,
+        0b01000100,
+        0b00111000,
+        0b00000000
+    },
+    { // p 0x70
+        0b11111100,
+        0b00100100,
+        0b00100100,
+        0b00100100,
+        0b00011000,
+        0b00000000
+    },
+    { // q 0x71
+        0b00011000,
+        0b00100100,
+        0b00100100,
+        0b00100100,
+        0b11111100,
+        0b00000000
+    },
+    { // r 0x72
+        0b01111100,
+        0b00001000,
+        0b00000100,
+        0b00000100,
+        0b00000100,
+        0b00000000
+    },
+    { // s 0x73
+        0b01001000,
+        0b01010100,
+        0b01010100,
+        0b01010100,
+        0b00100100,
+        0b00000000
+    },
+    { // t 0x74
+        0b00000100,
+        0b00111110,
+        0b01000100,
+        0b01000100,
+        0b00000000,
+        0b00000000
+    },
+    { // u 0x75
+        0b00111100,
+        0b01000000,
+        0b01000000,
+        0b01000000,
+        0b00111100,
+        0b00000000
+    },
+    { // v 0x76
+        0b00011100,
+        0b00100000,
+        0b01000000,
+        0b00100000,
+        0b00011100,
+        0b00000000
+    },
+    { // w 0x77
+        0b00111100,
+        0b01000000,
+        0b00100000,
+        0b01000000,
+        0b00111100,
+        0b00000000
+    },
+    { // x 0x78
+        0b01000100,
+        0b00101000,
+        0b00010000,
+        0b00101000,
+        0b01000100,
+        0b00000000
+    },
+    { // y 0x79
+        0b00001100,
+        0b01010000,
+        0b01010000,
+        0b01010000,
+        0b00111100,
+        0b00000000
+    },
+    { // z 0x7A
+        0b01000100,
+        0b01100100,
+        0b01010100,
+        0b01001100,
+        0b01000100,
+        0b00000000
+    },
+    { // { 0x7B
+        0b00001000,
+        0b00001000,
+        0b00110110,
+        0b01000001,
+        0b00000000,
+        0b00000000
+    },
+    { // | 0x7C
+        0b00000000,
+        0b00000000,
+        0b01111111,
+        0b00000000,
+        0b00000000,
+        0b00000000
+    },
+    { // } 0x7D
+        0b00000000,
+        0b01000001,
+        0b00110110,
+        0b00001000,
+        0b00001000,
+        0b00000000
+    },
+    { // ~ 0x7E
+        0b00001000,
+        0b00000100,
+        0b00001000,
+        0b00001000,
+        0b00000100,
+        0b00000000
+    },
+    { // DEL 0x7F
+        0b00000000,
+        0b00010000,
+        0b00111000,
+        0b00010000,
+        0b00000000,
+        0b00000000
+    },
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 131
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 135
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 139
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 143
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 147
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 151
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 155
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 159
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 163
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 167
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 171
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 175
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 179
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 183
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 187
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 191
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 195
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 199
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 203
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 207
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 211
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 215
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 219
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 223
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 227
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 231
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 235
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 239
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 243
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 247
+	{ // degree 0xF8 (248)
+        0b00000000,
+        0b00000110,
+        0b00001001,
+        0b00001001,
+        0b00000110,
+        0b00000000
+    },
+	{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}, // 251
+    {0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}  // 255
+};
\ No newline at end of file
diff --git a/src/BOARD.c b/src/BOARD.c
new file mode 100644
index 0000000000000000000000000000000000000000..a166c266853f0242eda04c89a730e09bcf666768
--- /dev/null
+++ b/src/BOARD.c
@@ -0,0 +1,174 @@
+/*
+ * File:   BOARD.c
+ * Author: Max
+ *
+ * Created on December 19, 2012, 2:08 PM
+ */
+
+
+#include <BOARD.h>
+#include <xc.h>
+#ifndef BOARD_TEST
+#include <serial.h>
+#endif
+
+
+
+/*******************************************************************************
+ * PRAGMAS                                                                     *
+ ******************************************************************************/
+// Configuration Bits
+// SYSCLK = 80MHz
+// PBCLK  = 40MHz
+// using POSC w/ PLL, XT mode
+#pragma config FPBDIV     = DIV_2
+#pragma config FPLLIDIV   = DIV_2     // Set the PLL input divider to 2, seems to
+#pragma config IESO       = OFF       // Internal/External Switch
+#pragma config POSCMOD    = XT        // Primary Oscillator Configuration for XT osc mode
+#pragma config OSCIOFNC   = OFF       // Disable clock signal output
+#pragma config FCKSM      = CSECMD    // Clock Switching and Monitor Selection
+#pragma config WDTPS      = PS1       // Specify the watchdog timer interval (unused)
+#pragma config FWDTEN     = OFF       // Disable the watchdog timer
+#pragma config ICESEL     = ICS_PGx2  // Allow for debugging with the Uno32
+#pragma config PWP        = OFF       // Keep the program flash writeable
+#pragma config BWP        = OFF       // Keep the boot flash writeable
+#pragma config CP         = OFF       // Disable code protect
+#pragma config FNOSC 		= PRIPLL	//Oscillator Selection Bits
+#pragma config FSOSCEN 		= OFF		//Secondary Oscillator Enable
+#pragma config FPLLMUL 		= MUL_20	//PLL Multiplier
+#pragma config FPLLODIV 	= DIV_1 	//System PLL Output Clock Divide
+
+
+
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+#define SYSTEM_CLOCK 80000000L
+#define  PB_CLOCK SYSTEM_CLOCK/2
+#define TurnOffAndClearInterrupt(Name) INTEnable(Name,INT_DISABLED); INTClearFlag(Name)
+
+/**
+ * @function BOARD_Init(void)
+ * @param None
+ * @return None
+ * @brief Set the clocks up for the board, initializes the serial port, and turns on the A/D
+ *        subsystem for battery monitoring
+ * @author Max Dunne, 2013.09.15  */
+void BOARD_Init()
+{
+    //sets the system clock to the optimal frequency given the system clock
+    //SYSTEMConfig(SYSTEM_CLOCK, SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
+    //sets the divisor to 2 to ensure 40Mhz peripheral bus
+    //OSCSetPBDIV(OSC_PB_DIV_2);
+
+
+    //disables all A/D pins for a clean start
+    AD1PCFG = 0xffff;
+
+    // get rid of JTAG before it kills us
+    DDPCONbits.JTAGEN = 0;
+
+
+    // this section of code comes from microchips deprecated plib
+    // dealing with the interrupt handler is tricky enough to the point of I have no desire to re-invent the wheel
+
+    unsigned int val;
+    // set the CP0 cause IV bit high
+    asm volatile("mfc0   %0,$13" : "=r"(val));
+    val |= 0x00800000;
+    asm volatile("mtc0   %0,$13" : "+r"(val));
+    INTCONSET = _INTCON_MVEC_MASK;
+    unsigned int status = 0;
+    asm volatile("ei    %0" : "=r"(status));
+
+
+#ifndef BOARD_TEST
+    //initializes the uart to give printf capabilities
+    SERIAL_Init();
+#endif
+    //printf("CMPE118 IO stack is now initialized\r\n");
+    char Time[] = __TIME__;
+    srand(Time[7] << Time[0]);
+
+}
+
+/**
+ * @function BOARD_End(void)
+ * @param None
+ * @return None
+ * @brief Shuts down all peripherals. Turns all pins into input
+ * @author Max Dunne, 2013.09.20  */
+void BOARD_End()
+{
+
+    // kill off all interrupts except serial and clear their flags
+    IEC0CLR = ~(_IEC0_U1TXIE_MASK | _IEC0_U1RXIE_MASK);
+    IFS0CLR = ~(_IFS0_U1TXIF_MASK | _IFS0_U1RXIF_MASK);
+
+    // kill off all interrupts except A/D and clear their flags
+    IEC1CLR = ~(_IEC1_AD1IE_MASK);
+    IFS0CLR = ~(_IFS1_AD1IF_MASK);
+
+    // set all ports to be digital inputs
+    TRISB = 0xff;
+    TRISC = 0xff;
+    TRISD = 0xff;
+    TRISE = 0xff;
+    TRISF = 0xff;
+    TRISG = 0xff;
+
+
+}
+
+/**
+ * @function BOARD_GetPBClock(void)
+ * @param None
+ * @return PB_CLOCK - Speed the peripheral clock is running in hertz
+ * @brief Returns the speed of the peripheral clock.  Nominally at 40Mhz
+ * @author Max Dunne, 2013.09.01  */
+unsigned int BOARD_GetPBClock()
+{
+    return PB_CLOCK;
+}
+
+
+#ifdef BOARD_TEST
+
+
+#define MAXPOWTWO 20
+
+int main(void)
+{
+    BOARD_Init();
+
+    //    int curPow2 = 12;
+    //    int i;
+    TRISDbits.TRISD4 = 0;
+    LATDbits.LATD4 = 0;
+    TRISE = 0; // turn on the leds on the top board
+    
+    unsigned int ledCount = 0;
+    
+    //will do a pulse of each power of two
+    //using scope can determine the length of timing for nops in test harnesses
+    //    for(curPow2=0;curPow2<=MAXPOWTWO;curPow2++)
+    //    {
+    //    while (1) {
+    //        LATDbits.LATD4 ^= 1;
+    //        for (i = 0; i < 1830000; i++) {
+    //            asm("nop");
+    //        }
+    //        //LATDbits.LATD4 = 0;
+    //    }
+    //will need a scope to test this module, the led should blink at the maximum rate
+    while (1) {
+        LATDbits.LATD4 ^= 1;
+        LATE = (ledCount>>16) & 0xFF;
+        ledCount++;
+    }
+}
+
+
+#endif
\ No newline at end of file
diff --git a/src/I2C.c b/src/I2C.c
new file mode 100644
index 0000000000000000000000000000000000000000..702f72b849b40146fd4676ceda9213c3cdaa20e4
--- /dev/null
+++ b/src/I2C.c
@@ -0,0 +1,274 @@
+/* 
+ * File:   I2C.c
+ * Author: Max
+ *
+ * Created on February 22, 2018, 1:06 PM
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <BOARD.h>
+#include <serial.h>
+#include <I2C.h>
+#include <xc.h>
+
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+#define F_PB (BOARD_GetPBClock())
+
+//#define DEBUG_I2C_CHANNEL
+
+
+#ifdef DEBUG_I2C_CHANNEL
+#define dbprintf(...) printf(__VA_ARGS__)
+#else
+#define dbprintf(...)
+#endif
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                           *
+ ******************************************************************************/
+static char I2C_Inited = FALSE;
+static char lastCommandError = FALSE;
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @Function I2C_Init(Rate)
+ * @param Rate - Clock rate for the I2C system
+ * @return The clock rate set for the I2C system, 0 if already inited
+ * @brief  Initializes the I2C System for use with the IMU
+ * @author Max Dunne */
+unsigned int I2C_Init(unsigned int Rate) {
+    unsigned int RealRate = 0;
+    if (!I2C_Inited) {
+
+        I2C1CONbits.ON = 0;
+
+        I2C1BRG = (F_PB / (2 * Rate)) - 2;
+
+
+        I2C1CONbits.ON = 1;
+        I2C_Inited = TRUE;
+        RealRate = (F_PB) / ((I2C1BRG + 2)*2);
+        I2C1CONbits.PEN = 1;
+    while (I2C1CONbits.PEN == 1);
+    }
+    
+    return RealRate;
+}
+
+
+/**
+ * @Function I2C_ReadRegister(unsigned char I2CAddress,unsigned char deviceRegisterAddress)
+ * @param I2CAddresss - 7-bit address of I2C device wished to interact with
+ * @param deviceRegisterAddress - 8-bit address of register on device
+ * @return Value at Register or 0
+ * @brief  Reads one device register on chosen I2C device
+ * @author Max Dunne*/
+unsigned char I2C_ReadRegister(unsigned char I2CAddress, unsigned char deviceRegisterAddress) {
+    unsigned char regContents = 0;
+    lastCommandError = FALSE;
+    if (!I2C_Inited) {
+        return 0;
+    }
+
+    I2C1CONbits.SEN = 1; // send a start condition
+    while (I2C1CONbits.SEN == 1); //wait for it to end, this is internal and can not stall
+
+    I2C1TRN = I2CAddress << 1; // load transmission buffer with address and R/W and transmit
+
+    while (I2C1STATbits.TRSTAT != 0); //wait for it, again no error possible
+
+    if (I2C1STATbits.ACKSTAT == 1) {
+        dbprintf("\r\nDevice failed to ACK\r\n");
+        return 0;
+    }
+
+    I2C1TRN = deviceRegisterAddress;
+
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        dbprintf("\r\nDevice failed to ACK\r\n");
+        return 0;
+    }
+    I2C1CONbits.RSEN = 1;
+
+    while (I2C1CONbits.RSEN == 1);
+    I2C1TRN = (I2CAddress << 1) + 1;
+
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        dbprintf("\r\nDevice failed to ACK\r\n");
+        return 0;
+    }
+    I2C1CONbits.RCEN = 1;
+    while (I2C1STATbits.RBF != 1);
+    regContents = I2C1RCV;
+    I2C1CONbits.PEN = 1;
+    while (I2C1CONbits.PEN == 1);
+    return regContents;
+
+
+
+    return regContents;
+}
+
+
+/**
+ * @Function I2C_WriteReg(unsigned char I2CAddress, unsigned char deviceRegisterAddress, char data)
+ * @param I2CAddresss - 7-bit address of I2C device wished to interact with
+ * @param deviceRegisterAddress - 8-bit address of register on device
+ * @param data - data wished to be written to register
+ * @return 0 if error and 1 if success
+ * @brief  Writes one device register on chosen I2C device
+ * @author Max Dunne*/
+unsigned char I2C_WriteReg(unsigned char I2CAddress,unsigned char deviceRegisterAddress, char data) {
+
+    I2C1CONbits.SEN = 1;
+    while (I2C1CONbits.SEN == 1);
+    I2C1TRN = (I2CAddress << 1);
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        //printf("Device Responded with NACK upon addressing");
+        return 0;
+    }
+
+    I2C1TRN = deviceRegisterAddress;
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+
+        return 0;
+    }
+    I2C1TRN = data;
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        return 0;
+    }
+    I2C1CONbits.PEN = 1;
+    while (I2C1CONbits.PEN == 1);
+
+    return 1;
+}
+
+
+/**
+ * @Function I2C_ReadInt(char I2CAddress, char deviceRegisterAddress, char isBigEndian)
+ * @param I2CAddresss - 7-bit address of I2C device wished to interact with
+ * @param deviceRegisterAddress - 8-bit lower address of register on device
+ * @param isBigEndian - Boolean determining if device is big or little endian
+ * @return 0 if error and 1 if success
+ * @brief  Reads two sequential registers to build a 16-bit value. isBigEndian
+ * whether the first bits are either the high or low bits of the value
+ * @author Max Dunne*/
+int I2C_ReadInt(char I2CAddress, char deviceRegisterAddress, char isBigEndian) {
+    short Data = 0;
+    I2C1CONbits.SEN = 1;
+    while (I2C1CONbits.SEN == 1);
+    I2C1TRN = I2CAddress << 1;
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        //printf("Device Responded with NACK");
+        return 0;
+    }
+    I2C1TRN = deviceRegisterAddress;
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        //printf("Device Responded with NACK");
+        return 0;
+    }
+    I2C1CONbits.RSEN = 1;
+    while (I2C1CONbits.RSEN == 1);
+    I2C1TRN = (I2CAddress << 1) + 1;
+    while (I2C1STATbits.TRSTAT != 0);
+    if (I2C1STATbits.ACKSTAT == 1) {
+        //printf("Device Responded with NACK");
+        return 0;
+    }
+    I2C1CONbits.RCEN = 1;
+    //while(I2C1CONbits.RCEN==1);
+    while (I2C1STATbits.RBF != 1);
+    if (isBigEndian) {
+        Data = I2C1RCV << 8;
+    } else {
+        Data = I2C1RCV;
+    }
+    I2C1CONbits.ACKEN = 1;
+    while (I2C1CONbits.ACKEN == 1);
+    I2C1CONbits.RCEN = 1;
+
+    while (I2C1STATbits.RBF != 1);
+    if (isBigEndian) {
+        Data |= I2C1RCV;
+    } else {
+        Data |= I2C1RCV << 8;
+    }
+    I2C1CONbits.ACKDT = 1;
+    I2C1CONbits.ACKEN = 1;
+    while (I2C1CONbits.ACKEN == 1);
+    I2C1CONbits.ACKDT = 0;
+    I2C1CONbits.PEN = 1;
+    while (I2C1CONbits.PEN == 1);
+    return Data;
+
+
+}
+
+
+
+#ifdef I2C_TEST_HARNESS
+
+#define I2C_ADDRESS 0b1001000 
+
+static enum {
+    TEMPERATURE_REGISTER,
+    CONFIGURATION_REGISTER,
+    TEMPERATURE_HYST_REGISTER,
+    TEMPERATURE_LIMIT_REGISTER
+} TCN75A_REGISTERS;
+
+int main(void) {
+
+    BOARD_Init();
+
+
+    char conRegister = 0;
+    char newconRegister = 0;
+    unsigned int temperatureValue = 0;
+
+    printf("\r\nStarting I2C at %d and getting %d", I2C_DEFUALT_RATE, I2C_Init(I2C_DEFUALT_RATE));
+
+    printf("\r\nWe will now read in a config register, alter its value, write it back, and confirm the change");
+
+    conRegister = I2C_ReadRegister(I2C_ADDRESS, CONFIGURATION_REGISTER);
+    printf("\r\nConfiguration register is currently 0X%X", conRegister);
+    conRegister ^= 0b10;
+    printf("\r\nWe wish to change con register to   0X%X", conRegister);
+    printf("\r\nThis changes the alert pin which will have no side effects");
+    I2C_WriteReg(I2C_ADDRESS, CONFIGURATION_REGISTER, conRegister);
+
+    newconRegister = I2C_ReadRegister(I2C_ADDRESS, CONFIGURATION_REGISTER);
+
+    if (newconRegister == conRegister) {
+        printf("\r\nConfiguration successfully changed to 0X%X", newconRegister);
+    } else {
+        printf("\r\nFailed configuration change");
+        while (1);
+    }
+    printf("The code will now print 16-bit temperature data at max serial rate");
+
+    while (1) {
+        if (IsTransmitEmpty()) {
+            temperatureValue = I2C_ReadInt(I2C_ADDRESS, TEMPERATURE_REGISTER, TRUE);
+            printf("\r\nCurrent Temperature is %f", (float) (temperatureValue >> 4) / 16.0); //need to convert to celsius fp
+        }
+    }
+    while (1);
+    return 1;
+}
+
+#endif
\ No newline at end of file
diff --git a/src/MPU9250.c b/src/MPU9250.c
new file mode 100644
index 0000000000000000000000000000000000000000..897d85c5d7858563f6ff97d57bf1fd41e3750404
--- /dev/null
+++ b/src/MPU9250.c
@@ -0,0 +1,271 @@
+
+
+#include <MPU9250.h>
+#include <I2C.h>
+#include <BOARD.h>
+
+#ifdef MPU9250_TEST
+#include <stdio.h>
+#endif
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+//#define DEBUG_MPU_CHANNEL
+
+#ifdef DEBUG_MPU_CHANNEL
+#define dbprintf(...) printf(__VA_ARGS__)
+#else
+#define dbprintf(...)
+#endif
+
+#define MAG_I2C_ADDRESS 0x0C
+#define ACCGYR_I2C_ADDRESS 0x68
+
+#define MAG_WHOAMI_VALUE 0x48
+#define MPU_WHOAMI_VALUE 0x71
+
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                           *
+ ******************************************************************************/
+
+static enum {
+    AK_WHOAMI_REGISTER,
+    AK_HXL = 0x03,
+    AK_HXH,
+    AK_HYL,
+    AK_HYH,
+    AK_HZL,
+    AK_HZH,
+    AK_ST2 = 0x9,
+    AK_CNTL1 = 0xA,
+    AK_CNTL2
+} AK8963_REGISTERS;
+
+static enum {
+    MPU_SMPLRT_DIV = 25,
+    MPU_CONFIG,
+    MPU_GYRO_CONFIG,
+    MPU_ACCEL_CONFIG,
+    MPU_ACCEL_CONFIG2,
+    MPU_INT_BYPASS_CONFIG = 55,
+    MPU_INT_CONFIG,
+    ACCEL_XOUT_H = 59,
+    ACCEL_XOUT_L,
+    ACCEL_YOUT_H,
+    ACCEL_YOUT_L,
+    ACCEL_ZOUT_H,
+    ACCEL_ZOUT_L,
+    GYRO_XOUT_H = 67,
+    GYRO_XOUT_L,
+    GYRO_YOUT_H,
+    GYRO_YOUT_L,
+    GYRO_ZOUT_H,
+    GYRO_ZOUT_L,
+    MPU_POWER_CTRL1 = 107,
+    MPU_WHOAMI_REGISTER = 117
+} MPU9250_REGISTERS;
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @Function MPU9250_Init(Rate)
+
+ * @return 0 if error, 1 if succeeded
+ * @brief  Initializes the MPU 9250 for usage. This will set all sensors to approximately 100HZ
+ * and Accel: 2g,Gyro:  250dps and Mag: 16-bit for the sensors
+ * @author Max Dunne */
+char MPU9250_Init(void) {
+    unsigned int intReturn;
+    unsigned char byteReturn;
+
+    intReturn = I2C_Init(I2C_DEFUALT_RATE);
+    if (intReturn != I2C_DEFUALT_RATE) {
+        return FALSE; // fail out if I2C does not set a rate that makes sense
+    }
+
+    // we have to configure the MPU first due to idiocy with the I2C setup internally
+    byteReturn = I2C_ReadRegister(ACCGYR_I2C_ADDRESS, MPU_WHOAMI_REGISTER);
+    //    printf("\r\n%X", byteReturn);
+    if (byteReturn != MPU_WHOAMI_VALUE) {
+        return FALSE; // make sure we are talking to the right device first
+    }
+
+    I2C_WriteReg(ACCGYR_I2C_ADDRESS, MPU_POWER_CTRL1, 0x01); // turn it on and hopefully use pll
+
+    I2C_WriteReg(ACCGYR_I2C_ADDRESS, MPU_CONFIG, 0x03); // don't really want a dlp but turning it off is non trivial
+    // setting it to fastest bandwidth for the gyro
+    //byteReturn = I2C_ReadRegister(ACCGYR_I2C_ADDRESS,MPU_GYRO_CONFIG);
+    //printf("\r\ngyro config: %d",byteReturn);
+    I2C_WriteReg(ACCGYR_I2C_ADDRESS, MPU_GYRO_CONFIG, 0x00); //set scale on gyro to 250 degrees /s
+    dbprintf("\r\nGYRO CONFIG Set To: 0X%X", I2C_ReadRegister(ACCGYR_I2C_ADDRESS, MPU_GYRO_CONFIG));
+    I2C_WriteReg(ACCGYR_I2C_ADDRESS, MPU_SMPLRT_DIV, 5); // set the output data rate to 100Hz
+    dbprintf("\r\nSMART RATE Set To: 0X%X", I2C_ReadRegister(ACCGYR_I2C_ADDRESS, MPU_SMPLRT_DIV));
+
+    // we now can configure the accelerometer
+
+    I2C_WriteReg(ACCGYR_I2C_ADDRESS, MPU_ACCEL_CONFIG2, 0b1001);
+    //sets the bandwidth to 184 and internal to 1K, actually output controlled by smart divider
+    dbprintf("\r\nACCEL CONFIG2 Set To: 0X%X", I2C_ReadRegister(ACCGYR_I2C_ADDRESS, MPU_ACCEL_CONFIG2));
+
+    I2C_WriteReg(ACCGYR_I2C_ADDRESS, MPU_ACCEL_CONFIG, 0);
+    dbprintf("\r\nACCEL CONFIG Set To: 0X%X", I2C_ReadRegister(ACCGYR_I2C_ADDRESS, MPU_ACCEL_CONFIG));
+
+    // finally we configure the I2C to allow us to talk to the mag
+    I2C_WriteReg(ACCGYR_I2C_ADDRESS, MPU_INT_BYPASS_CONFIG, 0x22);
+    dbprintf("\r\nBypass CONFIG Set To: 0X%X", I2C_ReadRegister(ACCGYR_I2C_ADDRESS, MPU_INT_BYPASS_CONFIG));
+
+
+    byteReturn = I2C_ReadRegister(MAG_I2C_ADDRESS, AK_WHOAMI_REGISTER);
+    //    printf("\r\n%X", byteReturn);
+    if (byteReturn != MAG_WHOAMI_VALUE) {
+        return FALSE; // make sure we are talking to the right device first
+    }
+
+    //configure output rate and scale
+    //    I2C_WriteReg(MAG_I2C_ADDRESS,AK_CNTL1,0b0);
+    //    I2C_WriteReg(MAG_I2C_ADDRESS,AK_CNTL1,0b1111);
+    //    I2C_WriteReg(MAG_I2C_ADDRESS,AK_CNTL1,0b0);
+    I2C_WriteReg(MAG_I2C_ADDRESS, AK_CNTL1, 0b10110);
+    dbprintf("\r\nMAG CNTL1 CONFIG Set To: 0X%X", I2C_ReadRegister(MAG_I2C_ADDRESS, AK_CNTL1));
+    return TRUE;
+}
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadAccelX(void) {
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, ACCEL_XOUT_H, TRUE);
+}
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadAccelY(void) {
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, ACCEL_YOUT_H, TRUE);
+}
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadAccelZ(void) {
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, ACCEL_ZOUT_H, TRUE);
+}
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadGyroX(void) {
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, GYRO_XOUT_H, TRUE);
+}
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadGyroY(void) {
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, GYRO_YOUT_H, TRUE);
+}
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadGyroZ(void) {
+    return I2C_ReadInt(ACCGYR_I2C_ADDRESS, GYRO_ZOUT_H, TRUE);
+}
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadMagX(void) {
+    short SensorValue = I2C_ReadInt(MAG_I2C_ADDRESS, AK_HXL, FALSE);
+    I2C_ReadRegister(MAG_I2C_ADDRESS, AK_ST2);
+    return SensorValue;
+}
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadMagY(void) {
+    short SensorValue = I2C_ReadInt(MAG_I2C_ADDRESS, AK_HYL, FALSE);
+    I2C_ReadRegister(MAG_I2C_ADDRESS, AK_ST2);
+    return SensorValue;
+}
+
+/**
+ * @Function MPU9250_Read*()
+ * @param None
+ * @return Returns raw sensor reading
+ * @brief reads sensor axis as given by name
+ * @author Max Dunne*/
+int MPU9250_ReadMagZ(void) {
+    short SensorValue = I2C_ReadInt(MAG_I2C_ADDRESS, AK_HZL, FALSE);
+    I2C_ReadRegister(MAG_I2C_ADDRESS, AK_ST2);
+    return SensorValue;
+}
+
+#ifdef MPU9250_TEST
+
+#include <stdio.h>
+
+#include "serial.h"
+#include <math.h>
+
+int main(void) {
+    BOARD_Init();
+
+    int aX, aY, aZ, gX, gY, gZ, mX, mY, mZ;
+    printf("\r\nWelcome to mpu9250 test, system will be inited and configured and then data printed");
+    if (!MPU9250_Init()) {
+        printf("\r\nSensor failed to come up");
+        while (1);
+    }
+    printf("\r\nSensor is up");
+    //    while(1);
+    while (1) {
+        if (IsTransmitEmpty()) {
+            aX = MPU9250_ReadAccelX();
+            aY = MPU9250_ReadAccelY();
+            aZ = MPU9250_ReadAccelZ();
+            gX = MPU9250_ReadGyroX();
+            gY = MPU9250_ReadGyroY();
+            gZ = MPU9250_ReadGyroZ();
+            mX = MPU9250_ReadMagX();
+            mY = MPU9250_ReadMagY();
+            mZ = MPU9250_ReadMagZ();
+            printf("\r\n(X,Y,Z)Accel : (%d,%d,%d)Gyro : (%d,%d,%d)Mag: (%d,%d,%d)", aX, aY, aZ, gX, gY, gZ, mX, mY, mZ);
+            mX = 0;
+        }
+    }
+
+    while (1);
+    return 1;
+}
+
+#endif
\ No newline at end of file
diff --git a/src/Oled.c b/src/Oled.c
new file mode 100644
index 0000000000000000000000000000000000000000..8f8ae155a7c714eb0f627e0b1f7105bd01a45675
--- /dev/null
+++ b/src/Oled.c
@@ -0,0 +1,235 @@
+#include <stddef.h>
+
+
+#include "OledDriver.h"
+#include "Oled.h"
+#include "Ascii.h"
+
+// in simulator we do nothing with the hardware, printing instead
+
+void OledInit(void)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    // First initialize the PIC32 to be able to talk over SPI to the OLED.
+    OledHostInit();
+
+    // Now send initialization commands to the OLED.
+    OledDriverInitDisplay();
+
+    // Clear the frame buffer by filling it with black pixels.
+    OledClear(OLED_COLOR_BLACK);
+
+    // Finally update the screen, triggering a write of all black pixels to the screen.
+    OledUpdate();
+#endif
+}
+
+void OledSetPixel(int x, int y, OledColor color)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    // Check for valid inputs before doing anything.
+    if (x >= OLED_DRIVER_PIXEL_COLUMNS || y >= OLED_DRIVER_PIXEL_ROWS || x < 0 || y < 0) {
+        return;
+    }
+
+    // Map the x/y coordinates into a byte/bit index.
+    unsigned int index = ((y & 0xFFF8) << 4) + x;
+    unsigned int shift = y & 0x0007;
+
+    // Now set the pixel to the proper color, doing nothing if an invalid color was specified.
+    if (color == OLED_COLOR_WHITE) {
+        rgbOledBmp[index] = rgbOledBmp[index] | (1 << shift);
+    } else if (color == OLED_COLOR_BLACK) {
+        rgbOledBmp[index] = rgbOledBmp[index] & ~(1 << shift);
+    } else {
+        return;
+    }
+#endif
+}
+
+int OledGetPixel(int x, int y)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    // Check for valid inputs before doing anything.
+    if (x >= OLED_DRIVER_PIXEL_COLUMNS || y >= OLED_DRIVER_PIXEL_ROWS || x < 0 || y < 0) {
+        return OLED_COLOR_BLACK;
+    }
+
+    // Map the x/y coordinates into a byte/bit index.
+    unsigned int index = ((y & 0xFFF8) << 4) + x;
+    unsigned int shift = y & 0x0007;
+
+    // Now return the desired bit.
+    return (rgbOledBmp[index] >> shift) & 0x01;
+#else
+    return OLED_COLOR_BLACK;
+#endif
+}
+
+//in simulator this is the same as putchar
+
+uint8_t OledDrawChar(int x, int y, char c)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    if (x <= OLED_DRIVER_PIXEL_COLUMNS - ASCII_FONT_WIDTH && y <= OLED_DRIVER_PIXEL_ROWS - ASCII_FONT_HEIGHT) {
+        // We need to convert our signed char into an unsigned value to index into the ascii[] array.
+        int charIndex = (int) (unsigned char) c;
+
+        // Now first determine the columns and rows of the OLED bits that need to be modified
+        int rowMin, rowMax, colMin, colMax;
+        rowMin = y / ASCII_FONT_HEIGHT;
+        int rowY = y % ASCII_FONT_HEIGHT;
+        rowMax = (y + ASCII_FONT_HEIGHT) / OLED_DRIVER_BUFFER_LINE_HEIGHT;
+        colMin = x;
+        colMax = x + ASCII_FONT_WIDTH;
+        {
+            // Generate a positive mask for where in the column the new symbol will be drawn.
+            int colMask = ((1 << ASCII_FONT_HEIGHT) - 1) << rowY;
+            int j;
+            for (j = 0; j < colMax - colMin; ++j) {
+                int oledCol = colMin + j;
+                uint8_t newCharCol = rgbOledBmp[rowMin * OLED_DRIVER_PIXEL_COLUMNS + oledCol] & ~colMask;
+                // Make sure we always grab from the top part of the character.
+                newCharCol |= (ascii[charIndex][j] & (colMask >> rowY)) << rowY;
+                rgbOledBmp[rowMin * OLED_DRIVER_PIXEL_COLUMNS + oledCol] = newCharCol;
+            }
+        }
+        if (rowMax > rowMin) {
+            // Generate a positive mask for where in the column the new symbol will be drawn.
+            // Since we need the lower portion of the symbol, we recalculate its height.
+            int colMask = ((1 << ASCII_FONT_HEIGHT) - 1) >> (OLED_DRIVER_BUFFER_LINE_HEIGHT - rowY);
+            int j;
+            for (j = 0; j < colMax - colMin; ++j) {
+                int oledCol = colMin + j;
+                uint8_t newCharCol = rgbOledBmp[rowMax * OLED_DRIVER_PIXEL_COLUMNS + oledCol] & ~colMask;
+                // Make sure we grab the proper part of the character from the font.
+                newCharCol |= (ascii[charIndex][j] & (colMask << (OLED_DRIVER_BUFFER_LINE_HEIGHT - rowY))) >>
+                        (OLED_DRIVER_BUFFER_LINE_HEIGHT - rowY);
+                rgbOledBmp[rowMax * OLED_DRIVER_PIXEL_COLUMNS + oledCol] = newCharCol;
+            }
+        }
+    }
+#else
+    putchar(c);
+#endif
+
+    return FALSE;
+}
+
+void OledDrawString(const char *string)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    if (string == NULL) {
+        return;
+    }
+
+    // Track the current line number we're in on the OLED. Valid values are [0, OLED_NUM_LINES).
+    int line = 0;
+
+    // Track the current character we're writing to the OLED. Valid values are
+    // [0, OLED_CHARS_PER_LINE).
+    int column = 0;
+
+    // Run through all characters. The maximum length can be the number of lines times the number
+    // of characters per line + three newlines.
+    int i;
+    for (i = 0; string[i] != '\0' && i < (OLED_NUM_LINES * OLED_CHARS_PER_LINE + 3); ++i) {
+        // Move the cursor to the next line if a newline character is encountered. This allows for
+        // early line ending.
+        if (string[i] == '\n') {
+            ++line;
+            column = 0;
+            continue;
+        } else {
+            // Reset to the start of the next line if we've hit the character limit of this line
+            // without seeing a newline.
+            if (column == OLED_CHARS_PER_LINE) {
+                ++line;
+                column = 0;
+            }
+
+            // Now if we're < OLED_NUM_LINES and < OLED_CHARS_PER_LINE we can proceed. The second
+            // check is implicitly handled by the above if-statement that forces a newline after
+            // encountering a full line of characters.
+            if (line == OLED_NUM_LINES) {
+                break;
+            }
+
+            // Finally at this point, we can write characters to the OLED.
+            OledDrawChar(column * ASCII_FONT_WIDTH, line * ASCII_FONT_HEIGHT, string[i]);
+            ++column;
+        }
+    }
+#else
+    printf("%s",string);
+#endif
+}
+
+void OledClear(OledColor p)
+{
+    int i;
+    for (i = 0; i < OLED_DRIVER_BUFFER_SIZE; i++) {
+        if (p == OLED_COLOR_WHITE) {
+            rgbOledBmp[i] = 0xFF;
+        } else {
+            rgbOledBmp[i] = 0;
+        }
+    }
+}
+
+void OledSetDisplayInverted(void)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    OledDriverSetDisplayInverted();
+#endif
+}
+
+void OledSetDisplayNormal(void)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    OledDriverSetDisplayNormal();
+#endif
+}
+
+void OledOn(void)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    OledDriverInitDisplay();
+#endif
+}
+
+void OledOff(void)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    OledDriverDisableDisplay();
+#endif
+}
+
+void OledUpdate(void)
+{
+#ifndef __MPLAB_DEBUGGER_SIMULATOR
+    OledDriverUpdateDisplay();
+#endif
+}
+
+
+
+
+#ifdef OLED_TEST
+#include <stdio.h>
+
+int main(void)
+{
+    BOARD_Init();
+    OledInit();
+    char SecondLine[40];
+    OledDrawString(__DATE__ "\n "__TIME__);
+    sprintf(SecondLine,"\n\nRandom: %d",rand());
+    OledDrawString(SecondLine);
+    OledUpdate();
+    printf("\r\nTesting at " __TIME__);
+    while(1);
+    return 0;
+    
+}
+#endif
\ No newline at end of file
diff --git a/src/OledDriver.c b/src/OledDriver.c
new file mode 100644
index 0000000000000000000000000000000000000000..ae049e17d7df15bee50d0a5768358aa1b5356066
--- /dev/null
+++ b/src/OledDriver.c
@@ -0,0 +1,266 @@
+#include <stdint.h>
+
+//CMPE13 Support Library
+#include "BOARD.h"
+
+#include <xc.h>
+
+
+#include "OledDriver.h"
+
+#define SPI_CHANNEL SPI_CHANNEL2
+
+/**
+ * Constants for the various command values that can be sent to the OLED driver.
+ */
+typedef enum {
+    OLED_COMMAND_SET_DISPLAY_LOWER_COLUMN_0 = 0x00,
+    OLED_COMMAND_SET_DISPLAY_UPPER_COLUMN_0 = 0x10,
+    OLED_COMMAND_SET_PAGE = 0x22,
+    OLED_COMMAND_SET_CHARGE_PUMP = 0x8D,
+    OLED_COMMAND_SET_SEGMENT_REMAP = 0xA1,
+    OLED_COMMAND_DISPLAY_NORMAL = 0xA6,
+    OLED_COMMAND_DISPLAY_INVERTED = 0xA7,
+    OLED_COMMAND_DISPLAY_OFF = 0xAE,
+    OLED_COMMAND_DISPLAY_ON = 0xAF,
+    OLED_COMMAND_SET_PRECHARGE_PERIOD = 0xD9,
+    OLED_COMMAND_SET_COM_PINS_CONFIG = 0xDA
+} OledCommand;
+
+/**
+ * Store constants for all settings used with the OLED driver.
+ */
+typedef enum {
+    OLED_SETTING_ENABLE_CHARGE_PUMP = 0x14,
+    OLED_SETTING_MAXIMUM_PRECHARGE = 0xF1,
+    OLED_SETTING_SEQUENTIAL_COM_NON_INTERLEAVED = 0x20,
+    OLED_SETTING_REVERSE_ROW_ORDERING = 0xC8
+} OledSetting;
+
+#define OLED_DRIVER_PAGES 4
+
+/**
+ * This array is the off-screen frame buffer used for rendering.
+ * It isn't possible to read back from the OLED display device,
+ * so display data is rendered into this off-screen buffer and then
+ * copied to the display.
+ * @note Any time this is updated, An `OledDriverUpdateDisplay()` call must be performed.
+ */
+uint8_t rgbOledBmp[OLED_DRIVER_BUFFER_SIZE];
+
+// Function prototypes for internal-use functions.
+void OledPutBuffer(int size, uint8_t *buffer);
+uint8_t Spi2Put(uint8_t bVal);
+void DelayMs(unsigned int msec);
+
+/**
+ * Initialize the PIC32MX to communicate with the UG-23832HSWEG04 OLED display through the SSD1306
+ * display controller.
+ */
+void OledHostInit(void)
+{
+    // Open SPI2 as a master in 1-byte mode running at 10MHz.
+    // The peripheral bus is running at 10Mhz, and we want a 10MHz SPI bus clock.
+    int pbClkDiv = 20000000 / 10000000;
+    SPI2CON = 0; // reset and clear the SPI config register
+    SPI2CONbits.MSTEN = 1; // We are a Master
+    SPI2CONbits.CKP = 1; // Idle is high level
+    SPI2BRG = (pbClkDiv >> 1) - 1; // set the baud rate to the correct setting.
+    SPI2CONbits.ON = 1; // turn it on
+
+
+    // Set RF4-6 as digital outputs for controlling data/command selection, logic power, and display
+    // power. They're all initialized high beforehand, because that disables power.
+    OLED_DRIVER_CONTROLLER_POWER_PORT = 1;
+    OLED_DRIVER_OLED_POWER_PORT = 1;
+    OLED_DRIVER_MODE_PORT = 1;
+
+    OLED_DRIVER_MODE_TRIS = 0;
+    OLED_DRIVER_CONTROLLER_POWER_TRIS = 0;
+    OLED_DRIVER_OLED_POWER_TRIS = 0;
+
+    // Set RG9 as a digital output, tied to the reset pin on the SG1306 controller, low => reset.
+    OLED_DRIVER_RESET_PORT = 1;
+    OLED_DRIVER_RESET_TRIS = 0;
+}
+
+/**
+ * Initialize the OLED display and driver circuitry.
+ */
+void OledDriverInitDisplay(void)
+{
+    // Set the OLED into command mode.
+    OLED_DRIVER_MODE_PORT = 0;
+
+    // Power on the display logic, waiting 1ms for it to start up.
+    OLED_DRIVER_CONTROLLER_POWER_PORT = 0;
+    DelayMs(1);
+
+    // Turn off the display.
+    Spi2Put(OLED_COMMAND_DISPLAY_OFF);
+
+    // Toggle the reset pin.
+    OLED_DRIVER_RESET_PORT = 0;
+    DelayMs(1);
+    OLED_DRIVER_RESET_PORT = 1;
+
+    // Enable the charge pump and
+    Spi2Put(OLED_COMMAND_SET_CHARGE_PUMP);
+    Spi2Put(OLED_SETTING_ENABLE_CHARGE_PUMP);
+    Spi2Put(OLED_COMMAND_SET_PRECHARGE_PERIOD);
+    Spi2Put(OLED_SETTING_MAXIMUM_PRECHARGE);
+
+    // Power on the display, giving it 100ms to start up.
+    OLED_DRIVER_OLED_POWER_PORT = 0;
+
+    DelayMs(100);
+
+    // Invert row numbering so that (0,0) is upper-right.
+    Spi2Put(OLED_COMMAND_SET_SEGMENT_REMAP);
+    Spi2Put(OLED_SETTING_REVERSE_ROW_ORDERING);
+
+    // Set sequential COM configuration with non-interleaved memory.
+    Spi2Put(OLED_COMMAND_SET_COM_PINS_CONFIG);
+    Spi2Put(OLED_SETTING_SEQUENTIAL_COM_NON_INTERLEAVED);
+
+    // And turn on the display.
+    Spi2Put(OLED_COMMAND_DISPLAY_ON);
+}
+
+/**
+ * Set the LCD to display pixel values as the opposite of how they are actually stored in NVRAM. So
+ * pixels set to black (0) will display as white, and pixels set to white (1) will display as black.
+ */
+void OledDriverSetDisplayInverted(void)
+{
+    // Set the OLED into command mode.
+    OLED_DRIVER_MODE_PORT = 0;
+
+    Spi2Put(OLED_COMMAND_DISPLAY_INVERTED);
+}
+
+/**
+ * Set the LCD to display pixel values normally, where a 1 indicates white and a 0 indicates black.
+ * This is the default operating mode of the LCD and the mode it starts up in.
+ */
+void OledDriverSetDisplayNormal(void)
+{
+    // Set the OLED into command mode.
+    OLED_DRIVER_MODE_PORT = 0;
+
+    Spi2Put(OLED_COMMAND_DISPLAY_NORMAL);
+}
+
+/**
+ * Disable the Oled display before power-off. This means powering it up, sending the display off
+ * command, and finally disabling Vbat.
+ */
+void OledDriverDisableDisplay(void)
+{
+    // Set the OLED into command mode.
+    OLED_DRIVER_MODE_PORT = 0;
+
+    // Power on the OLED display logic, waiting for 1ms for it to start up.
+    OLED_DRIVER_CONTROLLER_POWER_PORT = 0;
+    DelayMs(1);
+
+    // Send the display off command.
+    Spi2Put(OLED_COMMAND_DISPLAY_OFF);
+
+    // And finally power off the display, giving it 100ms to do so.
+    OLED_DRIVER_CONTROLLER_POWER_PORT = 1;
+    DelayMs(100);
+}
+
+/**
+ * Update the display with the contents of rgb0ledBmp.
+ */
+void OledDriverUpdateDisplay(void)
+{
+    uint8_t *pb = rgbOledBmp;
+    int page;
+    for (page = 0; page < OLED_DRIVER_PAGES; page++) {
+        // Set the LCD into command mode.
+        //        PORTClearBits(OLED_DRIVER_MODE_PORT, OLED_DRIVER_MODE_BIT);
+        OLED_DRIVER_MODE_PORT = 0;
+
+        // Set the desired page.
+        Spi2Put(OLED_COMMAND_SET_PAGE);
+        Spi2Put(page);
+
+        // Set the starting column back to the origin.
+        Spi2Put(OLED_COMMAND_SET_DISPLAY_LOWER_COLUMN_0);
+        Spi2Put(OLED_COMMAND_SET_DISPLAY_UPPER_COLUMN_0);
+
+        // Return the LCD to data mode.
+        //        PORTSetBits(OLED_DRIVER_MODE_PORT, OLED_DRIVER_MODE_BIT);
+        OLED_DRIVER_MODE_PORT = 1;
+
+        // Finally write this entire column to the OLED.
+        //		SpiChnPutS()
+        OledPutBuffer(OLED_DRIVER_PIXEL_COLUMNS, pb);
+        pb += OLED_DRIVER_PIXEL_COLUMNS;
+    }
+}
+
+/**
+ * Write an entire array of uint8_ts over SPI2.
+ * @param size The number of uint8_ts to write.
+ * @param buffer The start of the uint8_t array to write.
+ */
+void OledPutBuffer(int size, uint8_t *buffer)
+{
+    uint8_t bTmp = 0;
+    int i = bTmp; //non ideal way of forcing Wall error to go away
+    for (i = 0; i < size; ++i) {
+        // Make sure the transmitter is ready
+        while (SPI2STATbits.SPITBE == 0);
+
+        // Then transmit the desired uint8_t.
+        SPI2BUF = *buffer++;
+
+        // And wait for a response. It's ignored, but we read it out of the buffer anyways to keep
+        // the buffer clear.
+        while (SPI2STATbits.SPIRBF == 0);
+        bTmp = SPI2BUF;
+    }
+}
+
+/**
+ * Performs a blocking write of a single uint8_t over SPI2. The response uint8_t is returned.
+ * @param bVal The uint8_t to write over SPI.
+ * @return The response to the transmission.
+ */
+uint8_t Spi2Put(uint8_t bVal)
+{
+    // Make sure the transmitter is ready
+    while (SPI2STATbits.SPITBE == 0);
+
+    // Then transmit the desired uint8_t.
+    SPI2BUF = bVal;
+
+    // And wait for a response.
+    while (SPI2STATbits.SPIRBF == 0);
+
+    // Before returning it.
+    uint8_t bRx = SPI2BUF;
+    return bRx;
+}
+
+/**
+ * Block the processor for the desired number of milliseconds.
+ * @note Assumes processor frequency of 80Mhz.
+ * @param msec The number of milliseconds to block for.
+ */
+void DelayMs(uint32_t msec)
+{
+    uint32_t tWait, tStart, tCurrent;
+
+    // Calculate the amount of wait time in terms of core processor frequency.
+    tWait = (80000000L / 2000) * msec;
+    asm volatile("mfc0   %0, $9" : "=r"(tStart));
+    tCurrent = tStart;
+    while ((tCurrent - tStart) < tWait) {
+        asm volatile("mfc0   %0, $9" : "=r"(tCurrent));
+    }// wait for the time to pass
+}
\ No newline at end of file
diff --git a/src/ToneGeneration.c b/src/ToneGeneration.c
new file mode 100644
index 0000000000000000000000000000000000000000..932b90f6d1a27d9c037f36dad1d426888c3f6283
--- /dev/null
+++ b/src/ToneGeneration.c
@@ -0,0 +1,168 @@
+/*
+ * File:   ToneGeneration.c
+ * Author: mdunne
+ *
+ */
+
+#include "BOARD.h"
+#include "serial.h"
+#include "ToneGeneration.h"
+#include <xc.h>
+#ifdef TONEGENERATION_TEST
+#include <stdio.h>
+#endif
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+#define F_PB (BOARD_GetPBClock())
+
+
+
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                            *
+ ******************************************************************************/
+
+static unsigned char toneOn = FALSE;
+static unsigned int toneFrequency = 0;
+static unsigned char toneSystemActive = FALSE;
+
+/*******************************************************************************
+ * PRIVATE FUNCTION PROTOTYPES                                                            *
+ ******************************************************************************/
+
+#define TONEDUTY_REGISTER OC1RS
+#define TONERESET_REGISTER OC1R
+#define TONECONFIG_REGISTER OC1CON
+
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @Function ToneGeneration_Init(void)
+ * @param None
+ * @return SUCCESS or ERROR
+ * @brief  Initializes the timer and PWM for the tone system
+ * @note  None.
+ * @author Max Dunne */
+char ToneGeneration_Init(void)
+{
+    if (toneSystemActive) {
+        return ERROR;
+    }
+
+    toneSystemActive = TRUE;
+
+    ToneGeneration_SetFrequency(DEFAULT_TONE);
+
+    ToneGeneration_ToneOff();
+    TONERESET_REGISTER = 0;
+    TONECONFIG_REGISTER = (_OC1CON_ON_MASK | 0b110 << _OC1CON_OCM_POSITION | _OC1CON_OCTSEL_MASK);
+
+    return SUCCESS;
+}
+
+/**
+ * @Function ToneGeneration_SetFrequency(unsigned int NewFrequency)
+ * @param NewFrequency - new frequency to set. 
+ * @return SUCCESS OR ERROR
+ * @brief  Changes the frequency of the ToneGeneration system.
+ * @note  Behavior of ToneGeneration during Frequency change is undocumented
+ * @author Max Dunne */
+char ToneGeneration_SetFrequency(unsigned int NewFrequency)
+{
+    if (!toneSystemActive) {
+        return ERROR;
+    }
+
+    if (NewFrequency == toneFrequency) {
+        return SUCCESS;
+    }
+    if (NewFrequency < 1) {
+        return ERROR;
+    }
+
+    T3CON = 0;
+
+    if (NewFrequency <= 1000) {
+        T3CONbits.TCKPS = 0b101; // set the prescaler to 1:32
+        PR3 = F_PB / 32 / NewFrequency;
+    } else {
+        T3CONbits.TCKPS = 0;
+    }
+
+    TMR3 = 0;
+    TONEDUTY_REGISTER = (PR3 + 1) >> 1;
+    T3CONbits.ON = 1;
+    toneFrequency = NewFrequency;
+
+    return SUCCESS;
+}
+
+/**
+ * @Function ToneGeneration_GetFrequency(void)
+ * @return Frequency of system in Hertz
+ * @brief  gets the frequency of the ToneGeneration system.
+ * @author Max Dunne */
+unsigned int ToneGeneration_GetFrequency(void)
+{
+    return toneFrequency;
+}
+
+void ToneGeneration_ToneOff(void)
+{
+    TONEDUTY_REGISTER = 0;
+    toneOn = FALSE;
+}
+
+void ToneGeneration_ToneOn(void)
+{
+    if (toneOn) {
+        return;
+    }
+    toneOn = TRUE;
+    TONEDUTY_REGISTER = (PR3 + 1) >> 1;
+    //    printf("Duty Cycles: %d\t%d\r\n", PR3, TONEDUTY_REGISTER);
+}
+
+/*******************************************************************************
+ * PRIVATE FUNCTIONS                                                       *
+ ******************************************************************************/
+
+
+#ifdef TONEGENERATION_TEST
+
+#define DELAY(x)    {int wait; for (wait = 0; wait <= x; wait++) {asm("nop");}}
+#define A_BIT       18300
+#define A_LOT       183000
+static int ToneArray[] = {TONE_196, TONE_293, TONE_440, TONE_293, TONE_440, TONE_659};
+#include <stdio.h>
+
+int main(void)
+{
+
+    BOARD_Init();
+    printf("Beginning Tone Generation Test\r\n");
+
+    ToneGeneration_Init();
+
+    int curIndex;
+    while (1) {
+        for (curIndex = 0; curIndex < 6; curIndex++) {
+            ToneGeneration_SetFrequency(ToneArray[curIndex]);
+            ToneGeneration_ToneOn();
+            printf("\r\nOutputting Tone %d", ToneArray[curIndex]);
+            DELAY(A_LOT);
+        }
+        printf("\r\nOutputting Tone %d", 0);
+        ToneGeneration_ToneOff();
+        DELAY(A_LOT);
+    }
+    return 0;
+}
+
+#endif
\ No newline at end of file
diff --git a/src/pwm.c b/src/pwm.c
new file mode 100644
index 0000000000000000000000000000000000000000..c27f661ff148da35150c3a32f512e072959db370
--- /dev/null
+++ b/src/pwm.c
@@ -0,0 +1,837 @@
+/*
+ * File:   pwm.c
+ * Author: mdunne
+ *
+ * Created on November 12, 2011, 9:28 AM
+ */
+
+#include <xc.h>
+#include <BOARD.h>
+
+#include <pwm.h>
+#include <stdio.h>
+
+
+
+
+
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+#define F_PB (BOARD_GetPBClock())
+
+//#define PWM_DEBUG_VERBOSE
+#ifdef PWM_DEBUG_VERBOSE
+#include "serial.h"
+#define dbprintf(...) while(!IsTransmitEmpty()); printf(__VA_ARGS__)
+#else
+#define dbprintf(...)
+#endif
+
+#define ALLPWMPINS (PWM_PORTZ06|PWM_PORTY12|PWM_PORTY10|PWM_PORTY04|PWM_PORTX11)
+#define NUM_PWM_CHANNELS 5
+
+
+
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                            *
+ ******************************************************************************/
+static unsigned char PWMActive = FALSE;
+//static unsigned int usedChannels;
+static volatile unsigned int * const Duty_Registers[] = {&OC1RS, &OC2RS, &OC3RS, &OC4RS, &OC5RS};
+static volatile unsigned int * const Reset_Registers[] = {&OC1R, &OC2R, &OC3R, &OC4R, &OC5R};
+static volatile unsigned int * const Config_Registers[] = {&OC1CON, &OC2CON, &OC3CON, &OC4CON, &OC5CON};
+static unsigned int PWMActivePins;
+static unsigned int PWMFrequency;
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @Function PWM_Init(void)
+ * @param None
+ * @return SUCCESS or ERROR
+ * @brief  Initializes the timer for the PWM system and set is to the default frequency
+ * @note  None.
+ * @author Max Dunne, 2011.11.12 */
+char PWM_Init(void)
+{
+    if (PWMActive) {
+        dbprintf("%s tried to init when already initialized", __FUNCTION__);
+        return ERROR;
+    }
+    PWMActive = TRUE;
+    PWM_SetFrequency(PWM_DEFAULT_FREQUENCY);
+    PWMActivePins = 0;
+    return SUCCESS;
+}
+
+/**
+ * @Function PWM_SetFrequency(unsigned int NewFrequency)
+ * @param NewFrequency - new frequency to set. best to use #defined from header
+ * @return SUCCESS OR ERROR
+ * @brief  Changes the frequency of the PWM system.
+ * @note  Behavior of PWM channels during Frequency change is undocumented
+ * @author Max Dunne, 2013.08.19 */
+char PWM_SetFrequency(unsigned int NewFrequency)
+{
+    if (!PWMActive) {
+        dbprintf("%s called before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((NewFrequency < MIN_PWM_FREQ) | (MAX_PWM_FREQ < NewFrequency)) {
+        dbprintf("%s called with frequency outside bounds: %d", __FUNCTION__, NewFrequency);
+        return ERROR;
+    }
+    if (NewFrequency != 0) {
+        //turn off the timer in preperation to restarting it with the new fequency
+        T2CON = 0;
+    }
+    if (NewFrequency <= 1000) {
+        T2CONbits.TCKPS = 0b101; // set the prescaler to 1:32
+        PR2 = F_PB / 32 / NewFrequency;
+        dbprintf("Period less than 1KHz, setting prescaler to 32\r\n");
+    } else {
+        T2CONbits.TCKPS = 0;
+        PR2 = F_PB / NewFrequency;
+        dbprintf("Period greater than 1KHz, setting prescaler to 1\r\n");
+    }
+    TMR2 = 0;
+    T2CONbits.ON = 1;
+    PWMFrequency = NewFrequency;
+    return SUCCESS;
+}
+
+/**
+ * @Function PWM_GetFrequency(void)
+ * @return Frequency of system in Hertz
+ * @brief  gets the frequency of the PWM system.
+ * @author Max Dunne, 2013.08.19 */
+unsigned int PWM_GetFrequency(void)
+{
+    if (!PWMActive) {
+        dbprintf("%s called before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    return (PWMFrequency);
+}
+
+/**
+ * @Function PWM_AddPins(unsigned short int AddPins)
+ * @param AddPins - use #defined PWM_PORTxxx OR'd together for each A/D Pin you wish to add
+ * @return SUCCESS OR ERROR
+ * @brief  Adds new pins to the PWM system.  If any pin is already active it errors 
+ * out
+ * @author Max Dunne, 2013.08.15 */
+char PWM_AddPins(unsigned short int AddPins)
+{
+    if (!PWMActive) {
+        dbprintf("%s returning ERROR before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((AddPins == 0) || (AddPins > ALLPWMPINS)) {
+        dbprintf("%s returning ERROR with pins outside range: %X\r\n", __FUNCTION__, AddPins);
+        return ERROR;
+    }
+
+    if (PWMActivePins & AddPins) {
+        dbprintf("%s Returning ERROR for pins already in state: %X \r\n", __FUNCTION__, AddPins);
+        return ERROR;
+    }
+    int PinCount = 0;
+    //sets new pwm pins in the on state while setting their duty cycles to zero
+    for (PinCount = 0; PinCount < ALLPWMPINS; PinCount++) {
+        if (AddPins & (1 << PinCount)) {
+            *Duty_Registers[PinCount] = 0;
+            *Reset_Registers[PinCount] = 0;
+            // we can use OC1 for all masks as the registers don't change
+            *Config_Registers[PinCount] = (_OC1CON_ON_MASK | 0b110 << _OC1CON_OCM_POSITION);
+            dbprintf("PWM pin #%d has been added to the system\r\n", PinCount);
+        }
+    }
+
+    PWMActivePins |= AddPins;
+    return SUCCESS;
+}
+
+/**
+ * @Function PWM_RemovePins(unsigned int PWMPins)
+ * @param RemovePins - use #defined AD_PORTxxx OR'd together for each A/D Pin you wish to remove
+ * @return SUCCESS OR ERROR
+ * @brief  Remove pins from the PWM system.  If any pin is not active it errors out
+ * @author Max Dunne, 2013.08.15 */
+char PWM_RemovePins(unsigned int PWMPins)
+{
+    if (!PWMActive) {
+        dbprintf("%s returning ERROR before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((PWMPins == 0) || (PWMPins > ALLPWMPINS)) {
+        dbprintf("%s returning ERROR with pins outside range: %X\r\n", __FUNCTION__, PWMPins);
+        return ERROR;
+    }
+    if (!(PWMActivePins & PWMPins)) {
+        dbprintf("%s Returning ERROR for pins already in state: %X \r\n", __FUNCTION__, PWMPins);
+        return ERROR;
+    }
+    int PinCount = 0;
+    for (PinCount = 0; PinCount < ALLPWMPINS; PinCount++) {
+        if (PWMPins & (1 << PinCount)) {
+            *Duty_Registers[PinCount] = 0;
+            *Reset_Registers[PinCount] = 0;
+            *Config_Registers[PinCount] &= (~_OC1CON_ON_MASK);
+        }
+    }
+    PWMActivePins &= (~PWMPins);
+    return SUCCESS;
+}
+
+/**
+ * @Function PWM_ListPins(void)
+ * @param None
+ * @return Listing of all PWM pins that are active.
+ * @brief  Returns a variable of all active pwm pins. An individual pin can be determined 
+ * if active by "anding" with the pwm_PORTXX Macros
+ * @author Max Dunne, 2013.08.19 */
+unsigned int PWM_ListPins(void)
+{
+    return PWMActivePins;
+}
+
+/**
+ * Function  PWM_SetDutyCycle
+ * @param Channels, use #defined PWM_PORTxxx
+ * @param Duty, duty cycle for the channel (0-1000)
+ * @return SUCCESS or ERROR
+ * @remark Sets the Duty Cycle for a Single Channel and returns error if that channel is not enabled
+ * @author Max Dunne
+ * @date 2011.11.12  */
+char PWM_SetDutyCycle(unsigned char Channel, unsigned int Duty)
+{
+    if (!PWMActive) {
+        dbprintf("%s returning ERROR before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((Channel == 0 || Channel > ALLPWMPINS)) {
+        dbprintf("%s returning error with pin out of bounds: %X\r\n", __FUNCTION__, Channel);
+        return ERROR;
+    }
+    if (!(Channel & PWMActivePins)) {
+        dbprintf("%s returning error with unactivated pin: %X %X\r\n", __FUNCTION__, Channel, PWMActivePins);
+        return ERROR;
+    }
+    if (Duty < 0 || Duty > 1000) {
+        dbprintf("%s returning error with duty cycle out of bounds: %d\r\n", __FUNCTION__, Duty);
+        return ERROR;
+    }
+
+    unsigned int ScaledDuty = 0;
+    unsigned int TranslatedChannel = 0;
+    ScaledDuty = ((PR2 + 1) * Duty) / MAX_PWM;
+    while (Channel > 1) {
+        Channel >>= 1;
+        TranslatedChannel++;
+    }
+    dbprintf("Translated Channel is %d and Scaled Duty is %d\r\n", TranslatedChannel, ScaledDuty);
+    *Duty_Registers[TranslatedChannel] = ScaledDuty;
+    return SUCCESS;
+
+}
+
+/**
+ * Function  PWM_GetDutyCycle
+ * @param Channels, use #defined PWM_PORTxxx
+ *
+ * @return Duty cycle
+ * @remark Gets the Duty Cycle for a Single Channel and returns error if that channel is not enabled
+ * @author Max Dunne
+ * @date 2011.11.12  */
+unsigned int PWM_GetDutyCycle(char Channel)
+{
+    if (!PWMActive) {
+        dbprintf("%s returning ERROR before enable\r\n", __FUNCTION__);
+        return ERROR;
+    }
+    if ((Channel == 0 || Channel > ALLPWMPINS)) {
+        dbprintf("%s returning error with pin out of bounds: %X\r\n", __FUNCTION__, Channel);
+        return ERROR;
+    }
+    if (!(Channel & PWMActivePins)) {
+        dbprintf("%s returning error with unactivated pin: %X %X\r\n", __FUNCTION__, Channel, PWMActivePins);
+        return ERROR;
+    }
+
+    unsigned int ScaledDuty = 0;
+    unsigned int Duty = 0;
+    unsigned int TranslatedChannel = 0;
+
+    while (Channel > 1) {
+        Channel >>= 1;
+        TranslatedChannel++;
+    }
+    ScaledDuty = *Duty_Registers[TranslatedChannel];
+    Duty = (ScaledDuty * MAX_PWM) / (PR2 + 1) + 1;
+    if (Duty > MAX_PWM) {
+        //one off error due to integer division
+        Duty = MAX_PWM;
+    }
+    dbprintf("Translated Channel is %d and unScaled Duty is %d\r\n", TranslatedChannel, Duty);
+
+    return Duty;
+
+}
+
+/**
+ * Function: PWM_End
+ * @param None
+ * @return SUCCESS or ERROR
+ * @remark Disables the PWM sub-system and releases all pins.
+ * @author Max Dunne
+ * @date 2011.11.12  */
+char PWM_End(void)
+{
+    int Curpin;
+    if (!PWMActive) {
+        return ERROR;
+    }
+    for (Curpin = 0; Curpin < NUM_PWM_CHANNELS; Curpin++) {
+        *Duty_Registers[Curpin] = 0;
+        *Reset_Registers[Curpin] = 0;
+    }
+    IEC0CLR = _IEC0_T2IE_MASK | _IEC0_OC1IE_MASK | _IEC0_OC2IE_MASK | _IEC0_OC3IE_MASK | _IEC0_OC4IE_MASK | _IEC0_OC5IE_MASK;
+
+    PWMActive = FALSE;
+    PWMFrequency = 0;
+    return SUCCESS;
+}
+
+
+/*******************************************************************************
+ * TEST HARNESS                                                                *
+ ******************************************************************************/
+#ifdef PWM_TEST
+
+#include <xc.h>
+#include <serial.h>
+#include "PWM.h"
+#include <stdio.h>
+
+
+#define DELAY(x)    for (wait = 0; wait <= x; wait++) {asm("nop");}
+#define A_BIT       40000
+#define A_LOT       80000
+#define NUM2SWEEP   10
+#define NUM2SPIN    2
+#define INC         100
+#define PWM_PORT     PWM_PORTX04
+
+#define FIFTY_PERCENT_DUTY 500
+//#define GetArray(Name)  Name ## Goober
+//#define GetArrayWrapper()
+//#define Str(x)   #Str
+//GetArray(__FUNCTION__)[0]=3;
+
+int main(void)
+{
+    unsigned int wait = 0;
+    unsigned short int duty;
+    unsigned short int i, j, k;
+    char testPassed = FALSE;
+    //    int8_t wantedResult = SUCCESS;
+    DELAY(A_BIT);
+
+    BOARD_Init();
+    printf("\nCMPE118 PWM module test harness.");
+    printf("\nInitial Test, ensure all functions return ERROR "
+            "before PWM_Init() is run\n");
+
+    /***************************************************************************
+     *            TEST PWM MODULE ERROR CHECKING BEFORE ENABLE                  *
+     ***************************************************************************/
+    //
+    // PWM_AddPins() should FAIL before enable
+    //
+    printf("\nTesting: PWM_AddPins() for each pin before enable: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_AddPins(i) == ERROR) {
+
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_AddPins(0x%03x) returned SUCCESS: TEST FAILED", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+
+    //
+    // PWM_RemovePins() should FAIL before enable
+    //
+    printf("\nTesting: PWM_RemovePins() for each pin before enable: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_RemovePins(i) == ERROR) {
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_RemovePins(0x%03x) returned SUCCESS: TEST FAILED", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+
+    //
+    // PWM_SetDutyCycle() should FAIL before enable
+    //
+    printf("\nTesting: PWM_SetDutyCycle() for each pin before enable: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_SetDutyCycle(i, FIFTY_PERCENT_DUTY) == ERROR) {
+            DELAY(A_BIT);
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_SetDutyCycle(0x%03x) returned SUCCESS "
+                    "before enable: FAILED TEST", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+
+    //
+    // PWM_GetPulseTime() should FAIL before enable
+    //
+    printf("\nTesting: PWM_GetPulseTime() for each pin before enable: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_GetDutyCycle(i) == ERROR) {
+            DELAY(A_BIT);
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_GetPulseTime(0x%03x) returned SUCCESS "
+                    "before enable: FAILED TEST", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+
+    //
+    // PWM_ListPins() should return all zeros
+    //
+    printf("\nTesting: PWM_ListPins() before enable: ");
+    if (PWM_ListPins() == 0x000) {
+        printf("PASSED");
+    } else {
+        printf("FAILED");
+        printf("\nPWM_ListPins() = 0x%03x, FAILED TEST", PWM_ListPins());
+    }
+
+    //
+    // PWM_End() should FAIL before enable
+    //
+    printf("\nTesting: PWM_End() before enable: ");
+    if (PWM_End() == ERROR) {
+        printf("PASSED");
+    } else {
+        printf("FAILED TEST");
+    }
+    printf("\nPWM Module tests before PWM_Init() complete.\n");
+
+    /***************************************************************************
+     *            ENABLE PWM MODULE TEST INIT AND END                           *
+     ***************************************************************************/
+    //
+    //Enable module, test error checking on all functions
+    //
+    DELAY(A_BIT);
+    printf("\nTesting: Enable Module and re-test bounds checking");
+    printf("\nEnabling PWM module with PWM_Init(): ");
+    if (PWM_Init() == SUCCESS) {
+        printf("PASSED");
+    } else {
+        printf("FAILED TEST");
+    }
+    DELAY(A_BIT);
+    printf("\nRe-enabling PWM module with PWM_Init(): ");
+    if (PWM_Init() == SUCCESS) {
+        printf("FAILED TEST");
+    } else {
+        printf("PASSED");
+    }
+    DELAY(A_BIT);
+    printf("PWM Frequency: %d\r\n\r\n", PWM_GetFrequency());
+    /***************************************************************************
+     *            TEST PWM_ADDPIN()                                             *
+     ***************************************************************************/
+    printf("\n\nTesting PWM_AddPins() functionality");
+    printf("\nTesting: PWM_AddPins(0x000) out of bounds: ");
+    if (PWM_AddPins(0x000) == SUCCESS) {
+        printf("FAILED TEST");
+    } else {
+        printf("PASSED");
+    }
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_AddPins(0xFFF), out of bounds: ");
+    if (PWM_AddPins(0xFFF) == SUCCESS) {
+        printf("FAILED TEST");
+    } else {
+        printf("PASSED");
+    }
+
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_AddPins() for each pin: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_AddPins(i) == SUCCESS) {
+
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_AddPins(0x%03x) returned ERROR: TEST FAILED", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_AddPins() for each pin already enabled: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_AddPins(i) == ERROR) {
+            DELAY(A_BIT);
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_AddPins(0x%03x) returned SUCCESS with pin "
+                    "already enabled: TEST FAILED", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+    printf("\nTesting PWM_ListPins() with all pins enabled: ");
+    if (PWM_ListPins() == ALLPWMPINS) {
+        printf("PASSED");
+    } else {
+        printf("FAILED");
+        printf("\nPWM_ListPins() = 0x%03x, FAILED TEST", PWM_ListPins());
+    }
+    PWM_RemovePins(PWM_ListPins()); // get rid of all pins
+
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_AddPins() for two pins simultaneously: ");
+    testPassed = TRUE;
+    for (j = 1; j <= ALLPWMPINS; j <<= 1) {
+        for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+            if (PWM_AddPins(i | j) == SUCCESS) {
+            } else {
+                testPassed = FALSE;
+                printf("\nPWM_AddPins(0x%03x) returned ERROR: TEST FAILED", i | j);
+            }
+            PWM_RemovePins(i | j); // remove currently enabled pins
+
+        }
+    }
+    if (testPassed) printf("PASSED");
+    printf("\nPWM_AddPins() Tests complete.");
+
+
+    /***************************************************************************
+     *            TEST PWM_REMOVEPIN()                                          *
+     ***************************************************************************/
+    PWM_AddPins(ALLPWMPINS); // enable all pins for remove pin test
+
+    printf("\n\nTesting PWM_RemovePins() functionality");
+    printf("\nTesting: PWM_RemovePins(0x000) out of bounds: ");
+    if (PWM_RemovePins(0x000) == SUCCESS) {
+        printf("FAILED TEST");
+    } else {
+        printf("PASSED");
+    }
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_RemovePins(0xFFF), out of bounds: ");
+    if (PWM_RemovePins(0xFFF) == SUCCESS) {
+        printf("FAILED TEST");
+    } else {
+        printf("PASSED");
+    }
+
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_RemovePins() for each pin: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_RemovePins(i) == SUCCESS) {
+
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_RemovePins(0x%03x) returned ERROR: TEST FAILED", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_RemovePins() for each pin already disabled: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_RemovePins(i) == ERROR) {
+            DELAY(A_BIT);
+        } else {
+            testPassed = FALSE;
+            printf("\nPWM_RemovePins(0x%03x) returned SUCCESS with pin "
+                    "already disabled: TEST FAILED", i);
+        }
+    }
+    if (testPassed) printf("PASSED");
+    printf("\nTesting: PWM_ListPins() with all pins disabled: ");
+    if (PWM_ListPins() == 0x000) {
+        printf("PASSED");
+    } else {
+        printf("FAILED");
+        printf("\nPWM_ListPins() = 0x%03x, FAILED TEST", PWM_ListPins());
+    }
+    printf("\nPWM_RemovePins() Tests complete.");
+
+    /***************************************************************************
+     *            TEST PWM_LISTPINS()                                            *
+     ***************************************************************************/
+    printf("\n\nTesting PWM_ListPins() functionality");
+    DELAY(A_BIT);
+    printf("\nTesting: PWM_ListPins() for each individual pin: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        PWM_AddPins(i);
+
+        if (PWM_ListPins() != i) {
+            testPassed = FALSE;
+            printf("\nPWM_ListPins() = 0x%03x does not "
+                    "match [0x%03x]: TEST FAILED", PWM_ListPins(), i);
+        }
+        PWM_RemovePins(i);
+
+    }
+    if (testPassed) printf("PASSED");
+    // now do it with all pins active
+    printf("\nTesting: PWM_ListPins() for aggregate pins: ");
+    testPassed = TRUE;
+    PWM_RemovePins(PWM_ListPins()); // get rid of all pins
+
+    for (i = 1; i <= ALLPWMPINS; i = (i << 1) + 1) {
+        PWM_AddPins(i);
+
+        if (PWM_ListPins() != i) {
+            testPassed = FALSE;
+            printf("\nPWM_ListPins() = 0x%03x does not "
+                    "match [0x%03x]: TEST FAILED", PWM_ListPins(), i);
+        }
+        PWM_RemovePins(i);
+
+    }
+    if (testPassed) printf("PASSED");
+    // now test for all enabled but one
+    printf("\nTesting: PWM_ListPins() for all pins except one: ");
+    testPassed = TRUE;
+    PWM_RemovePins(PWM_ListPins()); // get rid of all pins
+
+    PWM_AddPins(ALLPWMPINS);
+
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        if (PWM_RemovePins(i) == SUCCESS) {
+
+            if (PWM_ListPins() != (ALLPWMPINS & (~i))) {
+                testPassed = FALSE;
+                printf("\nPWM_ListPins() = 0x%03x does not "
+                        "match [0x%03x]: TEST FAILED", PWM_ListPins(), (ALLPWMPINS & (~i)));
+            }
+            PWM_AddPins(i);
+
+        }
+    }
+    if (testPassed) printf("PASSED");
+    PWM_End();
+    DELAY(A_LOT);
+
+    printf("\nPWM_ListPins() Tests complete.");
+
+    /***************************************************************************
+     *            TEST PWM_SETPULSE()                                            *
+     ***************************************************************************/
+    PWM_Init();
+    printf("\n\nTesting PWM_SetDutyCycle() functionality");
+    printf("\nALL pinse set to SERVOCENTER, all attached servos should center");
+    PWM_AddPins(ALLPWMPINS);
+
+    if (PWM_ListPins() != ALLPWMPINS) {
+        printf("ERROR, pins not enabled");
+    }
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        PWM_SetDutyCycle(i, FIFTY_PERCENT_DUTY);
+    }
+    printf("\n ");
+    for (k = 0; k < NUM2SWEEP; k++) {
+        DELAY(A_LOT);
+        printf(". ");
+    }
+
+    printf("\nSweeping pulse on ALL pins from MIN_PWM to MAX_PWM (%d times)", NUM2SWEEP);
+    printf("\nAny servos attached to pins should move from FULL CCW to FULL CW and back");
+    printf("\nOn cycle: ");
+    for (k = 0; k < NUM2SWEEP; k++) {
+        printf("%d ", k);
+        for (duty = MIN_PWM; duty < MAX_PWM; duty += INC) {
+            for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+                PWM_SetDutyCycle(i, duty);
+            }
+            DELAY(A_LOT);
+        }
+        for (duty = MIN_PWM; duty >= MAX_PWM; duty -= INC) {
+            for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+                PWM_SetDutyCycle(i, duty);
+            }
+            DELAY(A_LOT);
+        }
+    }
+    printf("\n\nSweeping pulse on EACH pin from MIN_PWM to MAX_PWM (%d times)", NUM2SPIN);
+    printf("\nAll servos attached should remain centered, each servo "
+            "will turn from FULL CCW to FULL CW in turn");
+    printf("\nOn Servo: ");
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        PWM_SetDutyCycle(i, FIFTY_PERCENT_DUTY);
+    }
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        printf("[0x%03x] ", i);
+        for (k = 0; k < NUM2SPIN; k++) {
+            for (duty = MIN_PWM; duty <= MAX_PWM; duty += INC) {
+                PWM_SetDutyCycle(i, duty);
+                DELAY(A_LOT);
+            }
+            for (duty = MAX_PWM; duty <= MIN_PWM; duty -= INC) {
+                PWM_SetDutyCycle(i, duty);
+                DELAY(A_LOT);
+            }
+        }
+        PWM_SetDutyCycle(i, FIFTY_PERCENT_DUTY);
+    }
+    printf("\nPWM_SetDutyCycle Tests complete");
+
+
+    /***************************************************************************
+     *            TEST PWM_GETPULSE()                                            *
+     ***************************************************************************/
+    printf("\n\nTesting PWM_GetPulseTime() functionality");
+    printf("\nTesting: PWM_GetPulseTime() for each pin set to SERVOCENTER: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        PWM_SetDutyCycle(i, FIFTY_PERCENT_DUTY);
+        if (PWM_GetDutyCycle(i) != FIFTY_PERCENT_DUTY) {
+            printf("\nPWM_GetPulseTime(0x%03X) FAILED: returned %d "
+                    "instead of %d", i, PWM_GetDutyCycle(i), FIFTY_PERCENT_DUTY);
+            while (!IsTransmitEmpty());
+            testPassed = FALSE;
+        }
+    }
+    if (testPassed) printf("PASSED");
+
+    printf("\nTesting: PWM_GetPulseTime() for each pin set to MIN_PWM: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        PWM_SetDutyCycle(i, MIN_PWM);
+        if (PWM_GetDutyCycle(i) != MIN_PWM) {
+            printf("\nPWM_GetPulseTime(0x%03X) FAILED: returned %d "
+                    "instead of %d", i, PWM_GetDutyCycle(i), MIN_PWM);
+            testPassed = FALSE;
+        }
+    }
+    if (testPassed) printf("PASSED");
+    while (!IsTransmitEmpty());
+    printf("\nTesting: PWM_GetPulseTime() for each pin set to MAX_PWM: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        PWM_SetDutyCycle(i, MAX_PWM);
+        if (PWM_GetDutyCycle(i) != MAX_PWM) {
+            printf("\nPWM_GetPulseTime(0x%03X) FAILED: returned %d "
+                    "instead of %d", i, PWM_GetDutyCycle(i), MAX_PWM);
+
+            testPassed = FALSE;
+        }
+    }
+    if (testPassed) printf("PASSED");
+    while (!IsTransmitEmpty());
+    printf("\nTesting: PWM_GetDutyCycle() for each pin variable value: ");
+    testPassed = TRUE;
+    for (i = 1; i <= ALLPWMPINS; i <<= 1) {
+        for (duty = MIN_PWM; duty < MAX_PWM; duty += INC) {
+            PWM_SetDutyCycle(i, duty);
+            if (PWM_GetDutyCycle(i) != duty) {
+                printf("\nPWM_GetPulseTime(0x%03X) FAILED: returned %d "
+                        "instead of %d", i, PWM_GetDutyCycle(i), duty);
+                testPassed = FALSE;
+            }
+        }
+    }
+    if (testPassed) printf("PASSED");
+    printf("\nPWM_GetPulseTime() Tests complete");
+
+
+
+    /***************************************************************************
+     *            TEST PWM_END()                                                *
+     ***************************************************************************/
+    printf("\nTesting: PWM_End() while enabled: ");
+    if (PWM_End() == SUCCESS) {
+        printf("PASSED");
+        printf("\nAll enabled pins should be high impedance (inputs)");
+    } else {
+        printf("FAILED TEST");
+    }
+    printf("\nPWM_End() Testing complete.");
+    printf("\n\nPWM MODULE Testing complete.");
+
+    while (1) {
+        ;
+    }
+}
+#endif
+
+// #ifdef PWM_TEST
+
+// #include <serial.h>
+// #include <BOARD.h>
+
+// #define MIN_RAMP 0
+// #define MAX_RAMP 1000
+// #define FIRST_PERIOD PWM_20KHZ
+// #define SECOND_PERIOD PWM_500HZ
+// #define DELAY() for(i=0;i < NOPCOUNT; i++) __asm("nop")
+// #define NOPCOUNT 520000
+
+// int main(void) {
+// unsigned int i, j;
+// BOARD_Init();
+// printf("Uno PWM Test Harness\r\n");
+// PWM_Init();
+// PWM_AddPins(PWM_PORTX11 | PWM_PORTY04 | PWM_PORTY10 | PWM_PORTY12 | PWM_PORTZ06);
+// PWM_SetFrequency(FIRST_PERIOD);
+
+
+// printf("Ramping PWM from %d-%d%% in 10%% steps at %d with a delay between\r\n", MIN_RAMP, MAX_RAMP, FIRST_PERIOD);
+// unsigned char ch = 0;
+// for (j = MIN_RAMP; j <= MAX_RAMP; j += 100) {
+// PWM_SetDutyCycle(PWM_PORTX11, j);
+// PWM_SetDutyCycle(PWM_PORTY04, j + 20);
+// PWM_SetDutyCycle(PWM_PORTY10, j + 40);
+// PWM_SetDutyCycle(PWM_PORTY12, j + 60);
+// PWM_SetDutyCycle(PWM_PORTZ06, j + 80);
+// printf("Outputting %d%% Duty Cycle\r\n", j / 10);
+// DELAY();
+// }
+// printf("Setting Period to %d and repeating ramp\r\n", SECOND_PERIOD);
+// PWM_End();
+// PWM_Init();
+// PWM_AddPins(PWM_PORTX11 | PWM_PORTY04 | PWM_PORTY10 | PWM_PORTY12 | PWM_PORTZ06);
+// PWM_SetFrequency(FIRST_PERIOD);
+// for (j = MIN_RAMP; j <= MAX_RAMP; j += 100) {
+// PWM_SetDutyCycle(PWM_PORTX11, j);
+// PWM_SetDutyCycle(PWM_PORTY04, j + 20);
+// PWM_SetDutyCycle(PWM_PORTY10, j + 40);
+// PWM_SetDutyCycle(PWM_PORTY12, j + 60);
+// PWM_SetDutyCycle(PWM_PORTZ06, j + 80);
+// printf("Outputting %d%% Duty Cycle\r\n", j / 10);
+// DELAY();
+// }
+// PWM_End();
+// return 0;
+// while (1);
+// }
+
+// #endif
\ No newline at end of file
diff --git a/src/serial.c b/src/serial.c
new file mode 100644
index 0000000000000000000000000000000000000000..89fd18cd37860f06a932dfdeb0d7ab3df0eb8b31
--- /dev/null
+++ b/src/serial.c
@@ -0,0 +1,479 @@
+
+/*
+ * File:   uart.c
+ * Author: mdunne
+ *
+ * Created on November 10, 2011, 8:42 AM
+ */
+
+#include <xc.h>
+#include <serial.h>
+#include <sys/attribs.h>
+#include <BOARD.h>
+#include <stdint.h>
+//#include <stdlib.h>
+
+
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+#define F_PB (BOARD_GetPBClock())
+#define QUEUESIZE 512
+
+/*******************************************************************************
+ * PRIVATE DATATYPES                                                           *
+ ******************************************************************************/
+typedef struct CircBuffer {
+    unsigned char buffer[QUEUESIZE];
+    int head;
+    int tail;
+    unsigned int size;
+    unsigned char overflowCount;
+} CircBuffer;
+typedef struct CircBuffer* CBRef;
+
+
+/*******************************************************************************
+ * PRIVATE FUNCTIONS PROTOTYPES                                                *
+ ******************************************************************************/
+void newCircBuffer(CBRef cB);
+void freeCircBuffer(CBRef* cB);
+unsigned int getLength(CBRef cB);
+int readHead(CBRef cB);
+int readTail(CBRef cB);
+unsigned char peak(CBRef cB);
+unsigned char readFront(CBRef cB);
+unsigned char writeBack(CBRef cB, unsigned char data);
+
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                           *
+ ******************************************************************************/
+struct CircBuffer outgoingUart;
+CBRef transmitBuffer;
+struct CircBuffer incomingUart;
+CBRef receiveBuffer;
+static uint8_t AddingToTransmit = FALSE;
+static uint8_t GettingFromReceive = FALSE;
+static uint8_t TransmitCollisionOccured = FALSE;
+static uint8_t ReceiveCollisionOccured = FALSE;
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @Function SERIAL_Init(void)
+ * @param none
+ * @return none
+ * @brief  Initializes the UART subsystem to 115200 and sets up the circular buffer
+ * @author Max Dunne, 2011.11.10 */
+
+void SERIAL_Init(void)
+{
+    transmitBuffer = (struct CircBuffer*) &outgoingUart; //set up buffer for receive
+    newCircBuffer(transmitBuffer);
+
+    receiveBuffer = (struct CircBuffer*) &incomingUart; //set up buffer for transmit
+    newCircBuffer(receiveBuffer);
+
+    U1MODE = 0;
+    U1STA = 0;
+
+    // calculate BRG value
+    unsigned int brgValue = F_PB;
+    brgValue >>= 3;
+    brgValue /= 115200;
+    brgValue++;
+    brgValue >>= 1;
+    brgValue--;
+    U1BRG = brgValue; // set the baud rate to 115200
+    // have interrupts occur whenever RX is not empty
+    U1STAbits.URXISEL = 0;
+
+    IPC6bits.U1IP = 4; //set the interrupt priority
+
+    // we now enable the module and both RX and TX
+    U1MODEbits.ON = 1; // turn on uart itself
+    U1STAbits.UTXEN = 1; // turn on TX
+    U1STAbits.URXEN = 1; // turn on RX
+    // enable the interrupts
+    IEC0bits.U1RXIE = 1;
+    IEC0bits.U1TXIE = 1;
+}
+
+/**
+ * @Function PutChar(char ch)
+ * @param ch - the char to be sent out the serial port
+ * @return None.
+ * @brief  adds char to the end of the circular buffer and forces the interrupt flag 
+ * high if nothing is currently transmitting
+ * @author Max Dunne, 2011.11.10 */
+void PutChar(char ch)
+{
+    if (getLength(transmitBuffer) != QUEUESIZE) {
+        AddingToTransmit = TRUE;
+        writeBack(transmitBuffer, ch);
+        AddingToTransmit = FALSE;
+        if (U1STAbits.TRMT) {
+            IFS0bits.U1TXIF = 1;
+        }
+        //re-enter the interrupt if we removed a character while getting another one
+        if (TransmitCollisionOccured) {
+            IFS0bits.U1TXIF = 1;
+            TransmitCollisionOccured = FALSE;
+        }
+    }
+}
+
+/**
+ * @Function GetChar(void)
+ * @param None.
+ * @return ch - char from the serial port
+ * @brief  reads first character from buffer or returns 0 if no chars available
+ * @author Max Dunne, 2011.11.10 */
+char GetChar(void)
+{
+    char ch;
+    if (getLength(receiveBuffer) == 0) {
+        ch = 0;
+    } else {
+        GettingFromReceive = TRUE;
+        ch = readFront(receiveBuffer);
+        GettingFromReceive = FALSE;
+    }
+    //re-enter the interrupt if we added a character while transmitting another one
+    if (ReceiveCollisionOccured) {
+        IFS0bits.U1RXIF = 1;
+        ReceiveCollisionOccured = FALSE;
+    }
+    return ch;
+}
+
+/**
+ * @Function _mon_putc(char c)
+ * @param c - char to be sent
+ * @return None.
+ * @brief  overwrites weakly define extern to use circular buffer instead of Microchip 
+ * functions
+ * @author Max Dunne, 2011.11.10 */
+void _mon_putc(char c)
+{
+    PutChar(c);
+}
+
+/**
+ * @Function _mon_puts(const char* s)
+ * @param s - pointer to the string to be sent
+ * @return None.
+ * @brief  overwrites weakly defined extern to use circular buffer instead of Microchip 
+ * functions
+ * @author Max Dunne, 2011.11.10 */
+void _mon_puts(const char* s)
+{
+    int i;
+    for (i = 0; i<sizeof (s); i++)
+        PutChar(s[i]);
+}
+
+/**
+ * @Function _mon_getc(int CanBlock)
+ * @param CanBlock - unused variable but required to match Microchip form
+ * @return None.
+ * @brief  overwrites weakly defined extern to use circular buffer instead of Microchip 
+ * functions
+ * @author Max Dunne, 2011.11.10 */
+int _mon_getc(int CanBlock)
+{
+    if (getLength(receiveBuffer) == 0)
+        return -1;
+    return GetChar();
+}
+
+/**
+ * @Function IsReceiveEmpty(void)
+ * @param None.
+ * @return TRUE or FALSE
+ * @brief  returns the state of the receive buffer
+ * @author Max Dunne, 2011.12.15 */
+char IsReceiveEmpty(void)
+{
+    if (getLength(receiveBuffer) == 0)
+        return TRUE;
+    return FALSE;
+}
+
+/**
+ * @Function IsTransmitEmpty(void)
+ * @param None.
+ * @return TRUE or FALSE
+ * @brief  returns the state of the receive buffer
+ * @author Max Dunne, 2011.12.15 */
+char IsTransmitEmpty(void)
+{
+    if (getLength(transmitBuffer) == 0)
+        return TRUE;
+    return FALSE;
+}
+
+/****************************************************************************
+ Function
+    IntUart1Handler
+
+ Parameters
+    None.
+
+ Returns
+    None.
+
+ Description
+    Interrupt Handle for the uart. with the PIC32 architecture both send and receive are handled within the same interrupt
+
+ Notes
+
+
+ Author
+ Max Dunne, 2011.11.10
+ ****************************************************************************/
+void __ISR(_UART1_VECTOR) IntUart1Handler(void)
+{
+    if (IFS0bits.U1RXIF) {
+        IFS0bits.U1RXIF = 0;
+        if (!GettingFromReceive) {
+            writeBack(receiveBuffer, (unsigned char) U1RXREG);
+        } else {
+            //acknowledge we have a collision and return
+            ReceiveCollisionOccured = TRUE;
+        }
+    }
+    if (IFS0bits.U1TXIF) {
+        IFS0bits.U1TXIF = 0;
+        if (!(getLength(transmitBuffer) == 0)) {
+            if (!AddingToTransmit) {
+                U1TXREG = readFront(transmitBuffer);
+            } else {
+                //acknowledge we have a collision and return
+                TransmitCollisionOccured = TRUE;
+            }
+        }
+    }
+
+}
+
+/*******************************************************************************
+ * PRIVATE FUNCTIONS                                                          *
+ ******************************************************************************/
+
+void newCircBuffer(CBRef cB)
+{
+
+    // initialize to zero
+    int i;
+    for (i = 0; i < QUEUESIZE; i++) {
+        cB->buffer[i] = 0;
+    }
+
+    // initialize the data members
+    cB->head = 0;
+    cB->tail = 0;
+    cB->size = QUEUESIZE;
+    cB->overflowCount = 0;
+
+}
+
+// this function frees the Circular Buffer CB Ref
+
+void freeCircBuffer(CBRef* cB)
+{
+    // if it is already null, nothing to free
+    if (cB == NULL || *cB == NULL) {
+        return;
+    }
+
+    // free and nil the pointer
+    //free(*cB);
+    *cB = NULL;
+}
+
+
+
+
+// Accesor Methods
+// ===============
+
+// returns the amount of unread bytes in the circular buffer
+
+unsigned int getLength(CBRef cB)
+{
+    // if the circular buffer is not null
+    if (cB != NULL) {
+        if (cB->head <= cB->tail) {
+            return (cB->tail - cB->head);
+        } else {
+            return (cB->size + cB->tail - cB->head);
+        }
+    } else {
+        return 0;
+    }
+
+
+}
+
+// returns the actual index of the head
+
+int readHead(CBRef cB)
+{
+    // if the circular buffer is not null
+    if (cB != NULL) {
+        return (cB->head);
+    } else {
+        return 0;
+    }
+
+}
+
+// returns the actual index of the tail
+
+int readTail(CBRef cB)
+{
+    // if the circular buffer is not null
+    if (cB != NULL) {
+        return (cB->tail);
+    } else {
+        return 0;
+    }
+
+}
+
+// returns the byte (actual value) that the head points to. this
+// does not mark the byte as read, so succesive calls to peak will
+// always return the same value
+
+unsigned char peak(CBRef cB)
+{
+    // if the circular buffer is not null
+    if (cB != NULL) {
+        // if there are bytes in the buffer
+        if (getLength(cB) > 0) {
+            return cB->buffer[cB->head];
+        }
+    }
+    return 0;
+}
+
+
+// Manipulation Procedures
+// ======================
+// returns the front of the circular buffer and marks the byte as read
+
+unsigned char readFront(CBRef cB)
+{
+    // if the circular buffer is not null
+    if (cB != NULL) {
+        char retVal;
+        // if there are bytes in the buffer
+        if (getLength(cB) > 0) {
+            retVal = cB->buffer[cB->head];
+            cB->head = cB->head < (cB->size - 1) ? cB->head + 1 : 0;
+            return retVal;
+        }
+        return 128;
+    }
+    return 254;
+}
+
+// writes one byte at the end of the circular buffer,
+// increments overflow count if overflow occurs
+
+unsigned char writeBack(CBRef cB, unsigned char data)
+{
+    // if the circular buffer is not null
+    if (cB != NULL) {
+        if (getLength(cB) == (cB->size - 1)) {
+            cB->overflowCount++;
+            //return 1;
+        } else {
+            cB->buffer[cB->tail] = data;
+            cB->tail = cB->tail < (cB->size - 1) ? cB->tail + 1 : 0;
+            //return 0;
+        }
+        //return 0;
+    } else {
+        return 1;
+    }
+    return 0;
+}
+
+// empties the circular buffer. It does not change the size. use with caution!!
+
+void makeEmpty(CBRef cB)
+{
+    if (cB != NULL) {
+        int i;
+        for (i = 0; i < cB->size; ++i) {
+            cB->buffer[i] = 0;
+        }
+        cB->head = 0;
+        cB->tail = 0;
+        cB->overflowCount = 0;
+    }
+}
+
+// returns the amount of times the CB has overflown;
+
+unsigned char getOverflow(CBRef cB)
+{
+    if (cB != NULL) {
+        return cB->overflowCount;
+    }
+    return 0;
+}
+
+
+
+//#define SERIAL_TEST
+#ifdef SERIAL_TEST
+#include "serial.h"
+#include "BOARD.h"
+#include <GenericTypeDefs.h>
+#include <stdio.h>
+
+//#include <plib.h>
+#define MAX_RAND (1<<10)
+//#define INUNDATION_TEST
+
+int main(void)
+{
+    BOARD_Init();
+    unsigned int i;
+    printf("\r\nUno Serial Test Harness\r\nAfter this Message the terminal should mirror any single character you type.\r\n");
+    // while(!IsTransmitEmpty());
+    unsigned int NopCount = 0;
+    unsigned char CharCount = 0;
+#ifdef INUNDATION_TEST
+    while (1) {
+        NopCount = rand() % MAX_RAND + 1;
+        //printf("%X\r\n",rand());
+        for (i = 0; i < NopCount; i++) {
+            asm("Nop");
+        }
+        for (CharCount = 32; CharCount < 128; CharCount++) {
+            //printf("%c", CharCount);
+            putchar(CharCount);
+        }
+
+    }
+#endif
+    GetChar();
+    //    unsigned char ch = 0;
+    while (1) {
+        if (IsTransmitEmpty() == TRUE)
+            if (IsReceiveEmpty() == FALSE)
+                PutChar(GetChar());
+    }
+
+    return 0;
+}
+
+#endif
\ No newline at end of file
diff --git a/src/timers.c b/src/timers.c
new file mode 100644
index 0000000000000000000000000000000000000000..f31e0b48fe001d3af9432d50ff19ea5713733953
--- /dev/null
+++ b/src/timers.c
@@ -0,0 +1,129 @@
+/*
+ * File:   timers.c
+ * Author: mdunne
+ *
+ * Created on November 15, 2011, 9:53 AM
+ */
+
+#include <xc.h>
+#include <BOARD.h>
+#include "timers.h"
+#include <sys/attribs.h>
+
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+//#define TIMERS_TEST
+
+#define F_PB (BOARD_GetPBClock())
+#define TIMER_FREQUENCY 1000
+
+/*******************************************************************************
+ * PRIVATE VARIABLES                                                           *
+ ******************************************************************************/
+
+static unsigned int milliSecondCount;
+static unsigned int microSecondCount;
+
+/*******************************************************************************
+ * PUBLIC FUNCTIONS                                                           *
+ ******************************************************************************/
+
+/**
+ * @Function TIMERS_Init(void)
+ * @param none
+ * @return None.
+ * @brief  Initializes the timer module
+ * @author Max Dunne */
+void TIMERS_Init(void)
+{
+    T5CON = 0;
+    T5CONbits.TCKPS = 0b01;
+    PR5 = (F_PB / TIMER_FREQUENCY) >> 1;
+    T5CONbits.ON = 1;
+    IFS0bits.T5IF = 0;
+    IPC5bits.T5IP = 3;
+    IEC0bits.T5IE = 1;
+}
+
+/**
+ * Function: TIMERS_GetMilliSeconds
+ * @param None
+ * @return the current MilliSecond Count
+ * @author Max Dunne
+ */
+unsigned int TIMERS_GetMilliSeconds(void)
+{
+    return milliSecondCount;
+}
+
+/**
+ * Function: TIMERS_GetMicroSeconds
+ * @param None
+ * @return the current MicroSecond Count, it will roll over in 1.9 hours
+ * @author Max Dunne
+ */
+
+unsigned int TIMERS_GetMicroSeconds(void)
+{
+    return (microSecondCount + TMR5 / 20);
+}
+
+/**
+ * @Function Timer5IntHandler(void)
+ * @param None.
+ * @return None.
+ * @brief  This is the interrupt handler to support the timer module. It will increment 
+ * time
+ * @author Max Dunne */
+
+void __ISR(_TIMER_5_VECTOR) Timer5IntHandler(void)
+{
+    IFS0bits.T5IF = 0;
+    milliSecondCount++;
+    microSecondCount += 1000;
+}
+
+
+
+
+#ifdef TIMERS_TEST
+#include "serial.h"
+#include "timers.h"
+#include <stdio.h>
+
+int main(void)
+{
+    int i = 0;
+    BOARD_Init();
+    int curMilliSeconds;
+    int curMicroSeconds;
+    printf("Welcome to The Timers Test, Module will Init and then print times, get a stopwatch and compare\r\n");
+    while (!IsTransmitEmpty());
+
+    TIMERS_Init();
+    unsigned int tick = 0;
+    //    while (1) {
+    //        if (IsTransmitEmpty()) {
+    //            printf("%d\r\n",TIMERS_GetMilliSeconds());
+    //        }
+    //    }
+    while (1) {
+        if (TIMERS_GetMilliSeconds() - tick >= 10) {
+            tick = TIMERS_GetMilliSeconds();
+            if (IsTransmitEmpty()) {
+                curMicroSeconds = TIMERS_GetMicroSeconds();
+                curMilliSeconds = TIMERS_GetMilliSeconds();
+                printf("ms: %d\tus: %d\tus/1000: %d\r\n",
+                        curMilliSeconds, curMicroSeconds, curMicroSeconds / 1000);
+            }
+        }
+    }
+
+
+
+    while (1);
+}
+
+#endif
\ No newline at end of file
diff --git a/templates/LibraryTemplate.c b/templates/LibraryTemplate.c
new file mode 100644
index 0000000000000000000000000000000000000000..8d57762ca92303bb084b2290d50e7d3b9fe6cf83
--- /dev/null
+++ b/templates/LibraryTemplate.c
@@ -0,0 +1,48 @@
+/* 
+ * File:   LibraryTemplate.c
+ * Author: <Your Name>
+ * Brief: 
+ * Created on <month> <day>, <year>, <hour> <pm/am>
+ * Modified on <month> <day>, <year>, <hour> <pm/am>
+ */
+
+/*******************************************************************************
+ * #INCLUDES                                                                   *
+ ******************************************************************************/
+
+#include "LibraryTemplate.h" // The header file for this source file. 
+
+/*******************************************************************************
+ * PRIVATE #DEFINES                                                            *
+ ******************************************************************************/
+
+
+/*******************************************************************************
+ * PRIVATE TYPEDEFS                                                            *
+ ******************************************************************************/
+
+/*******************************************************************************
+ * PRIVATE FUNCTIONS PROTOTYPES                                                 *
+ ******************************************************************************/
+
+/*******************************************************************************
+ * PUBLIC FUNCTION IMPLEMENTATIONS                                             *
+ ******************************************************************************/
+
+/*******************************************************************************
+ * PRIVATE FUNCTION IMPLEMENTATIONS                                            *
+ ******************************************************************************/
+
+
+
+/**
+ * @Function someFunction(void)
+ * @param foo, some value
+ * @return TRUE or FALSE
+ * @brief 
+ * @note 
+ * @author <Your Name>
+ * @modified <Your Name>, <year>.<month>.<day> <hour> <pm/am> */
+uint8_t someFunction(int foo);
+
+
diff --git a/templates/LibraryTemplate.h b/templates/LibraryTemplate.h
new file mode 100644
index 0000000000000000000000000000000000000000..a5e0c23e90f864dd0e2cc0c53fad28ec4a76b5b3
--- /dev/null
+++ b/templates/LibraryTemplate.h
@@ -0,0 +1,46 @@
+/* 
+ * File:   filename.h
+ * Author: <Your Name>
+ * Brief: 
+ * Created on <month> <day>, <year>, <hour> <pm/am>
+ * Modified on <month> <day>, <year>, <hour> <pm/am>
+ */
+
+#ifndef LIBRARYTEMPLATE_H // Header guard
+#define	LIBRARYTEMPLATE_H //
+
+/*******************************************************************************
+ * PUBLIC #INCLUDES                                                            *
+ ******************************************************************************/
+
+#include "otherHeaderFile.h" 
+#include "anotherOne.h"
+
+/*******************************************************************************
+ * PUBLIC #DEFINES                                                             *
+ ******************************************************************************/
+
+
+/*******************************************************************************
+ * PUBLIC TYPEDEFS                                                             *
+ ******************************************************************************/
+
+
+/*******************************************************************************
+ * PUBLIC FUNCTION PROTOTYPES                                                  *
+ ******************************************************************************/
+
+/**
+ * @Function someFunction(void)
+ * @param foo, some value
+ * @return TRUE or FALSE
+ * @brief 
+ * @note 
+ * @author <Your Name>,
+ * @modified <Your Name>, <year>.<month>.<day> <hour> <pm/am> */
+uint8_t someFunction(int foo);
+
+
+
+#endif	/* LIBRARYTEMPLATE_H */ // End of header guard
+
